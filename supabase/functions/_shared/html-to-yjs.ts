/**
 * HTML to Y.js ProseMirror Converter
 *
 * Parses HTML into ProseMirror document structure and applies it to a Y.js XmlFragment.
 * This allows AI-generated HTML to be converted to collaborative document updates.
 */

import * as Y from 'npm:yjs@13.6.18';

/**
 * Parse HTML and convert to ProseMirror JSON structure
 * This is a simplified parser that handles the HTML generated by the AI
 */
export function htmlToProseMirrorJSON(html: string): any {
  // Remove itinerary wrapper tags if present
  const cleanHtml = html.replace(/<\/?itinerary[^>]*>/g, '').trim();

  if (!cleanHtml) {
    return {
      type: 'doc',
      content: [
        { type: 'paragraph', content: [] }
      ]
    };
  }

  const content: any[] = [];

  // Split by block-level tags
  const blockRegex = /<(h[1-3]|p|ul|ol|blockquote)(?:\s[^>]*)?>(.+?)<\/\1>/gis;
  let match;
  let lastIndex = 0;

  while ((match = blockRegex.exec(cleanHtml)) !== null) {
    const [fullMatch, tagName, innerContent] = match;

    if (tagName.startsWith('h')) {
      // Heading
      const level = parseInt(tagName[1]) as 1 | 2 | 3;
      const textContent = parseInlineContent(innerContent);
      content.push({
        type: 'heading',
        attrs: { level },
        content: textContent
      });
    } else if (tagName === 'p') {
      // Paragraph
      const textContent = parseInlineContent(innerContent);
      content.push({
        type: 'paragraph',
        content: textContent
      });
    } else if (tagName === 'ul' || tagName === 'ol') {
      // List
      const listItems = parseListItems(innerContent);
      content.push({
        type: tagName === 'ul' ? 'bullet_list' : 'ordered_list',
        content: listItems
      });
    } else if (tagName === 'blockquote') {
      // Blockquote
      const textContent = parseInlineContent(innerContent);
      content.push({
        type: 'blockquote',
        content: [{
          type: 'paragraph',
          content: textContent
        }]
      });
    }

    lastIndex = match.index + fullMatch.length;
  }

  // If no content parsed, try to parse as simple text
  if (content.length === 0 && cleanHtml.trim()) {
    const textContent = parseInlineContent(cleanHtml);
    content.push({
      type: 'paragraph',
      content: textContent
    });
  }

  return {
    type: 'doc',
    content: content.length > 0 ? content : [{ type: 'paragraph', content: [] }]
  };
}

/**
 * Parse inline content (text, strong, em, geo-marks)
 */
function parseInlineContent(html: string): any[] {
  const content: any[] = [];

  // Simple tokenizer for inline content
  const tokens = html.split(/(<[^>]+>)/g).filter(Boolean);

  let currentMarks: any[] = [];

  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i].trim();
    if (!token) continue;

    if (token.startsWith('<')) {
      // It's a tag
      if (token.startsWith('<strong')) {
        currentMarks.push({ type: 'strong' });
      } else if (token === '</strong>') {
        currentMarks = currentMarks.filter(m => m.type !== 'strong');
      } else if (token.startsWith('<em')) {
        currentMarks.push({ type: 'em' });
      } else if (token === '</em>') {
        currentMarks = currentMarks.filter(m => m.type !== 'em');
      } else if (token.match(/<span\s+class="geo-mark"/)) {
        // Parse geo-mark attributes
        const geoMarkAttrs = parseGeoMarkAttrs(token);
        const textContent = tokens[i + 1] || '';

        // Geo-marks are inline nodes, not marks
        content.push({
          type: 'geoMark',
          attrs: geoMarkAttrs,
          content: [{ type: 'text', text: textContent }]
        });

        // Skip the text token since we already processed it
        i++;
      }
      // Ignore closing tags and other tags
    } else {
      // It's text content
      const text = decodeHTMLEntities(token);
      if (text.trim()) {
        const textNode: any = { type: 'text', text };
        if (currentMarks.length > 0) {
          textNode.marks = [...currentMarks];
        }
        content.push(textNode);
      }
    }
  }

  return content.length > 0 ? content : [];
}

/**
 * Parse list items from HTML
 */
function parseListItems(html: string): any[] {
  const items: any[] = [];
  const itemRegex = /<li(?:\s[^>]*)?>(.+?)<\/li>/gis;
  let match;

  while ((match = itemRegex.exec(html)) !== null) {
    const innerContent = match[1];
    const textContent = parseInlineContent(innerContent);
    items.push({
      type: 'list_item',
      content: [{
        type: 'paragraph',
        content: textContent
      }]
    });
  }

  return items;
}

/**
 * Parse geo-mark attributes from span tag
 */
function parseGeoMarkAttrs(spanTag: string): any {
  const attrs: any = {
    geoId: null,
    placeName: '',
    lat: '',
    lng: '',
    colorIndex: 0,
    coordSource: 'manual',
    description: null,
    transportFrom: null,
    transportProfile: null,
    waypoints: null,
    visitDocument: null,
    photoName: null
  };

  const attrRegex = /(\w+(?:-\w+)*)="([^"]*)"/g;
  let match;

  while ((match = attrRegex.exec(spanTag)) !== null) {
    const key = match[1];
    const value = match[2];

    // Convert kebab-case to camelCase
    let camelKey = key.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());

    // Remove "data" prefix
    if (camelKey.startsWith('data')) {
      camelKey = camelKey.charAt(4).toLowerCase() + camelKey.slice(5);
    }

    if (camelKey === 'colorIndex') {
      attrs[camelKey] = parseInt(value) || 0;
    } else if (attrs.hasOwnProperty(camelKey)) {
      attrs[camelKey] = value;
    }
  }

  return attrs;
}

/**
 * Decode HTML entities
 */
function decodeHTMLEntities(text: string): string {
  return text
    .replace(/&lt;/g, '<')
    .replace(/&gt;/g, '>')
    .replace(/&amp;/g, '&')
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'");
}

/**
 * Apply ProseMirror JSON to Y.js XmlFragment incrementally
 * This creates proper Y.js transactions that other clients can merge
 */
export function applyProseMirrorJSONToYjs(
  ydoc: Y.Doc,
  pmJSON: any,
  fragmentName: string = 'prosemirror'
): void {
  const fragment = ydoc.getXmlFragment(fragmentName);

  // Start a transaction
  ydoc.transact(() => {
    // Clear existing content
    fragment.delete(0, fragment.length);

    // Add new content
    if (pmJSON.content && pmJSON.content.length > 0) {
      pmJSON.content.forEach((node: any) => {
        const xmlElement = convertNodeToXmlElement(node);
        if (xmlElement) {
          fragment.push([xmlElement]);
        }
      });
    }
  }, 'ai-assistant'); // Origin tag for tracking
}

/**
 * Convert ProseMirror node to Y.XmlElement
 */
function convertNodeToXmlElement(node: any): Y.XmlElement | Y.XmlText | null {
  if (node.type === 'text') {
    const text = new Y.XmlText(node.text || '');
    // Apply marks
    if (node.marks && node.marks.length > 0) {
      node.marks.forEach((mark: any) => {
        text.setAttribute(mark.type, 'true');
        if (mark.attrs) {
          Object.entries(mark.attrs).forEach(([key, value]) => {
            text.setAttribute(`${mark.type}_${key}`, String(value));
          });
        }
      });
    }
    return text;
  }

  const element = new Y.XmlElement(node.type);

  // Set attributes
  if (node.attrs) {
    Object.entries(node.attrs).forEach(([key, value]) => {
      element.setAttribute(key, String(value));
    });
  }

  // Add content
  if (node.content && node.content.length > 0) {
    node.content.forEach((childNode: any) => {
      const childElement = convertNodeToXmlElement(childNode);
      if (childElement) {
        element.push([childElement]);
      }
    });
  }

  return element;
}
