<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ProseMirror Editor</title>
  <!-- Socket.io client for collaboration -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #ffffff;
    }

    #editor-container {
      padding: 0;
      height: 100%;
      background: white;
      display: flex;
      justify-content: center;
      /* Thin, auto-hiding scrollbar for WebKit browsers (Chrome, Safari, Edge) */
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
    }

    /* Custom scrollbar styling for WebKit browsers */
    #editor-container::-webkit-scrollbar {
      width: 6px;
    }

    #editor-container::-webkit-scrollbar-track {
      background: transparent;
    }

    #editor-container::-webkit-scrollbar-thumb {
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      transition: background-color 0.2s;
    }

    #editor-container::-webkit-scrollbar-thumb:hover {
      background-color: rgba(0, 0, 0, 0.3);
    }

    .ProseMirror {
      outline: none;
      padding: 20px 32px;
      min-height: 100%;
      max-width: 700px;
      width: 100%;
      background: white;
      border: none;
      border-radius: 0;
      caret-color: #3b82f6; /* Bright blue cursor */
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
    }

    /* Disable spell checking underlines */
    .ProseMirror * {
      -webkit-text-decoration-skip: none;
      text-decoration-skip-ink: none;
    }

    /* Make cursor/caret more visible with animation */
    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Enhanced selection highlighting */
    .ProseMirror ::selection {
      background-color: #3b82f6; /* Bright blue */
      color: white;
    }

    .ProseMirror ::-moz-selection {
      background-color: #3b82f6;
      color: white;
    }

    /* ProseMirror's own selection styling */
    .ProseMirror-selectednode {
      outline: 3px solid #3b82f6;
      outline-offset: 2px;
    }

    /* Make the gapcursor more visible */
    .ProseMirror-gapcursor {
      display: block;
      pointer-events: none;
      position: absolute;
    }

    .ProseMirror-gapcursor:after {
      content: "";
      display: block;
      position: absolute;
      top: -2px;
      width: 20px;
      border-top: 2px solid #3b82f6;
      animation: blink 1.2s step-end infinite;
    }

    /* Custom typing cursor indicator */
    #typing-cursor {
      position: absolute;
      width: 3px;
      background-color: #EF4444; /* Bright red for visibility */
      pointer-events: none;
      z-index: 1000;
      animation: blink 0.8s ease-in-out infinite;
      display: none; /* Hidden by default, shown during typing */
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);
    }

    #typing-cursor.visible {
      display: block;
    }

    /* Collaboration cursors and selections */
    .collab-cursor {
      position: relative;
      display: inline-block;
      width: 0;
      height: 1em;
    }

    .collab-cursor-label {
      position: absolute;
      bottom: 100%;
      left: -2px;
      background-color: #3b82f6;
      color: white;
      font-size: 11px;
      padding: 2px 4px;
      border-radius: 3px;
      white-space: nowrap;
      pointer-events: none;
      z-index: 10;
    }

    .collab-selection {
      background-color: rgba(59, 130, 246, 0.2);
    }

    /* Y.js remote cursor and selection styles */
    .ProseMirror-yjs-cursor {
      position: relative;
      margin-left: -1px;
      margin-right: -1px;
      border-left: 2px solid;
      border-right: 2px solid;
      word-break: normal;
      pointer-events: none;
      height: 1em;
      display: inline-block;
    }

    .ProseMirror-yjs-cursor > div {
      position: absolute;
      top: -1.4em;
      left: -1px;
      font-size: 11px;
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      font-weight: 500;
      pointer-events: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
    }

    /* Collaboration status indicator */
    #collab-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      font-size: 11px;
      border-radius: 4px;
      z-index: 100;
      display: none;
    }

    #collab-status.connected {
      background: rgba(16, 185, 129, 0.9);
      display: block;
    }

    #collab-status.disconnected {
      background: rgba(239, 68, 68, 0.9);
      display: block;
    }

    #collab-users {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .collab-user {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      color: white;
      font-weight: 500;
    }

    .ProseMirror h1 {
      font-size: 2em;
      margin: 0.67em 0;
      font-weight: bold;
    }

    .ProseMirror h2 {
      font-size: 1.5em;
      margin: 0.75em 0;
      font-weight: bold;
    }

    .ProseMirror p {
      margin: 1em 0;
    }

    .ProseMirror ul, .ProseMirror ol {
      padding-left: 30px;
    }

    .ProseMirror strong {
      font-weight: bold;
    }

    .ProseMirror em {
      font-style: italic;
    }

    .ProseMirror .geo-mark {
      background-color: rgba(59, 130, 246, 0.2);
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none !important;
      border: none !important;
      border-bottom: none !important;
      -webkit-text-decoration: none !important;
    }

    .ProseMirror .geo-mark:hover {
      background-color: rgba(59, 130, 246, 0.3);
    }

    .ProseMirror .comment-mark {
      background-color: rgba(251, 191, 36, 0.3);
      border-bottom: 2px solid rgba(251, 191, 36, 0.6);
      cursor: pointer;
      padding: 1px 0;
      transition: all 0.2s ease;
    }

    .ProseMirror .comment-mark:hover {
      background-color: rgba(251, 191, 36, 0.4);
      border-bottom-color: rgba(251, 191, 36, 0.9);
    }

    .ProseMirror .comment-mark[data-resolved="true"] {
      background-color: rgba(156, 163, 175, 0.2);
      border-bottom-color: rgba(156, 163, 175, 0.4);
      opacity: 0.7;
    }

    .status-bar {
      display: none; /* Hidden to save space */
    }

    #editor-container {
      padding: 0;
      height: 100%;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="status-bar" id="status">Loading ProseMirror...</div>
  <div id="collab-status">Disconnected</div>
  <div id="collab-users"></div>
  <div id="editor-container"></div>
  <div id="typing-cursor"></div>

  <script>
    console.log('[WebView] Script starting...');

    // Polyfill Web Locks API for sandboxed iframes
    if (!navigator.locks) {
      console.log('[WebView] Polyfilling Web Locks API');
      navigator.locks = {
        request: async function(name, options, callback) {
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          // Simple polyfill - just run the callback immediately
          // This doesn't provide actual locking, but Supabase should handle it
          return await callback({ name, mode: options.mode || 'exclusive' });
        }
      };
    }

    // Set up message handler
    function sendMessageToNative(message) {
      try {
        const json = JSON.stringify(message);
        if (window.ReactNativeWebView) {
          // Native WebView (iOS/Android)
          window.ReactNativeWebView.postMessage(json);
        } else if (window.parent && window.parent !== window) {
          // Web iframe
          window.parent.postMessage(json, '*');
        } else {
          console.warn('[WebView] No message handler available');
        }
      } catch (e) {
        console.error('[WebView] Error sending message:', e);
      }
    }

    function setStatus(text, isError = false) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = text;
      statusEl.className = isError ? 'status-bar error' : 'status-bar';
    }

    // Handle errors
    window.addEventListener('error', function(e) {
      console.error('[WebView] Error:', e.message, e.filename, e.lineno);
      setStatus('Error: ' + e.message, true);
      sendMessageToNative({
        type: 'error',
        message: e.message,
        filename: e.filename,
        lineno: e.lineno
      });
    });

    // Load ProseMirror bundle
    console.log('[WebView] About to load ProseMirror bundle...');
    setStatus('Loading ProseMirror bundle...');
  </script>

  <!-- INLINE PROSEMIRROR BUNDLE WILL BE INSERTED HERE -->
  <script id="prosemirror-bundle">
    // This will be replaced with the actual bundle content
    console.log('[WebView] ProseMirror bundle placeholder');
  </script>

  <script>
    console.log('[WebView] [v4-fixed] Checking if ProseMirror loaded...');
    console.log('[WebView] window.PM exists:', typeof window.PM !== 'undefined');
    console.log('[WebView] PM contents:', window.PM);

    if (typeof window.PM === 'undefined') {
      setStatus('ERROR: ProseMirror failed to load', true);
      sendMessageToNative({
        type: 'error',
        message: 'ProseMirror bundle did not load'
      });
    } else {
      setStatus('ProseMirror loaded successfully!');

      // Initialize editor
      const { EditorState, Plugin, PluginKey } = window.PM.state;
      const { EditorView, Decoration, DecorationSet } = window.PM.view;
      const { schema } = window.PM;
      const { keymap } = window.PM;
      const { history, undo, redo } = window.PM.history;
      const { baseKeymap } = window.PM.commands;
      const { Step } = window.PM.transform;

      console.log('[WebView] Creating editor state...');

      let editorView = null;
      let collabConnection = null;
      let collabPlugin = null;
      let socket = null;

      // Y.js collaboration variables
      let ydoc = null;
      let yXmlFragment = null;
      let awareness = null;
      let yProvider = null; // Supabase Y.js provider

      // Buffer for Y.js updates received before collaboration is initialized
      let pendingYjsUpdates = [];

      // WebView Y.js Provider for Supabase Realtime
      class YWebViewProvider {
        constructor(ydoc, { supabase, documentId, userId, userName, debug = false }) {
          this.ydoc = ydoc;
          this.supabase = supabase;
          this.documentId = documentId;
          this.userId = userId;
          this.userName = userName;
          this.debug = debug;
          this.channel = null;
          this.synced = false;

          this.log('YWebViewProvider initialized for document:', this.documentId);
        }

        log(...args) {
          if (this.debug) {
            console.log('[YWebViewProvider]', ...args);
          }
        }

        async connect() {
          this.log('Connecting to channel:', `doc:${this.documentId}`);

          // Create trip-specific channel using injected Supabase client
          this.channel = this.supabase.channel(`doc:${this.documentId}`, {
            config: {
              broadcast: { self: false }, // Don't receive our own broadcasts
            },
          });

          // Listen for Y.js updates from other clients
          this.channel.on('broadcast', { event: 'yjs-update' }, (payload) => {
            this.log('Received yjs-update from remote');
            try {
              let update;

              // Handle both base64 (new) and array (old) formats
              const updateData = payload.payload?.update || payload.update;

              if (!updateData) {
                console.error('[YWebViewProvider] No update in payload:', payload);
                return;
              }

              if (typeof updateData === 'string') {
                // Base64 format
                update = this.base64ToUint8Array(updateData);
              } else if (Array.isArray(updateData)) {
                // Array format (backward compatibility)
                update = new Uint8Array(updateData);
              } else {
                console.error('[YWebViewProvider] Unknown update format:', typeof updateData);
                return;
              }

              window.PM.Y.applyUpdate(this.ydoc, update, 'remote');
              this.log('Applied remote update, size:', update.length);
            } catch (error) {
              console.error('[YWebViewProvider] Error applying update:', error);
            }
          });

          // Subscribe to channel with timeout
          await new Promise((resolve, reject) => {
            // Add timeout to detect hanging
            const timeout = setTimeout(() => {
              console.error('[YWebViewProvider] Channel subscription timeout after 10 seconds');
              reject(new Error('Channel subscription timeout'));
            }, 10000);

            try {
              const subscription = this.channel.subscribe(async (status) => {
                this.log('Channel status:', status);

                if (status === 'SUBSCRIBED') {
                  clearTimeout(timeout);
                  this.log('Channel subscribed, loading initial state...');
                  try {
                    await this.loadInitialState();
                    this.synced = true;
                    this.log('Sync complete, provider ready');
                    resolve();
                  } catch (error) {
                    reject(error);
                  }
                }

                if (status === 'CLOSED') {
                  this.log('Channel closed');
                  this.synced = false;
                }

                if (status === 'CHANNEL_ERROR') {
                  clearTimeout(timeout);
                  reject(new Error('Channel subscription failed'));
                }
              });

              this.log('Subscribe method returned:', subscription);

              // Check if subscription returned an error
              if (subscription && subscription.error) {
                clearTimeout(timeout);
                console.error('[YWebViewProvider] Subscribe error:', subscription.error);
                reject(subscription.error);
              }
            } catch (error) {
              clearTimeout(timeout);
              console.error('[YWebViewProvider] Error calling subscribe:', error);
              reject(error);
            }
          });

          // Broadcast local Y.js updates
          this.ydoc.on('update', this.handleLocalUpdate);

          this.log('Connected and synced');
        }

        handleLocalUpdate = (update, origin) => {
          // Don't broadcast updates that came from remote
          if (origin === 'remote') return;

          this.log('Broadcasting local update, size:', update.length);

          if (this.channel) {
            this.channel.send({
              type: 'broadcast',
              event: 'yjs-update',
              payload: {
                update: this.uint8ArrayToBase64(update),
              },
            });
          }
        };

        async loadInitialState() {
          this.log('Loading initial state from database');

          try {
            this.log('Querying trips table for document:', this.documentId);

            // Use injected Supabase client to load initial state
            const { data, error } = await this.supabase
              .from('trips')
              .select('yjs_state, yjs_clock')
              .eq('id', this.documentId)
              .single();

            this.log('Query result:', { hasData: !!data, hasError: !!error });

            if (error) {
              console.error('[YWebViewProvider] Error loading state:', error);
              // Don't throw - just continue with empty state
              this.log('Continuing with empty state');
              return;
            }

            if (data?.yjs_state) {
              this.log('Applying initial state, clock:', data.yjs_clock);

              let state;

              if (data.yjs_state instanceof Uint8Array) {
                state = data.yjs_state;
              } else if (Array.isArray(data.yjs_state)) {
                state = new Uint8Array(data.yjs_state);
              } else if (typeof data.yjs_state === 'string') {
                // Handle hex or base64
                if (data.yjs_state.startsWith('\\x')) {
                  // PostgreSQL bytea format
                  const hex = data.yjs_state.substring(2);
                  const bytes = new Uint8Array(hex.length / 2);
                  for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
                  }
                  state = bytes;
                } else {
                  // Base64
                  state = this.base64ToUint8Array(data.yjs_state);
                }
              } else {
                console.error('[YWebViewProvider] Unknown yjs_state format:', typeof data.yjs_state);
                throw new Error('Unknown yjs_state format');
              }

              this.log('Applying Y.js state, size:', state.length);
              window.PM.Y.applyUpdate(this.ydoc, state, 'remote');
            } else {
              this.log('No initial state found, document is empty');
            }
          } catch (error) {
            console.error('[YWebViewProvider] Error in loadInitialState:', error);
            throw error;
          }
        }

        async destroy() {
          this.log('Destroying provider');

          // Remove event listeners
          this.ydoc.off('update', this.handleLocalUpdate);

          // Unsubscribe from channel
          if (this.channel) {
            await this.supabase.removeChannel(this.channel);
            this.channel = null;
          }

          this.synced = false;
          this.log('Provider destroyed');
        }

        uint8ArrayToBase64(bytes) {
          let binary = '';
          for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        }

        base64ToUint8Array(base64) {
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        }
      }

      // Create initial document - empty, content will be sent from React Native
      const { DOMParser: PMDOMParser } = window.PM.model;

      // Start with empty document
      const doc = schema.node('doc', null, [
        schema.node('paragraph', null, [])
      ]);

      // Create initial editor state
      let editorState = EditorState.create({
        doc: doc,
        schema: schema,
        plugins: [
          history(),
          keymap({ 'Mod-z': undo, 'Mod-y': redo }),
          keymap(baseKeymap)
        ]
      });

      console.log('[WebView] Creating editor view...');

      // Color palette for geo-marks
      const COLORS = [
        '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',
        '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
      ];

      // NodeView for geo-marks
      function createGeoMarkNodeView(node) {
        const span = document.createElement('span');
        span.className = 'geo-mark';

        // Apply background color based on colorIndex
        const colorIndex = node.attrs.colorIndex || 0;
        const color = COLORS[colorIndex % COLORS.length];
        span.style.backgroundColor = color + '33'; // 33 = 20% opacity
        span.style.padding = '2px 4px';
        span.style.borderRadius = '3px';
        span.style.cursor = 'pointer';
        span.style.transition = 'all 0.2s ease';
        span.style.textDecoration = 'none';
        span.style.border = 'none';
        span.style.borderBottom = 'none';

        // Store attributes as data attributes for click handling
        if (node.attrs.geoId) span.setAttribute('data-geo-id', node.attrs.geoId);
        if (node.attrs.placeName) span.setAttribute('data-place-name', node.attrs.placeName);
        if (node.attrs.lat) span.setAttribute('data-lat', node.attrs.lat);
        if (node.attrs.lng) span.setAttribute('data-lng', node.attrs.lng);
        if (node.attrs.colorIndex !== undefined) span.setAttribute('data-color-index', node.attrs.colorIndex);
        if (node.attrs.coordSource) span.setAttribute('data-coord-source', node.attrs.coordSource);

        console.log('[WebView] Created geo-mark NodeView with color:', color, 'for:', node.attrs.placeName);

        return {
          dom: span,
          contentDOM: span
        };
      }

      // Typing cursor management
      const typingCursor = document.getElementById('typing-cursor');
      let isTypingActive = false;

      function updateTypingCursor() {
        if (!isTypingActive || !editorView) {
          typingCursor.classList.remove('visible');
          return;
        }

        const { state } = editorView;
        const { selection } = state;
        const { from } = selection;

        // Get the coordinates of the cursor position
        try {
          const coords = editorView.coordsAtPos(from);
          const editorContainer = document.querySelector('#editor-container');
          const editorRect = editorContainer.getBoundingClientRect();

          // Calculate cursor height based on line height
          const cursorHeight = coords.bottom - coords.top;

          // Position and size the cursor indicator
          typingCursor.style.left = (coords.left - editorRect.left) + 'px';
          typingCursor.style.top = (coords.top - editorRect.top) + 'px';
          typingCursor.style.height = cursorHeight + 'px';
          typingCursor.classList.add('visible');

          console.log('[WebView] Cursor updated: height =', cursorHeight);
        } catch (e) {
          console.warn('[WebView] Could not get cursor coordinates:', e);
          typingCursor.classList.remove('visible');
        }
      }

      function showTypingCursor() {
        isTypingActive = true;
        updateTypingCursor();
        console.log('[WebView] Typing cursor shown');
      }

      function hideTypingCursor() {
        isTypingActive = false;
        typingCursor.classList.remove('visible');
        console.log('[WebView] Typing cursor hidden');
      }

      // Expose for native to control
      window.showTypingCursor = showTypingCursor;
      window.hideTypingCursor = hideTypingCursor;

      // Helper functions for toolbar state (must be defined before EditorView)
      // Helper function to update collaboration users display
      function updateCollabUsers() {
        if (!collabConnection) return;

        const usersEl = document.getElementById('collab-users');
        usersEl.innerHTML = '';

        collabConnection.users.forEach((user, userId) => {
          if (userId !== collabConnection.userId) {
            const userEl = document.createElement('div');
            userEl.className = 'collab-user';
            userEl.style.backgroundColor = user.color;
            userEl.textContent = user.name;
            usersEl.appendChild(userEl);
          }
        });
      }

      function isNodeTypeActive(state, nodeType, attrs = {}) {
        const { $from } = state.selection;
        const node = $from.parent;

        if (node.type.name !== nodeType.name) {
          return false;
        }

        // Check attributes match
        for (let key in attrs) {
          if (node.attrs[key] !== attrs[key]) {
            return false;
          }
        }

        return true;
      }

      function isMarkActive(state, markType) {
        const { from, to } = state.selection;
        return state.doc.rangeHasMark(from, to, markType);
      }

      // Get current toolbar state based on selection
      function getToolbarState() {
        const state = editorView.state;
        return {
          paragraph: isNodeTypeActive(state, schema.nodes.paragraph),
          h1: isNodeTypeActive(state, schema.nodes.heading, { level: 1 }),
          h2: isNodeTypeActive(state, schema.nodes.heading, { level: 2 }),
          h3: isNodeTypeActive(state, schema.nodes.heading, { level: 3 }),
          bold: schema.marks.strong ? isMarkActive(state, schema.marks.strong) : false,
          italic: schema.marks.em ? isMarkActive(state, schema.marks.em) : false
        };
      }

      // Create editor view
      editorView = new EditorView(document.querySelector('#editor-container'), {
        state: editorState,
        nodeViews: {
          geoMark: createGeoMarkNodeView
        },
        attributes: {
          spellcheck: 'false',
          autocorrect: 'off',
          autocapitalize: 'off'
        },
        dispatchTransaction(transaction) {
          const oldState = editorView.state;
          const newState = oldState.apply(transaction);
          editorView.updateState(newState);

          // Update typing cursor position on any change
          if (isTypingActive) {
            updateTypingCursor();
          }

          // Send document changes to native
          // NOTE: Skip during Y.js collaboration - sync happens via Y.js, not local storage
          if (transaction.docChanged && !yProvider) {
            const docJSON = newState.doc.toJSON();
            console.log('[WebView] Document changed, sending to native:', JSON.stringify(docJSON));
            sendMessageToNative({
              type: 'documentChange',
              doc: docJSON
            });
          } else if (transaction.docChanged && yProvider) {
            console.log('[WebView] Document changed via Y.js, skipping native sync');
          }

          // Send selection changes to native
          const oldSelection = oldState.selection;
          const newSelection = newState.selection;
          if (!oldSelection.eq(newSelection)) {
            console.log('[WebView] Selection changed, empty:', newSelection.empty);
            sendMessageToNative({
              type: 'selectionChange',
              empty: newSelection.empty
            });

            // Send toolbar state update
            const toolbarState = getToolbarState();
            sendMessageToNative({
              type: 'toolbarStateChange',
              state: toolbarState
            });
          }
        }
      });

      console.log('[WebView] Editor created successfully');
      setStatus('Editor ready');

      // Add click handler for geo-marks and comments
      document.querySelector('#editor-container').addEventListener('click', function(e) {
        if (e.target.classList.contains('geo-mark')) {
          const attrs = {
            geoId: e.target.getAttribute('data-geo-id'),
            placeName: e.target.getAttribute('data-place-name'),
            lat: e.target.getAttribute('data-lat'),
            lng: e.target.getAttribute('data-lng'),
            colorIndex: parseInt(e.target.getAttribute('data-color-index') || '0'),
            coordSource: e.target.getAttribute('data-coord-source')
          };
          console.log('[WebView] Geo-mark clicked:', attrs);
          sendMessageToNative({
            type: 'geoMarkNavigate',
            attrs: attrs
          });
        }

        if (e.target.classList.contains('comment-mark')) {
          const repliesStr = e.target.getAttribute('data-replies');
          let replies = null;
          if (repliesStr) {
            try {
              replies = JSON.parse(repliesStr);
            } catch (err) {
              console.error('[WebView] Error parsing replies:', err);
            }
          }

          const attrs = {
            commentId: e.target.getAttribute('data-comment-id'),
            userId: e.target.getAttribute('data-user-id'),
            userName: e.target.getAttribute('data-user-name') || '',
            content: e.target.getAttribute('data-content') || '',
            createdAt: e.target.getAttribute('data-created-at'),
            resolved: e.target.getAttribute('data-resolved') === 'true',
            replies: replies
          };
          console.log('[WebView] Comment clicked:', attrs);
          sendMessageToNative({
            type: 'commentClick',
            attrs: attrs
          });
        }
      });

      // Send ready message
      sendMessageToNative({
        type: 'ready',
        message: 'ProseMirror editor initialized'
      });

      // Send initial toolbar state
      const initialToolbarState = getToolbarState();
      sendMessageToNative({
        type: 'toolbarStateChange',
        state: initialToolbarState
      });

      // Listen for iOS custom menu actions
      // iOS will trigger this when custom menu items are selected
      document.addEventListener('selectionchange', function() {
        console.log('[WebView] Selection changed via DOM');
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          const selectedText = selection.toString();
          console.log('[WebView] Selected text from DOM:', selectedText);
        }
      });

      // Intercept iOS UIMenuItem actions via a hidden input trick
      // When iOS menu items are clicked, we can detect it through focus/blur events
      let lastSelectedText = '';
      let pendingGeoMarkCreation = false;

      // Store selection when text is selected
      document.addEventListener('selectionchange', function() {
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          lastSelectedText = selection.toString();
          console.log('[WebView] Stored selected text:', lastSelectedText);
        }
      });

      // Create a global function that iOS can call
      window.createLocationFromSelection = function() {
        console.log('[WebView] createLocationFromSelection called!');
        const { state } = editorView;
        const { selection } = state;

        if (selection.empty) {
          console.warn('[WebView] No text selected');
          return;
        }

        const selectedText = state.doc.textBetween(
          selection.from,
          selection.to,
          ' '
        );

        console.log('[WebView] Creating location from iOS menu for:', selectedText);

        // Send request to show geo-mark editor
        sendMessageToNative({
          type: 'showGeoMarkEditor',
          data: {
            placeName: selectedText,
            from: selection.from,
            to: selection.to
          },
          existingLocations: []
        });
      };

      // Expose to window for iOS to call
      window.handleCreateLocation = window.createLocationFromSelection;

      // Y.js helper functions
      function setupYjsListeners() {
        if (!ydoc || !awareness) {
          console.error('[WebView] Cannot setup Y.js listeners - missing ydoc or awareness');
          return;
        }

        console.log('[WebView] Setting up Y.js listeners');

        // Forward Y.js updates to React Native
        ydoc.on('update', (update, origin) => {
          if (origin !== 'remote') {
            console.log('[WebView] Y.js update detected, forwarding to native');
            sendMessageToNative({
              type: 'yjsUpdate',
              update: Array.from(update)
            });
          }
        });

        // Forward awareness changes
        awareness.on('change', () => {
          const update = window.PM.awarenessProtocol.encodeAwarenessUpdate(
            awareness,
            Array.from(awareness.getStates().keys())
          );
          console.log('[WebView] Awareness update detected, forwarding to native');
          sendMessageToNative({
            type: 'awarenessUpdate',
            update: Array.from(update)
          });
        });

        console.log('[WebView] Y.js listeners setup complete');
      }

      function getRandomColor() {
        const colors = [
          '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',
          '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Listen for messages from React Native and native iOS menu
      window.addEventListener('message', function(event) {
        // Verbose logging removed - messages are frequent

        // Handle native iOS menu actions
        if (event.data && event.data.source === 'nativeMenu') {
          console.log('[WebView] Native menu action:', event.data.action);

          if (event.data.action === 'createLocation') {
            console.log('[WebView] Create location from native menu:', event.data.data.selectedText);
            // Trigger the create location function
            if (window.createLocationFromSelection) {
              window.createLocationFromSelection();
            }
            return;
          }

          if (event.data.action === 'addNote') {
            console.log('[WebView] Add note from native menu:', event.data.data.selectedText);
            // Handle add note action
            return;
          }
        }

        try {
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          switch (data.type) {
            case 'evalScript':
              console.log('[WebView] Executing script via postMessage');
              try {
                eval(data.script);
              } catch (evalError) {
                console.error('[WebView] Error executing script:', evalError);
              }
              break;

            case 'supabaseConfig':
              console.log('[WebView] Received Supabase config via postMessage');
              // Store config globally for use during collaboration
              window.__supabaseConfig = data.config;
              break;

            case 'setContent':
              console.log('[WebView] Setting content:', JSON.stringify(data.content));
              if (data.content && editorView) {
                try {
                  const doc = schema.nodeFromJSON(data.content);
                  console.log('[WebView] Created doc from JSON:', doc.toString());
                  console.log('[WebView] Doc content:', doc.content.toString());

                  // Check for headings in the document
                  let hasHeadings = false;
                  doc.descendants((node) => {
                    if (node.type.name === 'heading') {
                      console.log('[WebView] Found heading node, level:', node.attrs.level);
                      hasHeadings = true;
                    }
                  });
                  console.log('[WebView] Document has headings:', hasHeadings);

                  // Create new state with fresh plugins
                  const newState = EditorState.create({
                    doc: doc,
                    schema: schema,
                    plugins: [
                      history(),
                      keymap({ 'Mod-z': undo, 'Mod-y': redo }),
                      keymap(baseKeymap)
                    ]
                  });
                  editorView.updateState(newState);
                  editorState = newState;

                  // Send updated toolbar state after loading content
                  const toolbarState = getToolbarState();
                  sendMessageToNative({
                    type: 'toolbarStateChange',
                    state: toolbarState
                  });
                } catch (e) {
                  console.error('[WebView] Error creating doc from JSON:', e);
                  console.error('[WebView] Content was:', JSON.stringify(data.content));
                }
              }
              break;

            case 'setEditable':
              console.log('[WebView] Setting editable:', data.editable);
              if (editorView) {
                editorView.setProps({ editable: () => data.editable });
              }
              break;

            case 'getState':
              // Verbose logging removed - state requests are frequent
              if (editorView) {
                sendMessageToNative({
                  type: 'stateResponse',
                  state: editorView.state.doc.toJSON()
                });
              }
              break;

            case 'createGeoMarkFromRecent':
              console.log('[WebView] Creating geo-mark from recent text:', data.geoMarkData);
              if (editorView && data.geoMarkData && data.textLength) {
                const { state, dispatch } = editorView;
                // Select the recently typed text by going backwards from current position
                const currentPos = state.selection.to;
                const from = Math.max(0, currentPos - data.textLength);
                const to = currentPos;

                // Create selection
                const newSelection = TextSelection.create(state.doc, from, to);
                let tr = state.tr.setSelection(newSelection);
                dispatch(tr);

                // Now create the geo-mark with the selected text
                const selectedText = state.doc.textBetween(from, to, ' ');
                const geoMarkType = schema.nodes.geoMark;
                if (!geoMarkType) {
                  console.error('[WebView] geoMark node type not found in schema');
                  break;
                }

                const geoMarkNode = geoMarkType.create(
                  {
                    geoId: data.geoMarkData.geoId,
                    placeName: data.geoMarkData.placeName,
                    lat: data.geoMarkData.lat,
                    lng: data.geoMarkData.lng,
                    colorIndex: data.geoMarkData.colorIndex || 0,
                    coordSource: data.geoMarkData.coordSource || 'manual',
                    description: data.geoMarkData.description || null,
                    transportFrom: data.geoMarkData.transportFrom || null,
                    transportProfile: data.geoMarkData.transportProfile || null,
                    waypoints: data.geoMarkData.waypoints || null,
                    visitDocument: data.geoMarkData.visitDocument || null,
                    photoName: data.geoMarkData.photoName || null,
                  },
                  schema.text(selectedText)
                );

                // Replace the selection with the geo-mark node
                const tr2 = editorView.state.tr.replaceSelectionWith(geoMarkNode);
                dispatch(tr2);
                console.log('[WebView] Geo-mark created from recent text');
              }
              break;

            case 'createGeoMark':
              console.log('[WebView] Creating geo-mark with data:', data.geoMarkData);
              sendMessageToNative({
                type: 'debug',
                message: '[WebView DEBUG] Received createGeoMark message'
              });

              try {
                if (!editorView) {
                  throw new Error('editorView is null');
                }
                if (!data.geoMarkData) {
                  throw new Error('geoMarkData is missing');
                }
                console.log('[WebView] Step 1: editorView and geoMarkData validated');

                const { state, dispatch } = editorView;
                console.log('[WebView] Step 2: Got state and dispatch from editorView');

                const { selection } = state;
                const { from, to } = selection;
                console.log('[WebView] Step 3: Selection bounds:', { from, to });

                sendMessageToNative({
                  type: 'debug',
                  message: `[WebView DEBUG] Selection from ${from} to ${to}, selected text: "${state.doc.textBetween(from, to, ' ')}"`
                });

                // Create a geoMark NODE (not mark) with the location data
                const geoMarkType = schema.nodes.geoMark;
                if (!geoMarkType) {
                  throw new Error('geoMark node type not found in schema');
                }
                console.log('[WebView] Step 4: geoMarkType found in schema');

                // Get the selected text
                const selectedText = state.doc.textBetween(from, to, ' ');
                console.log('[WebView] Step 5: Selected text:', selectedText);

                // Create geoMark node with text content and all attributes
                const geoMarkNode = geoMarkType.create(
                  {
                    geoId: data.geoMarkData.geoId,
                    placeName: data.geoMarkData.placeName,
                    lat: data.geoMarkData.lat,
                    lng: data.geoMarkData.lng,
                    colorIndex: data.geoMarkData.colorIndex || 0,
                    coordSource: data.geoMarkData.coordSource || 'manual',
                    description: data.geoMarkData.description || null,
                    transportFrom: data.geoMarkData.transportFrom || null,
                    transportProfile: data.geoMarkData.transportProfile || null,
                    waypoints: data.geoMarkData.waypoints || null,
                    visitDocument: data.geoMarkData.visitDocument || null,
                    photoName: data.geoMarkData.photoName || null
                  },
                  schema.text(selectedText)
                );
                console.log('[WebView] Step 6: geoMarkNode created:', geoMarkNode);

                // Replace the selected text with the geo-mark node
                const tr = state.tr.replaceSelectionWith(geoMarkNode);
                console.log('[WebView] Step 7: Transaction created');

                dispatch(tr);
                console.log('[WebView] Step 8: Transaction dispatched');

                console.log('[WebView] Geo-mark NODE created successfully');
                sendMessageToNative({
                  type: 'info',
                  message: 'Location created: ' + data.geoMarkData.placeName
                });
              } catch (error) {
                console.error('[WebView] ERROR in createGeoMark:', error);
                console.error('[WebView] Error stack:', error.stack);
                sendMessageToNative({
                  type: 'error',
                  message: `Failed to create geo-mark: ${error.message}`
                });
              }
              break;

            case 'command':
              console.log('[WebView] Executing command:', data.command, data.params);
              if (!editorView) {
                console.warn('[WebView] Editor view not available');
                break;
              }

              const { state, dispatch } = editorView;
              const { selection } = state;
              const { from, to } = selection;

              switch (data.command) {
                case 'setParagraph':
                  console.log('[WebView] Setting paragraph');
                  const paragraphTr = state.tr.setBlockType(from, to, schema.nodes.paragraph);
                  dispatch(paragraphTr);
                  editorView.focus();
                  break;

                case 'setHeading':
                  const level = data.params?.level || 1;
                  console.log('[WebView] Setting heading level:', level);
                  // Get the current cursor position
                  const cursorPos = state.selection.$from.pos;
                  // Find the bounds of the current block (paragraph)
                  const $pos = state.doc.resolve(cursorPos);
                  const blockStart = $pos.before($pos.depth);
                  const blockEnd = $pos.after($pos.depth);
                  // Only set heading for the current block
                  const headingTr = state.tr.setBlockType(blockStart, blockEnd, schema.nodes.heading, { level });
                  dispatch(headingTr);
                  console.log('[WebView] Set heading from', blockStart, 'to', blockEnd);
                  editorView.focus();
                  break;

                case 'toggleBold':
                  console.log('[WebView] Toggling bold');
                  if (schema.marks.strong) {
                    const hasBold = state.doc.rangeHasMark(from, to, schema.marks.strong);
                    if (hasBold) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.strong));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.strong.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'toggleItalic':
                  console.log('[WebView] Toggling italic');
                  if (schema.marks.em) {
                    const hasItalic = state.doc.rangeHasMark(from, to, schema.marks.em);
                    if (hasItalic) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.em));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.em.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'createGeoMark':
                  // Check if there's selected text
                  if (selection.empty) {
                    console.warn('[WebView] No text selected for geo-mark');
                    sendMessageToNative({
                      type: 'error',
                      message: 'Please select text to create a location'
                    });
                    break;
                  }

                  // Get selected text
                  const selectedText = state.doc.textBetween(from, to, ' ');
                  console.log('[WebView] Selected text:', selectedText);

                  // Check if geoMarkData is provided (for animation mode)
                  if (data.params && data.params.geoMarkData) {
                    console.log('[WebView] Animation mode: Creating geo-mark directly with data:', data.params.geoMarkData);
                    try {
                      const geoMarkType = schema.nodes.geoMark;
                      if (!geoMarkType) {
                        throw new Error('geoMark node type not found in schema');
                      }
                      console.log('[WebView] Step 1: geoMarkType found in schema');

                      // Create geoMark node with text content and all attributes
                      const geoMarkNode = geoMarkType.create(
                        {
                          geoId: data.params.geoMarkData.geoId,
                          placeName: data.params.geoMarkData.placeName,
                          lat: data.params.geoMarkData.lat,
                          lng: data.params.geoMarkData.lng,
                          colorIndex: data.params.geoMarkData.colorIndex || 0,
                          coordSource: data.params.geoMarkData.coordSource || 'manual',
                          description: data.params.geoMarkData.description || null,
                          transportFrom: data.params.geoMarkData.transportFrom || null,
                          transportProfile: data.params.geoMarkData.transportProfile || null,
                          waypoints: data.params.geoMarkData.waypoints || null,
                          visitDocument: data.params.geoMarkData.visitDocument || null,
                          photoName: data.params.geoMarkData.photoName || null
                        },
                        schema.text(selectedText)
                      );
                      console.log('[WebView] Step 2: geoMarkNode created');

                      // Replace the selected text with the geo-mark node
                      const tr = state.tr.replaceSelectionWith(geoMarkNode);
                      console.log('[WebView] Step 3: Transaction created');

                      dispatch(tr);
                      console.log('[WebView] Step 4: Transaction dispatched');

                      console.log('[WebView] Geo-mark NODE created successfully!');
                      sendMessageToNative({
                        type: 'info',
                        message: 'Location created: ' + data.params.geoMarkData.placeName
                      });
                    } catch (error) {
                      console.error('[WebView] ERROR creating geo-mark:', error);
                      console.error('[WebView] Error stack:', error.stack);
                      sendMessageToNative({
                        type: 'error',
                        message: `Failed to create geo-mark: ${error.message}`
                      });
                    }
                    break;
                  }

                  // Interactive mode: Send request to show geo-mark editor
                  sendMessageToNative({
                    type: 'showGeoMarkEditor',
                    data: {
                      placeName: selectedText,
                      from: selection.from,
                      to: selection.to
                    },
                    existingLocations: []
                  });
                  break;

                case 'addComment':
                  // Check if there's selected text
                  if (selection.empty) {
                    console.warn('[WebView] No text selected for comment');
                    sendMessageToNative({
                      type: 'error',
                      message: 'Please select text to add a comment'
                    });
                    break;
                  }

                  // Get selected text
                  const commentSelectedText = state.doc.textBetween(from, to, ' ');
                  console.log('[WebView] Selected text for comment:', commentSelectedText);

                  // Send request to show comment editor
                  sendMessageToNative({
                    type: 'showCommentEditor',
                    data: {
                      selectedText: commentSelectedText,
                      from: selection.from,
                      to: selection.to
                    }
                  });
                  break;

                case 'createComment':
                  // Create a comment mark with the provided data
                  if (data.params && schema.marks.comment) {
                    const commentMark = schema.marks.comment.create({
                      commentId: data.params.commentId,
                      userId: data.params.userId,
                      userName: data.params.userName,
                      content: data.params.content,
                      createdAt: data.params.createdAt,
                      resolved: data.params.resolved || false,
                      replies: data.params.replies || null
                    });

                    const commentTr = state.tr.addMark(
                      data.params.from || from,
                      data.params.to || to,
                      commentMark
                    );
                    dispatch(commentTr);
                    console.log('[WebView] Comment created successfully');
                    editorView.focus();
                  }
                  break;

                case 'updateCommentAIReply':
                  // Update a comment mark's aiReply attribute
                  console.log('[WebView] Updating comment AI reply:', data.commentId);
                  if (data.commentId && data.aiReplyDoc && schema.marks.comment) {
                    let commentFound = false;
                    const updateTr = state.tr;

                    // Find all comment marks in the document
                    state.doc.descendants((node, pos) => {
                      if (!node.isText) return;

                      // Check if this text node has a comment mark with matching ID
                      const commentMark = node.marks.find(
                        mark => mark.type.name === 'comment' && mark.attrs.commentId === data.commentId
                      );

                      if (commentMark) {
                        commentFound = true;
                        const nodeStart = pos;
                        const nodeEnd = pos + node.nodeSize;

                        console.log('[WebView] Found comment mark at', nodeStart, '-', nodeEnd);

                        // Create updated comment mark with aiReply
                        const updatedCommentMark = schema.marks.comment.create({
                          ...commentMark.attrs,
                          aiReply: data.aiReplyDoc
                        });

                        // Remove old mark and add updated one
                        updateTr.removeMark(nodeStart, nodeEnd, commentMark);
                        updateTr.addMark(nodeStart, nodeEnd, updatedCommentMark);

                        console.log('[WebView] Updated comment with AI reply');
                      }
                    });

                    if (commentFound) {
                      dispatch(updateTr);
                      console.log('[WebView] Comment AI reply updated successfully');
                      sendMessageToNative({
                        type: 'info',
                        message: 'AI reply received'
                      });
                    } else {
                      console.warn('[WebView] Comment not found:', data.commentId);
                    }
                  }
                  break;

                case 'focusEditor':
                  console.log('[WebView] Focusing editor');
                  // Focus the editor
                  editorView.focus();
                  // Move cursor to end of document
                  const endPos = state.doc.content.size;
                  const focusTr = state.tr.setSelection(
                    window.PM.state.Selection.near(state.doc.resolve(endPos))
                  );
                  dispatch(focusTr);
                  console.log('[WebView] Editor focused, cursor at end');
                  break;

                case 'insertText':
                  console.log('[WebView] Inserting text:', data.params?.text);
                  // Insert text at current cursor position
                  const text = data.params?.text || '';
                  const insertTextTr = state.tr.insertText(text);
                  dispatch(insertTextTr);
                  console.log('[WebView] Text inserted at pos:', state.selection.$from.pos);
                  break;

                case 'insertParagraph':
                  console.log('[WebView] Inserting paragraph');
                  // Split the current block and reset to paragraph
                  let paraTr = state.tr.split(state.selection.to);
                  // After split, set the new block to paragraph (not heading)
                  const newPos = paraTr.selection.$from.pos;
                  const $newPos = paraTr.doc.resolve(newPos);
                  const newBlockStart = $newPos.before($newPos.depth);
                  const newBlockEnd = $newPos.after($newPos.depth);
                  paraTr = paraTr.setBlockType(newBlockStart, newBlockEnd, schema.nodes.paragraph);
                  dispatch(paraTr);
                  console.log('[WebView] Paragraph split/inserted and reset to paragraph type');
                  break;

                case 'selectText':
                  console.log('[WebView] Selecting text backwards:', data.params?.count);
                  // Select text backwards from cursor (like Shift+ArrowLeft)
                  try {
                    const count = data.params?.count || 0;
                    const currentPos = state.selection.to;
                    const startPos = Math.max(0, currentPos - count);

                    const selectTr = state.tr.setSelection(
                      window.PM.state.TextSelection.create(state.doc, startPos, currentPos)
                    );
                    dispatch(selectTr);
                    console.log('[WebView] Selected text from', startPos, 'to', currentPos);
                  } catch (error) {
                    console.error('[WebView] Error selecting text:', error);
                  }
                  break;

                case 'selectBackward':
                  console.log('[WebView] Selecting backward:', data.params?.length);
                  sendMessageToNative({
                    type: 'debug',
                    message: `[WebView DEBUG] selectBackward command received, length: ${data.params?.length}`
                  });

                  try {
                    // Select text backwards from cursor by the specified length
                    const length = data.params?.length || 0;
                    const currentPos = state.selection.to;
                    const startPos = Math.max(0, currentPos - length);

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] Before selection: currentPos=${currentPos}, will select from ${startPos} to ${currentPos}`
                    });

                    const selectTr = state.tr.setSelection(
                      window.PM.state.TextSelection.create(state.doc, startPos, currentPos)
                    );

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] Created selection transaction, about to dispatch`
                    });

                    dispatch(selectTr);

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] After selection dispatch: from ${startPos} to ${currentPos}`
                    });
                  } catch (error) {
                    sendMessageToNative({
                      type: 'error',
                      message: `[WebView ERROR] selectBackward failed: ${error.message}`
                    });
                  }
                  break;

                case 'selectRange':
                  console.log('[WebView] Selecting range:', data.params?.from, 'to', data.params?.to);
                  try {
                    const rangeFrom = data.params?.from || 0;
                    const rangeTo = data.params?.to || 0;

                    // Create selection for the specified range
                    const rangeTr = state.tr.setSelection(
                      window.PM.state.TextSelection.create(state.doc, rangeFrom, rangeTo)
                    );
                    dispatch(rangeTr);
                    console.log('[WebView] Range selected from', rangeFrom, 'to', rangeTo);
                  } catch (error) {
                    console.error('[WebView] selectRange failed:', error);
                  }
                  break;

                case 'deleteSelection':
                  console.log('[WebView] Deleting selection');
                  try {
                    // Delete the current selection
                    const deleteTr = state.tr.deleteSelection();
                    dispatch(deleteTr);
                    console.log('[WebView] Selection deleted');
                  } catch (error) {
                    console.error('[WebView] deleteSelection failed:', error);
                  }
                  break;

                case 'showTypingCursor':
                  console.log('[WebView] Showing typing cursor');
                  showTypingCursor();
                  break;

                case 'hideTypingCursor':
                  console.log('[WebView] Hiding typing cursor');
                  hideTypingCursor();
                  break;

                default:
                  console.warn('[WebView] Unknown command:', data.command);
              }
              break;

            case 'startCollaboration':
              console.log('[WebView] Starting Y.js collaboration:', data);

              if (!editorView) {
                console.error('[WebView] Cannot start collaboration - editor not ready');
                sendMessageToNative({
                  type: 'collaborationStarted',
                  success: false,
                  error: 'Editor not ready'
                });
                break;
              }

              if (!window.PM.Y || !window.PM.yProsemirror) {
                console.error('[WebView] Cannot start collaboration - Y.js not loaded');
                sendMessageToNative({
                  type: 'collaborationStarted',
                  success: false,
                  error: 'Y.js not loaded'
                });
                break;
              }

              (async () => {
                try {
                  // Connect to Tiptap Cloud or standalone Hocuspocus server
                  const { documentId, userId, userName, token, serverUrl, hocuspocusUrl } = data;

                  // Determine which URL to use (serverUrl takes priority for Tiptap Cloud)
                  const wsUrl = serverUrl || hocuspocusUrl || 'ws://127.0.0.1:1234/collaboration';

                  console.log('[WebView] Creating Hocuspocus collaboration for document:', documentId);
                  console.log('[WebView] WebSocket URL:', wsUrl);
                  console.log('[WebView] Auth token:', token ? 'present' : 'missing');

                  if (!token) {
                    throw new Error('Authentication required - no token provided');
                  }

                  // Get HocuspocusProvider from bundled modules
                  if (!window.PM.HocuspocusProvider) {
                    throw new Error('HocuspocusProvider not available in bundle');
                  }
                  const HocuspocusProvider = window.PM.HocuspocusProvider;
                  console.log('[WebView] Using bundled HocuspocusProvider');

                  // Create Y.Doc and fragment
                  ydoc = new window.PM.Y.Doc();
                  yXmlFragment = ydoc.getXmlFragment('prosemirror');
                  awareness = new window.PM.Awareness(ydoc);

                  // Set local awareness state
                  awareness.setLocalStateField('user', {
                    id: userId,
                    name: userName,
                    color: getRandomColor()
                  });

                  console.log('[WebView] Y.Doc created with clientID:', ydoc.clientID);

                  // LOCAL-FIRST: Load initial state from AsyncStorage if provided
                  // BUT: Only apply if we have local state AND we're not about to sync from server
                  // The Hocuspocus provider will merge any server state automatically via CRDT
                  if (data.yjsState) {
                    console.log('[WebView]  Loading Y.js state from AsyncStorage');
                    try {
                      // Decode base64 to Uint8Array
                      const binaryString = atob(data.yjsState);
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }

                      // Apply the state to our Y.Doc BEFORE connecting to Hocuspocus
                      // This ensures local edits are preserved when merging with server state
                      window.PM.Y.applyUpdate(ydoc, bytes);
                      console.log('[WebView]  Y.js state loaded successfully. YXmlFragment length:', yXmlFragment.length);
                    } catch (error) {
                      console.error('[WebView]  Failed to load Y.js state:', error);
                    }
                  } else {
                    console.log('[WebView] No local Y.js state to load - will sync from server');
                  }

                  // LOCAL-FIRST: Monitor Y.Doc updates and persist to AsyncStorage (debounced)
                  let saveTimeout = null;
                  ydoc.on('update', (update, origin) => {
                    // Debounce saves to AsyncStorage (every 2 seconds)
                    if (saveTimeout) clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                      // Check if document has content
                      const docSize = yXmlFragment.length;
                      if (docSize === 0) return;

                      const state = window.PM.Y.encodeStateAsUpdate(ydoc);
                      const base64State = btoa(String.fromCharCode(...new Uint8Array(state)));
                      console.log('[WebView] Saving Y.js state:', state.byteLength, 'bytes');
                      sendMessageToNative({
                        type: 'saveYjsState',
                        state: base64State
                      });
                    }, 2000);
                  });

                  // Create Hocuspocus provider for Tiptap Cloud or standalone server
                  console.log('[WebView] Connecting to Hocuspocus server...');

                  // Create Hocuspocus provider
                  yProvider = new HocuspocusProvider({
                    url: wsUrl,
                    name: documentId,
                    document: ydoc,
                    token: token,
                    awareness: awareness,
                    onConnect: () => {
                      console.log('[WebView]  Hocuspocus connected successfully');
                    },
                    onDisconnect: ({ event }) => {
                      console.log('[WebView]  Hocuspocus disconnected:', event);
                    },
                    onStatus: ({ status }) => {
                      console.log('[WebView]  Hocuspocus status:', status);
                    },
                    onSynced: ({ state }) => {
                      console.log('[WebView]  Hocuspocus synced:', state);
                      // NOTE: We don't send stateResponse here anymore
                      // The Y.Doc update observer will handle persistence to AsyncStorage
                    },
                    onAuthenticationFailed: ({ reason }) => {
                      console.error('[WebView]  Hocuspocus authentication failed:', reason);
                      console.error('[WebView] Token was:', token ? `${token.substring(0, 50)}...` : 'missing');
                      console.error('[WebView] Document ID:', documentId);
                      console.error('[WebView] URL:', wsUrl);
                    },
                    onClose: ({ event }) => {
                      console.error('[WebView]  Hocuspocus connection closed:', event);
                    }
                  });

                  console.log('[WebView] Hocuspocus provider created and connecting...');

                  // Recreate editor with Y.js plugins
                  // NOTE: Do NOT pass a doc parameter - ySyncPlugin will create the doc from YXmlFragment
                  const newState = EditorState.create({
                    schema: schema,
                    plugins: [
                      window.PM.yProsemirror.ySyncPlugin(yXmlFragment),
                      window.PM.yProsemirror.yCursorPlugin(awareness),
                      window.PM.yProsemirror.yUndoPlugin(),
                      keymap({ 'Mod-z': undo, 'Mod-y': redo }),
                      keymap(baseKeymap)
                    ]
                  });

                  editorView.updateState(newState);
                  console.log('[WebView] Y.js collaboration started');

                  // Update UI
                  const statusEl = document.getElementById('collab-status');
                  if (statusEl) {
                    statusEl.textContent = 'Connected (Y.js)';
                    statusEl.className = 'connected';
                  }

                  // Notify React Native
                  sendMessageToNative({
                    type: 'collaborationStarted',
                    success: true,
                    clientId: ydoc.clientID
                  });

                  console.log('[WebView] Y.js collaboration started successfully');
                } catch (error) {
                  console.error('[WebView] Failed to start Y.js collaboration:', error);
                  sendMessageToNative({
                    type: 'collaborationStarted',
                    success: false,
                    error: error.message
                  });
                }
              })();
              break;

            case 'stopCollaboration':
              console.log('[WebView] Stopping Y.js collaboration');

              (async () => {
                try {
                  // Destroy Hocuspocus provider
                  if (yProvider) {
                    yProvider.destroy();
                    yProvider = null;
                    console.log('[WebView] Hocuspocus provider destroyed');
                  }

                  // Clean up Y.js resources
                  if (ydoc) {
                    ydoc.destroy();
                    ydoc = null;
                    yXmlFragment = null;
                    awareness = null;
                    console.log('[WebView] Y.js resources cleaned up');
                  }

                  // Remove Y.js plugins and restore editor with basic plugins
                  if (editorView) {
                    const currentDoc = editorView.state.doc;
                    const newState = EditorState.create({
                      schema: schema,
                      doc: currentDoc,
                      plugins: [
                        history(),
                        keymap({ 'Mod-z': undo, 'Mod-y': redo }),
                        keymap(baseKeymap)
                      ]
                    });
                    editorView.updateState(newState);
                    console.log('[WebView] Editor restored with basic plugins');
                  }

                  // Update UI
                  const statusEl = document.getElementById('collab-status');
                  if (statusEl) {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'disconnected';
                  }

                  sendMessageToNative({
                    type: 'collaborationStopped',
                    success: true
                  });

                  console.log('[WebView] Y.js collaboration stopped successfully');
                } catch (error) {
                  console.error('[WebView] Error stopping Y.js collaboration:', error);
                  sendMessageToNative({
                    type: 'collaborationStopped',
                    success: false,
                    error: error.message
                  });
                }
              })();
              break;

            case 'applySteps':
              console.log('[WebView] Applying steps from', data.clientID, '- version:', data.version, '- steps:', data.steps.length);
              if (editorView && data.steps && data.steps.length > 0) {
                try {
                  let tr = editorView.state.tr;

                  // Apply each step to the transaction
                  for (const stepJSON of data.steps) {
                    const step = Step.fromJSON(schema, stepJSON);
                    tr.step(step);
                  }

                  // Apply the transaction to update the editor
                  editorView.dispatch(tr);
                  editorState = editorView.state;

                  console.log('[WebView] Successfully applied', data.steps.length, 'steps');

                  // Notify React Native that document changed
                  sendMessageToNative({
                    type: 'documentChange',
                    document: editorView.state.doc.toJSON()
                  });
                } catch (e) {
                  console.error('[WebView] Error applying steps:', e);
                }
              }
              break;

            case 'yjsUpdate':
              // Handle incoming Y.js update from React Native (base64 encoded)
              console.log('[WebView] yjsUpdate message received, data:', {
                hasUpdateBase64: !!data.updateBase64,
                updateBase64Type: typeof data.updateBase64,
                updateBase64Length: data.updateBase64 ? data.updateBase64.length : 0,
                ydocReady: !!ydoc
              });

              if (data.updateBase64) {
                try {
                  // Decode base64 to Uint8Array
                  const binary = atob(data.updateBase64);
                  const bytes = new Uint8Array(binary.length);
                  for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                  }
                  console.log('[WebView] Decoded base64 update, byte size:', bytes.length);

                  if (ydoc) {
                    // Y.js is initialized, apply update immediately
                    console.log('[WebView] Applying Y.js update from native, size:', bytes.length);
                    window.PM.Y.applyUpdate(ydoc, bytes, 'remote');
                    console.log('[WebView] Y.js update applied successfully');
                  } else {
                    // Buffer the update until Y.js is initialized
                    console.log('[WebView] Buffering Y.js update (ydoc not ready yet)');
                    pendingYjsUpdates.push(bytes);
                  }
                } catch (error) {
                  console.error('[WebView] Error decoding/applying Y.js update:', error);
                }
              } else {
                console.warn('[WebView] Received yjsUpdate but no updateBase64 data');
              }
              break;

            case 'awarenessUpdate':
              // Handle incoming awareness update from React Native
              if (awareness && data.update) {
                try {
                  const update = new Uint8Array(data.update);
                  console.log('[WebView] Applying awareness update from native, size:', update.length);
                  window.PM.awarenessProtocol.applyAwarenessUpdate(
                    awareness,
                    update,
                    'remote'
                  );
                  console.log('[WebView] Awareness update applied successfully');
                } catch (error) {
                  console.error('[WebView] Error applying awareness update:', error);
                }
              } else {
                console.warn('[WebView] Received awarenessUpdate but awareness not initialized or no update data');
              }
              break;

            default:
              console.warn('[WebView] Unknown message type:', data.type);
          }
        } catch (e) {
          console.error('[WebView] Error handling message:', e);
        }
      });
    }
  </script>
</body>
</html>
