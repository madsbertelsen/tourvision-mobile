<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ProseMirror Editor</title>
  <!-- Socket.io client for collaboration -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <!-- Mapbox GL JS for map in location modal -->
  <link href="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css" rel="stylesheet" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: white;
    }

    #editor-container {
      padding: 0;
      height: 100%;
      background: white;
      /* Thin, auto-hiding scrollbar for WebKit browsers (Chrome, Safari, Edge) */
      scrollbar-width: thin;
      scrollbar-color: rgba(0, 0, 0, 0.2) transparent;
    }

    /* Custom scrollbar styling for WebKit browsers */
    #editor-container::-webkit-scrollbar {
      width: 6px;
    }

    #editor-container::-webkit-scrollbar-track {
      background: transparent;
    }

    #editor-container::-webkit-scrollbar-thumb {
      background-color: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
      transition: background-color 0.2s;
    }

    #editor-container::-webkit-scrollbar-thumb:hover {
      background-color: rgba(0, 0, 0, 0.3);
    }

    .ProseMirror {
      outline: none;
      padding: 20px 32px;
      min-height: 100vh;
      width: 100%;
      background: white;
      border: none;
      border-radius: 0;
      caret-color: #3b82f6; /* Bright blue cursor */
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
    }

    /* Disable spell checking underlines */
    .ProseMirror * {
      -webkit-text-decoration-skip: none;
      text-decoration-skip-ink: none;
    }

    /* Make cursor/caret more visible with animation */
    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Enhanced selection highlighting - SUPER VISIBLE! */
    .ProseMirror ::selection {
      background-color: #3b82f6 !important; /* Bright blue */
      color: white !important;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.8) !important;
    }

    /* Animated selection highlight for demo */
    .selection-highlight {
      background-color: rgba(59, 130, 246, 0.4) !important;
      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.6);
      animation: pulse-selection 0.3s ease-in-out;
    }

    @keyframes pulse-selection {
      0%, 100% { background-color: rgba(59, 130, 246, 0.3); }
      50% { background-color: rgba(59, 130, 246, 0.5); }
    }

    .ProseMirror ::-moz-selection {
      background-color: #3b82f6;
      color: white;
    }

    /* ProseMirror's own selection styling */
    .ProseMirror-selectednode {
      outline: 3px solid #3b82f6;
      outline-offset: 2px;
    }

    /* Make the gapcursor more visible */
    .ProseMirror-gapcursor {
      display: block;
      pointer-events: none;
      position: absolute;
    }

    .ProseMirror-gapcursor:after {
      content: "";
      display: block;
      position: absolute;
      top: -2px;
      width: 20px;
      border-top: 2px solid #3b82f6;
      animation: blink 1.2s step-end infinite;
    }

    /* Custom typing cursor indicator */
    #typing-cursor {
      position: absolute;
      width: 3px;
      background-color: #EF4444; /* Bright red for visibility */
      pointer-events: none;
      z-index: 1000;
      animation: blink 0.8s ease-in-out infinite;
      display: none; /* Hidden by default, shown during typing */
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);
    }

    #typing-cursor.visible {
      display: block;
    }

    /* Collaboration cursors and selections */
    .collab-cursor {
      position: relative;
      display: inline-block;
      width: 0;
      height: 1em;
    }

    .collab-cursor-label {
      position: absolute;
      bottom: 100%;
      left: -2px;
      background-color: #3b82f6;
      color: white;
      font-size: 11px;
      padding: 2px 4px;
      border-radius: 3px;
      white-space: nowrap;
      pointer-events: none;
      z-index: 10;
    }

    .collab-selection {
      background-color: rgba(59, 130, 246, 0.2);
    }

    /* Y.js remote cursor and selection styles */
    .ProseMirror-yjs-cursor {
      position: relative;
      margin-left: -1px;
      margin-right: -1px;
      border-left: 2px solid;
      border-right: 2px solid;
      word-break: normal;
      pointer-events: none;
      height: 1em;
      display: inline-block;
    }

    .ProseMirror-yjs-cursor > div {
      position: absolute;
      top: -1.4em;
      left: -1px;
      font-size: 11px;
      color: white;
      padding: 2px 6px;
      border-radius: 3px;
      white-space: nowrap;
      font-weight: 500;
      pointer-events: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
    }

    /* Collaboration status indicator */
    #collab-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      font-size: 11px;
      border-radius: 4px;
      z-index: 100;
      display: none;
    }

    #collab-status.connected {
      background: rgba(16, 185, 129, 0.9);
      display: block;
    }

    #collab-status.disconnected {
      background: rgba(239, 68, 68, 0.9);
      display: block;
    }

    #collab-users {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .collab-user {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      color: white;
      font-weight: 500;
    }

    .ProseMirror h1 {
      font-size: 2em;
      margin: 0.67em 0;
      font-weight: bold;
    }

    .ProseMirror h2 {
      font-size: 1.5em;
      margin: 0.75em 0;
      font-weight: bold;
    }

    .ProseMirror p {
      margin: 1em 0;
    }

    .ProseMirror ul, .ProseMirror ol {
      padding-left: 30px;
    }

    .ProseMirror strong {
      font-weight: bold;
    }

    .ProseMirror em {
      font-style: italic;
    }

    .ProseMirror .geo-mark {
      background-color: rgba(59, 130, 246, 0.2);
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none !important;
      border: none !important;
      border-bottom: none !important;
      -webkit-text-decoration: none !important;
    }

    .ProseMirror .geo-mark:hover {
      background-color: rgba(59, 130, 246, 0.3);
    }

    .ProseMirror .comment-mark {
      background-color: rgba(251, 191, 36, 0.3);
      border-bottom: 2px solid rgba(251, 191, 36, 0.6);
      cursor: pointer;
      padding: 1px 0;
      transition: all 0.2s ease;
    }

    .ProseMirror .comment-mark:hover {
      background-color: rgba(251, 191, 36, 0.4);
      border-bottom-color: rgba(251, 191, 36, 0.9);
    }

    .ProseMirror .comment-mark[data-resolved="true"] {
      background-color: rgba(156, 163, 175, 0.2);
      border-bottom-color: rgba(156, 163, 175, 0.4);
      opacity: 0.7;
    }

    /* Voice dictation pending mark */
    .ProseMirror .pending-voice {
      background-color: rgba(251, 191, 36, 0.25);
      border-left: 3px solid #FBBF24;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: default;
      transition: all 0.2s ease;
    }

    /* Voice control buttons */
    .voice-control-buttons {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      gap: 12px;
      background: white;
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      z-index: 999;
      animation: slideUp 0.3s ease-out;
      flex-direction: column;
      align-items: center;
    }

    .voice-control-buttons.visible {
      display: flex;
    }

    .voice-button-row {
      display: flex;
      gap: 12px;
    }

    .voice-btn {
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 16px;
      border: none;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 120px;
    }

    .voice-btn-accept {
      background: #10B981;
      color: white;
    }

    .voice-btn-accept:hover {
      background: #059669;
      transform: scale(1.05);
    }

    .voice-btn-reject {
      background: #EF4444;
      color: white;
    }

    .voice-btn-reject:hover {
      background: #DC2626;
      transform: scale(1.05);
    }

    .voice-help-text {
      font-size: 12px;
      color: #6B7280;
      text-align: center;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translate(-50%, 20px);
      }
      to {
        opacity: 1;
        transform: translate(-50%, 0);
      }
    }

    .status-bar {
      display: none; /* Hidden to save space */
    }

    #editor-container {
      padding: 0;
      height: 100%;
      overflow-y: auto;
      position: relative; /* Make editor container the positioning context */
    }

    /* Location modal */
    .location-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .location-modal-overlay.active {
      display: flex;
    }

    .location-modal {
      background: white;
      border-radius: 12px;
      width: 90%;
      max-width: 500px;
      max-height: 80vh;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      display: flex;
      flex-direction: column;
    }

    .location-modal-header {
      padding: 20px;
      border-bottom: 1px solid #E5E7EB;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .location-modal-title {
      font-size: 18px;
      font-weight: 700;
      color: #111827;
    }

    .location-modal-close {
      background: none;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: #6B7280;
      padding: 0;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 6px;
    }

    .location-modal-close:hover {
      background: #F3F4F6;
    }

    .location-modal-body {
      padding: 0;
      overflow: hidden;
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .location-modal-map {
      height: 300px;
      width: 100%;
      background: #f0f0f0;
      position: relative;
    }

    .location-modal-search {
      padding: 20px;
      border-bottom: 1px solid #e5e7eb;
    }

    .location-modal-results {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .location-search-input {
      width: 100%;
      padding: 12px;
      border: 2px solid #E5E7EB;
      border-radius: 8px;
      font-size: 14px;
      margin-bottom: 16px;
      box-sizing: border-box;
    }

    .location-search-input:focus {
      outline: none;
      border-color: #3B82F6;
    }

    .location-results {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .location-result-item {
      padding: 12px;
      border: 1px solid #E5E7EB;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .location-result-item:hover {
      background: #F9FAFB;
      border-color: #3B82F6;
    }

    .location-result-name {
      font-weight: 600;
      color: #111827;
      margin-bottom: 4px;
    }

    .location-result-address {
      font-size: 13px;
      color: #6B7280;
    }

    .location-loading {
      text-align: center;
      padding: 40px;
      color: #6B7280;
    }

    .location-no-results {
      text-align: center;
      padding: 40px;
      color: #6B7280;
    }

    /* Slash Menu Styles */
    .slash-menu {
      position: absolute;
      background: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      padding: 4px;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
    }

    .slash-menu.visible {
      display: block;
    }

    .slash-menu-item {
      padding: 8px 12px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.15s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: #1f2937;
    }

    .slash-menu-item:hover {
      background-color: #f3f4f6;
    }

    .slash-menu-item.selected {
      background-color: #3b82f6;
      color: white;
    }

    .slash-menu-item-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .slash-menu-filter {
      color: #6b7280;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="status-bar" id="status">Loading ProseMirror...</div>
  <div id="collab-status">Disconnected</div>
  <div id="collab-users"></div>
  <div id="editor-container"></div>

  <!-- Slash Menu -->
  <div id="slashMenu" class="slash-menu"></div>

  <!-- Voice Control Buttons -->
  <div id="voiceControlButtons" class="voice-control-buttons">
    <div class="voice-button-row">
      <button id="acceptVoiceBtn" class="voice-btn voice-btn-accept">âœ“ Accept</button>
      <button id="rejectVoiceBtn" class="voice-btn voice-btn-reject">âœ— Reject</button>
    </div>
    <div class="voice-help-text">Edit the text above and click Accept or Reject</div>
  </div>

  <!-- Draft Control Buttons -->
  <div id="draftControlButtons" class="voice-control-buttons">
    <div class="voice-button-row">
      <button id="acceptDraftBtn" class="voice-btn voice-btn-accept">âœ“ Accept Draft</button>
    </div>
    <div class="voice-help-text">New text is marked as draft until accepted</div>
  </div>

  <!-- Location Modal -->
  <div id="locationModalOverlay" class="location-modal-overlay">
    <div class="location-modal">
      <div class="location-modal-header">
        <div class="location-modal-title">Add Location</div>
        <button class="location-modal-close" id="closeLocationModal">Ã—</button>
      </div>
      <div class="location-modal-body">
        <div id="locationMap" class="location-modal-map"></div>
        <div class="location-modal-search">
          <input
            type="text"
            class="location-search-input"
            id="locationSearchInput"
            placeholder="Search for a location..."
          />
        </div>
        <div class="location-modal-results">
          <div id="locationResults" class="location-results"></div>
        </div>
      </div>
    </div>
  </div>
  <div id="typing-cursor"></div>

  <script>
    console.log('[WebView] Script starting...');

    // Polyfill Web Locks API for sandboxed iframes
    if (!navigator.locks) {
      console.log('[WebView] Polyfilling Web Locks API');
      navigator.locks = {
        request: async function(name, options, callback) {
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          // Simple polyfill - just run the callback immediately
          // This doesn't provide actual locking, but Supabase should handle it
          return await callback({ name, mode: options.mode || 'exclusive' });
        }
      };
    }

    // Set up message handler
    function sendMessageToNative(message) {
      try {
        const json = JSON.stringify(message);
        if (window.ReactNativeWebView) {
          // Native WebView (iOS/Android)
          window.ReactNativeWebView.postMessage(json);
        } else if (window.parent && window.parent !== window) {
          // Web iframe
          window.parent.postMessage(json, '*');
        } else {
          console.warn('[WebView] No message handler available');
        }
      } catch (e) {
        console.error('[WebView] Error sending message:', e);
      }
    }

    // Wrapper for Enter key handler that sends tool picker message to React Native
    function createEnterKeyHandler(view) {
      return (state, dispatch) => {
        const result = window.PM.handleEnterWithSelection(view)(state, dispatch);

        if (result && result.showToolPicker) {
          const { selectedText, from, to, coordsStart, coordsEnd } = result.data;

          // Get editor container for coordinate calculation
          const editorContainer = document.querySelector('#editor-container');
          const editorRect = editorContainer.getBoundingClientRect();

          // Calculate midpoint Y for consistent positioning
          const midpointY = (coordsStart.top + coordsStart.bottom) / 2;

          // Send message to React Native to show tool picker
          sendMessageToNative({
            type: 'showToolPicker',
            data: {
              selectedText: selectedText,
              from: from,
              to: to,
              selectionTop: midpointY - editorRect.top,
              selectionLeft: coordsStart.left - editorRect.left,
              selectionWidth: coordsEnd.right - coordsStart.left
            }
          });

          return true; // Prevent default Enter behavior
        }

        return false; // Allow default Enter behavior (line break)
      };
    }

    // Define slash menu items
    const slashMenuItems = [
      {
        id: 'heading1',
        label: 'Heading 1',
        type: 'command',
        available: () => true,
        command: (view) => {
          const { state, dispatch } = view;
          const { $from } = state.selection;
          const nodeType = state.schema.nodes.heading;

          if (nodeType) {
            const tr = state.tr.setBlockType($from.pos, $from.pos, nodeType, { level: 1 });
            dispatch(tr);
          }
        }
      },
      {
        id: 'heading2',
        label: 'Heading 2',
        type: 'command',
        available: () => true,
        command: (view) => {
          const { state, dispatch } = view;
          const { $from } = state.selection;
          const nodeType = state.schema.nodes.heading;

          if (nodeType) {
            const tr = state.tr.setBlockType($from.pos, $from.pos, nodeType, { level: 2 });
            dispatch(tr);
          }
        }
      },
      {
        id: 'heading3',
        label: 'Heading 3',
        type: 'command',
        available: () => true,
        command: (view) => {
          const { state, dispatch } = view;
          const { $from } = state.selection;
          const nodeType = state.schema.nodes.heading;

          if (nodeType) {
            const tr = state.tr.setBlockType($from.pos, $from.pos, nodeType, { level: 3 });
            dispatch(tr);
          }
        }
      },
      {
        id: 'bulletlist',
        label: 'Bullet List',
        type: 'command',
        available: () => true,
        command: (view) => {
          const { state, dispatch } = view;
          const { $from } = state.selection;
          const listType = state.schema.nodes.bullet_list;
          const itemType = state.schema.nodes.list_item;

          if (listType && itemType) {
            const tr = state.tr.replaceSelectionWith(
              listType.create(null, itemType.create(null, state.schema.nodes.paragraph.create()))
            );
            dispatch(tr);
          }
        }
      },
      {
        id: 'orderedlist',
        label: 'Numbered List',
        type: 'command',
        available: () => true,
        command: (view) => {
          const { state, dispatch } = view;
          const { $from } = state.selection;
          const listType = state.schema.nodes.ordered_list;
          const itemType = state.schema.nodes.list_item;

          if (listType && itemType) {
            const tr = state.tr.replaceSelectionWith(
              listType.create(null, itemType.create(null, state.schema.nodes.paragraph.create()))
            );
            dispatch(tr);
          }
        }
      },
      {
        id: 'location',
        label: 'Add Location',
        type: 'command',
        available: () => true,
        command: (view) => {
          console.log('[SlashMenu] Add Location selected');
          // Trigger location creation flow
          if (window.createLocationFromSelection) {
            window.createLocationFromSelection();
          }
        }
      }
    ];

    // Helper to create standard plugins with Enter key handler
    function createEditorPlugins() {
      const { SlashMenuPlugin, SlashMenuKey } = window.PM.slashMenu;

      console.log('[SlashMenu] Creating slash menu plugin with items:', slashMenuItems);
      const slashPlugin = SlashMenuPlugin(slashMenuItems);
      console.log('[SlashMenu] Plugin created:', slashPlugin);

      return [
        window.PM.history.history(),
        window.PM.keymap({ 'Mod-z': window.PM.history.undo, 'Mod-y': window.PM.history.redo }),
        // Slash menu plugin
        slashPlugin,
        // Custom Enter key handler for tool picker (must be before baseKeymap to override)
        window.PM.keymap({
          'Enter': (state, dispatch, view) => {
            return createEnterKeyHandler(view)(state, dispatch);
          }
        }),
        window.PM.keymap(window.PM.commands.baseKeymap)
      ];
    }

    function setStatus(text, isError = false) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = text;
      statusEl.className = isError ? 'status-bar error' : 'status-bar';
    }

    // Handle errors
    window.addEventListener('error', function(e) {
      console.error('[WebView] Error:', e.message, e.filename, e.lineno);
      setStatus('Error: ' + e.message, true);
      sendMessageToNative({
        type: 'error',
        message: e.message,
        filename: e.filename,
        lineno: e.lineno
      });
    });

    // Load ProseMirror bundle
    console.log('[WebView] About to load ProseMirror bundle...');
    setStatus('Loading ProseMirror bundle...');
  </script>

  <!-- INLINE PROSEMIRROR BUNDLE WILL BE INSERTED HERE -->
  <script id="prosemirror-bundle">
    // This will be replaced with the actual bundle content
    console.log('[WebView] ProseMirror bundle placeholder');
  </script>

  <script>
    console.log('[WebView] [v4-fixed] Checking if ProseMirror loaded...');
    console.log('[WebView] window.PM exists:', typeof window.PM !== 'undefined');
    console.log('[WebView] PM contents:', window.PM);

    if (typeof window.PM === 'undefined') {
      setStatus('ERROR: ProseMirror failed to load', true);
      sendMessageToNative({
        type: 'error',
        message: 'ProseMirror bundle did not load'
      });
    } else {
      setStatus('ProseMirror loaded successfully!');

      // Initialize editor
      const { EditorState, Plugin, PluginKey } = window.PM.state;
      const { EditorView, Decoration, DecorationSet } = window.PM.view;
      const { schema } = window.PM;
      const { keymap } = window.PM;
      const { history, undo, redo } = window.PM.history;
      const { baseKeymap } = window.PM.commands;
      const { Step } = window.PM.transform;

      console.log('[WebView] Creating editor state...');

      let editorView = null;
      let collabConnection = null;
      let collabPlugin = null;
      let socket = null;

      // Y.js collaboration variables
      let ydoc = null;
      let yXmlFragment = null;
      let awareness = null;
      let yProvider = null; // Supabase Y.js provider

      // Buffer for Y.js updates received before collaboration is initialized
      let pendingYjsUpdates = [];

      // WebView Y.js Provider for Supabase Realtime
      class YWebViewProvider {
        constructor(ydoc, { supabase, documentId, userId, userName, debug = false }) {
          this.ydoc = ydoc;
          this.supabase = supabase;
          this.documentId = documentId;
          this.userId = userId;
          this.userName = userName;
          this.debug = debug;
          this.channel = null;
          this.synced = false;

          this.log('YWebViewProvider initialized for document:', this.documentId);
        }

        log(...args) {
          if (this.debug) {
            console.log('[YWebViewProvider]', ...args);
          }
        }

        async connect() {
          this.log('Connecting to channel:', `doc:${this.documentId}`);

          // Create trip-specific channel using injected Supabase client
          this.channel = this.supabase.channel(`doc:${this.documentId}`, {
            config: {
              broadcast: { self: false }, // Don't receive our own broadcasts
            },
          });

          // Listen for Y.js updates from other clients
          this.channel.on('broadcast', { event: 'yjs-update' }, (payload) => {
            this.log('Received yjs-update from remote');
            try {
              let update;

              // Handle both base64 (new) and array (old) formats
              const updateData = payload.payload?.update || payload.update;

              if (!updateData) {
                console.error('[YWebViewProvider] No update in payload:', payload);
                return;
              }

              if (typeof updateData === 'string') {
                // Base64 format
                update = this.base64ToUint8Array(updateData);
              } else if (Array.isArray(updateData)) {
                // Array format (backward compatibility)
                update = new Uint8Array(updateData);
              } else {
                console.error('[YWebViewProvider] Unknown update format:', typeof updateData);
                return;
              }

              window.PM.Y.applyUpdate(this.ydoc, update, 'remote');
              this.log('Applied remote update, size:', update.length);
            } catch (error) {
              console.error('[YWebViewProvider] Error applying update:', error);
            }
          });

          // Subscribe to channel with timeout
          await new Promise((resolve, reject) => {
            // Add timeout to detect hanging
            const timeout = setTimeout(() => {
              console.error('[YWebViewProvider] Channel subscription timeout after 10 seconds');
              reject(new Error('Channel subscription timeout'));
            }, 10000);

            try {
              const subscription = this.channel.subscribe(async (status) => {
                this.log('Channel status:', status);

                if (status === 'SUBSCRIBED') {
                  clearTimeout(timeout);
                  this.log('Channel subscribed, loading initial state...');
                  try {
                    await this.loadInitialState();
                    this.synced = true;
                    this.log('Sync complete, provider ready');
                    resolve();
                  } catch (error) {
                    reject(error);
                  }
                }

                if (status === 'CLOSED') {
                  this.log('Channel closed');
                  this.synced = false;
                }

                if (status === 'CHANNEL_ERROR') {
                  clearTimeout(timeout);
                  reject(new Error('Channel subscription failed'));
                }
              });

              this.log('Subscribe method returned:', subscription);

              // Check if subscription returned an error
              if (subscription && subscription.error) {
                clearTimeout(timeout);
                console.error('[YWebViewProvider] Subscribe error:', subscription.error);
                reject(subscription.error);
              }
            } catch (error) {
              clearTimeout(timeout);
              console.error('[YWebViewProvider] Error calling subscribe:', error);
              reject(error);
            }
          });

          // Broadcast local Y.js updates
          this.ydoc.on('update', this.handleLocalUpdate);

          this.log('Connected and synced');
        }

        handleLocalUpdate = (update, origin) => {
          // Don't broadcast updates that came from remote
          if (origin === 'remote') return;

          this.log('Broadcasting local update, size:', update.length);

          if (this.channel) {
            this.channel.send({
              type: 'broadcast',
              event: 'yjs-update',
              payload: {
                update: this.uint8ArrayToBase64(update),
              },
            });
          }
        };

        async loadInitialState() {
          this.log('Loading initial state from database');

          try {
            this.log('Querying trips table for document:', this.documentId);

            // Use injected Supabase client to load initial state
            const { data, error } = await this.supabase
              .from('trips')
              .select('yjs_state, yjs_clock')
              .eq('id', this.documentId)
              .single();

            this.log('Query result:', { hasData: !!data, hasError: !!error });

            if (error) {
              console.error('[YWebViewProvider] Error loading state:', error);
              // Don't throw - just continue with empty state
              this.log('Continuing with empty state');
              return;
            }

            if (data?.yjs_state) {
              this.log('Applying initial state, clock:', data.yjs_clock);

              let state;

              if (data.yjs_state instanceof Uint8Array) {
                state = data.yjs_state;
              } else if (Array.isArray(data.yjs_state)) {
                state = new Uint8Array(data.yjs_state);
              } else if (typeof data.yjs_state === 'string') {
                // Handle hex or base64
                if (data.yjs_state.startsWith('\\x')) {
                  // PostgreSQL bytea format
                  const hex = data.yjs_state.substring(2);
                  const bytes = new Uint8Array(hex.length / 2);
                  for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
                  }
                  state = bytes;
                } else {
                  // Base64
                  state = this.base64ToUint8Array(data.yjs_state);
                }
              } else {
                console.error('[YWebViewProvider] Unknown yjs_state format:', typeof data.yjs_state);
                throw new Error('Unknown yjs_state format');
              }

              this.log('Applying Y.js state, size:', state.length);
              window.PM.Y.applyUpdate(this.ydoc, state, 'remote');
            } else {
              this.log('No initial state found, document is empty');
            }
          } catch (error) {
            console.error('[YWebViewProvider] Error in loadInitialState:', error);
            throw error;
          }
        }

        async destroy() {
          this.log('Destroying provider');

          // Remove event listeners
          this.ydoc.off('update', this.handleLocalUpdate);

          // Unsubscribe from channel
          if (this.channel) {
            await this.supabase.removeChannel(this.channel);
            this.channel = null;
          }

          this.synced = false;
          this.log('Provider destroyed');
        }

        uint8ArrayToBase64(bytes) {
          let binary = '';
          for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        }

        base64ToUint8Array(base64) {
          const binary = atob(base64);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes;
        }
      }

      // Create initial document - empty, content will be sent from React Native
      const { DOMParser: PMDOMParser } = window.PM.model;

      // Start with empty document - content will be sent from React Native
      const doc = schema.node('doc', null, [
        schema.node('paragraph', null, [])
      ]);

      // Create initial editor state
      // Location Modal Functions
      let currentLocationSelection = null;
      let locationMap = null;
      let locationMarker = null;

      function initLocationMap(lat, lng) {
        if (!locationMap) {
          // Check if mapboxgl is available
          if (typeof mapboxgl === 'undefined') {
            console.warn('[LocationModal] Mapbox GL JS not loaded');
            return;
          }

          // Get Mapbox token from environment (passed via postMessage)
          if (!window.__mapboxToken) {
            console.error('[LocationModal] No Mapbox token available. Set EXPO_PUBLIC_MAPBOX_TOKEN in your environment.');
            return;
          }

          mapboxgl.accessToken = window.__mapboxToken;

          locationMap = new mapboxgl.Map({
            container: 'locationMap',
            style: 'mapbox://styles/mapbox/light-v11',
            center: [lng, lat],
            zoom: 12
          });

          // Disable map rotation
          locationMap.dragRotate.disable();
          locationMap.touchZoomRotate.disableRotation();
        }

        // Update or create marker
        if (locationMarker) {
          locationMarker.setLngLat([lng, lat]);
        } else {
          locationMarker = new mapboxgl.Marker({ color: '#3B82F6' })
            .setLngLat([lng, lat])
            .addTo(locationMap);
        }

        // Fly to location
        locationMap.flyTo({
          center: [lng, lat],
          zoom: 12,
          duration: 1000
        });
      }

      function showLocationModal(searchText, from, to) {
        console.log('[LocationModal] Showing modal for:', searchText);
        currentLocationSelection = { searchText, from, to };

        const modalOverlay = document.getElementById('locationModalOverlay');
        const searchInput = document.getElementById('locationSearchInput');
        const resultsContainer = document.getElementById('locationResults');

        // Set initial search query
        searchInput.value = searchText;

        // Show modal
        modalOverlay.classList.add('active');

        // Focus search input
        setTimeout(() => searchInput.focus(), 100);

        // Fetch initial results
        searchLocations(searchText, resultsContainer);
      }

      function hideLocationModal() {
        console.log('[LocationModal] Hiding modal');
        const modalOverlay = document.getElementById('locationModalOverlay');
        modalOverlay.classList.remove('active');
        currentLocationSelection = null;
      }

      function searchLocations(query, resultsContainer) {
        if (!query.trim()) {
          resultsContainer.innerHTML = '<div class="location-no-results">Enter a location to search</div>';
          return;
        }

        resultsContainer.innerHTML = '<div class="location-loading">Searching...</div>';

        fetch(
          `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(query)}&format=jsonv2&limit=5&addressdetails=1`,
          { headers: { 'User-Agent': 'TourVision-App' } }
        )
          .then(res => res.json())
          .then(results => {
            if (!results || results.length === 0) {
              resultsContainer.innerHTML = '<div class="location-no-results">No locations found</div>';
              return;
            }

            resultsContainer.innerHTML = results.map(result => `
              <div class="location-result-item" data-lat="${result.lat}" data-lng="${result.lon}" data-name="${escapeHtml(result.display_name)}">
                <div class="location-result-name">${escapeHtml(result.name || result.display_name.split(',')[0])}</div>
                <div class="location-result-address">${escapeHtml(result.display_name)}</div>
              </div>
            `).join('');

            // Add click handlers to results
            resultsContainer.querySelectorAll('.location-result-item').forEach(item => {
              item.addEventListener('click', () => {
                const lat = parseFloat(item.dataset.lat);
                const lng = parseFloat(item.dataset.lng);
                const placeName = item.dataset.name;

                // Update map view
                initLocationMap(lat, lng);

                handleLocationSelected(placeName, lat, lng);
              });
            });

            // Initialize map with first result
            if (results.length > 0) {
              const firstResult = results[0];
              initLocationMap(parseFloat(firstResult.lat), parseFloat(firstResult.lon));
            }
          })
          .catch(error => {
            console.error('[LocationModal] Search error:', error);
            resultsContainer.innerHTML = '<div class="location-no-results">Error searching locations</div>';
          });
      }

      function handleLocationSelected(placeName, lat, lng) {
        console.log('[LocationModal] Location selected:', { placeName, lat, lng });

        if (!currentLocationSelection) {
          console.error('[LocationModal] No current selection');
          return;
        }

        if (!editorView) {
          console.error('[LocationModal] Editor view not available');
          return;
        }

        // Create geo-mark in the document
        const { searchText, from, to } = currentLocationSelection;

        try {
          // Generate unique geoId
          const geoId = 'loc-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);

          // Create geo-mark MARK (not node) with location data
          const geoMarkType = schema.marks.geoMark;
          if (!geoMarkType) {
            throw new Error('geoMark mark type not found in schema');
          }

          const geoMarkMark = geoMarkType.create({
            geoId: geoId,
            placeName: placeName,
            lat: lat.toString(),
            lng: lng.toString(),
            colorIndex: 0,
            coordSource: 'nominatim',
            description: null,
            transportFrom: null,
            transportProfile: null,
            waypoints: null,
            visitDocument: null,
            photoName: null
          });

          // Apply the mark to the selected text
          const tr = editorView.state.tr.addMark(from, to, geoMarkMark);

          // Dispatch transaction
          editorView.dispatch(tr);

          console.log('[LocationModal] Geo-mark created successfully:', geoId);
        } catch (error) {
          console.error('[LocationModal] Error creating geo-mark:', error);
        }

        // Hide modal
        hideLocationModal();
      }

      function escapeHtml(unsafe) {
        return unsafe
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }

      // Set up modal event listeners
      document.getElementById('closeLocationModal').addEventListener('click', hideLocationModal);
      document.getElementById('locationModalOverlay').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
          hideLocationModal();
        }
      });

      let searchTimeout;
      document.getElementById('locationSearchInput').addEventListener('input', (e) => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          searchLocations(e.target.value, document.getElementById('locationResults'));
        }, 300);
      });

      let editorState = EditorState.create({
        doc: doc,
        schema: schema,
        plugins: createEditorPlugins()
      });

      console.log('[WebView] Creating editor view...');

      // Color palette for geo-marks - MUST match DocumentSplitMap.tsx
      // NOTE: Geo-marks are now rendered via schema toDOM() method
      // No custom NodeView needed - marks use toDOM for rendering

      // Slash Menu Setup (must be before editor view creation)
      const slashMenuElement = document.getElementById('slashMenu');

      function renderSlashMenu(state) {
        const { SlashMenuKey } = window.PM.slashMenu;
        const slashMenuState = SlashMenuKey.getState(state);

        console.log('[SlashMenu] renderSlashMenu called, state:', slashMenuState);

        if (!slashMenuState || !slashMenuState.open) {
          slashMenuElement.classList.remove('visible');
          return;
        }

        console.log('[SlashMenu] Menu is open, rendering...');
        const { filteredElements, selected } = slashMenuState;
        console.log('[SlashMenu] Filtered elements:', filteredElements);

        // Position the menu at the cursor
        try {
          const { from } = state.selection;
          const coords = editorView.coordsAtPos(from);
          const editorContainer = document.querySelector('#editor-container');
          const editorRect = editorContainer.getBoundingClientRect();

          // Calculate available space below cursor
          const viewportHeight = window.visualViewport?.height || window.innerHeight;
          const spaceBelow = viewportHeight - coords.bottom;
          const menuHeight = 300; // max-height from CSS

          // Position above cursor if not enough space below
          if (spaceBelow < menuHeight && coords.top > menuHeight) {
            // Position above cursor
            slashMenuElement.style.left = (coords.left - editorRect.left) + 'px';
            slashMenuElement.style.bottom = (editorRect.bottom - coords.top + 5) + 'px';
            slashMenuElement.style.top = 'auto';
            console.log('[SlashMenu] Positioning above cursor (not enough space below)');
          } else {
            // Position below cursor (default)
            slashMenuElement.style.left = (coords.left - editorRect.left) + 'px';
            slashMenuElement.style.top = (coords.bottom - editorRect.top + 5) + 'px';
            slashMenuElement.style.bottom = 'auto';
          }
        } catch (e) {
          console.warn('[SlashMenu] Could not position menu:', e);
        }

        // Render menu items
        slashMenuElement.innerHTML = filteredElements.map((item, index) => {
          const isSelected = item.id === selected;
          return `<div class="slash-menu-item ${isSelected ? 'selected' : ''}" data-item-id="${item.id}">
            <span class="slash-menu-item-icon">${getMenuItemIcon(item.id)}</span>
            <span>${item.label}</span>
          </div>`;
        }).join('');

        // Add click handlers
        slashMenuElement.querySelectorAll('.slash-menu-item').forEach((el, index) => {
          el.addEventListener('click', () => {
            const itemId = el.getAttribute('data-item-id');
            const item = filteredElements.find(i => i.id === itemId);
            if (item && item.type === 'command') {
              item.command(editorView);
              closeSlashMenu();
            }
          });
        });

        slashMenuElement.classList.add('visible');
      }

      function getMenuItemIcon(itemId) {
        const icons = {
          'heading1': 'H1',
          'heading2': 'H2',
          'heading3': 'H3',
          'bulletlist': 'â€¢',
          'orderedlist': '1.',
          'location': 'ðŸ“'
        };
        return icons[itemId] || 'â€¢';
      }

      function closeSlashMenu() {
        const { SlashMenuKey, SlashMetaTypes } = window.PM.slashMenu;
        const tr = editorView.state.tr;
        tr.setMeta(SlashMenuKey, { type: SlashMetaTypes.close });
        editorView.dispatch(tr);
      }

      // Typing cursor management
      const typingCursor = document.getElementById('typing-cursor');
      let isTypingActive = false;

      function updateTypingCursor() {
        if (!isTypingActive || !editorView) {
          typingCursor.classList.remove('visible');
          return;
        }

        const { state } = editorView;
        const { selection } = state;
        const { from } = selection;

        // Get the coordinates of the cursor position
        try {
          const coords = editorView.coordsAtPos(from);
          const editorContainer = document.querySelector('#editor-container');
          const editorRect = editorContainer.getBoundingClientRect();

          // Calculate cursor height based on line height
          const cursorHeight = coords.bottom - coords.top;

          // Position and size the cursor indicator
          typingCursor.style.left = (coords.left - editorRect.left) + 'px';
          typingCursor.style.top = (coords.top - editorRect.top) + 'px';
          typingCursor.style.height = cursorHeight + 'px';
          typingCursor.classList.add('visible');

          console.log('[WebView] Cursor updated: height =', cursorHeight);
        } catch (e) {
          console.warn('[WebView] Could not get cursor coordinates:', e);
          typingCursor.classList.remove('visible');
        }
      }

      function showTypingCursor() {
        isTypingActive = true;
        updateTypingCursor();
        console.log('[WebView] Typing cursor shown');
      }

      function hideTypingCursor() {
        isTypingActive = false;
        typingCursor.classList.remove('visible');
        console.log('[WebView] Typing cursor hidden');
      }

      // Expose for native to control
      window.showTypingCursor = showTypingCursor;
      window.hideTypingCursor = hideTypingCursor;

      // Helper functions for toolbar state (must be defined before EditorView)
      // Helper function to update collaboration users display
      function updateCollabUsers() {
        if (!collabConnection) return;

        const usersEl = document.getElementById('collab-users');
        usersEl.innerHTML = '';

        collabConnection.users.forEach((user, userId) => {
          if (userId !== collabConnection.userId) {
            const userEl = document.createElement('div');
            userEl.className = 'collab-user';
            userEl.style.backgroundColor = user.color;
            userEl.textContent = user.name;
            usersEl.appendChild(userEl);
          }
        });
      }

      function isNodeTypeActive(state, nodeType, attrs = {}) {
        const { $from } = state.selection;
        const node = $from.parent;

        if (node.type.name !== nodeType.name) {
          return false;
        }

        // Check attributes match
        for (let key in attrs) {
          if (node.attrs[key] !== attrs[key]) {
            return false;
          }
        }

        return true;
      }

      function isMarkActive(state, markType) {
        const { from, to } = state.selection;
        return state.doc.rangeHasMark(from, to, markType);
      }

      // Get current toolbar state based on selection
      function getToolbarState() {
        const state = editorView.state;
        return {
          paragraph: isNodeTypeActive(state, schema.nodes.paragraph),
          h1: isNodeTypeActive(state, schema.nodes.heading, { level: 1 }),
          h2: isNodeTypeActive(state, schema.nodes.heading, { level: 2 }),
          h3: isNodeTypeActive(state, schema.nodes.heading, { level: 3 }),
          bold: schema.marks.strong ? isMarkActive(state, schema.marks.strong) : false,
          italic: schema.marks.em ? isMarkActive(state, schema.marks.em) : false,
          canUndo: window.PM.history.undo(state),
          canRedo: window.PM.history.redo(state)
        };
      }

      // MapView NodeView for rendering interactive maps
      class MapView {
        constructor(node, view, getPos) {
          this.node = node;
          this.view = view;
          this.getPos = getPos;
          this.map = null;
          this.markers = [];
          this.routeLayers = [];

          // Color palette matching geo-marks
          this.COLORS = [
            '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',
            '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
          ];

          // Create container with explicit dimensions
          this.dom = document.createElement('div');
          this.dom.className = 'prosemirror-map';
          this.dom.style.cssText = `
            width: 100%;
            height: ${node.attrs.height}px;
            background: #f3f4f6;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            margin: 16px 0;
            position: relative;
            overflow: hidden;
          `;

          // Initialize map after a short delay to ensure container is in DOM
          setTimeout(() => this.initMap(), 0);
        }

        collectGeoMarks() {
          const geoMarks = [];
          const seenGeoIds = new Set();
          const mapPos = this.getPos();

          // Traverse from start of document to map position
          this.view.state.doc.nodesBetween(0, mapPos, (node, pos) => {
            if (node.marks) {
              node.marks.forEach(mark => {
                if (mark.type.name === 'geoMark' && !seenGeoIds.has(mark.attrs.geoId)) {
                  seenGeoIds.add(mark.attrs.geoId);
                  geoMarks.push({
                    geoId: mark.attrs.geoId,
                    placeName: mark.attrs.placeName,
                    lat: parseFloat(mark.attrs.lat),
                    lng: parseFloat(mark.attrs.lng),
                    colorIndex: mark.attrs.colorIndex || 0,
                    transportFrom: mark.attrs.transportFrom,
                    transportProfile: mark.attrs.transportProfile,
                    waypoints: mark.attrs.waypoints
                  });
                }
              });
            }
          });

          console.log('[MapView] Collected geo-marks:', geoMarks);
          return geoMarks;
        }

        initMap() {
          const geoMarks = this.collectGeoMarks();

          if (geoMarks.length === 0) {
            // Show empty state
            this.dom.innerHTML = `
              <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #6b7280;">
                ðŸ—ºï¸ No locations to display yet
              </div>
            `;
            return;
          }

          // Get Mapbox token (hardcoded fallback)
          const mapboxToken = window.mapboxToken || 'pk.eyJ1IjoibWFkc2JlcnRlbHNlbiIsImEiOiJja2tjeDgxZWYwNHU5MnhtaTVndWRmeHpzIn0.Zs-SFtuSE9I1XAG-TG2fsw';

          // Initialize Mapbox GL map
          mapboxgl.accessToken = mapboxToken;

          // Use bounds for multiple locations, center/zoom for single location
          const mapConfig = {
            container: this.dom,
            style: 'mapbox://styles/mapbox/light-v11',
            trackResize: true
          };

          if (geoMarks.length === 1) {
            // Single location - use center and zoom
            mapConfig.center = [geoMarks[0].lng, geoMarks[0].lat];
            mapConfig.zoom = 11;
          } else if (geoMarks.length > 1) {
            // Multiple locations - use bounds for automatic fitting
            // Include both markers and waypoints
            const coordinates = [];

            // Add all marker coordinates
            geoMarks.forEach(gm => {
              coordinates.push([gm.lng, gm.lat]);

              // Also add waypoints if they exist
              if (gm.waypoints && Array.isArray(gm.waypoints)) {
                gm.waypoints.forEach(wp => {
                  coordinates.push([wp.lng, wp.lat]);
                });
              }
            });

            const bbox = coordinates.reduce((bounds, coord) => {
              return bounds.extend(coord);
            }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));

            mapConfig.bounds = bbox;
            mapConfig.fitBoundsOptions = { padding: 50 };
          } else {
            // No locations
            mapConfig.center = [0, 0];
            mapConfig.zoom = 2;
          }

          this.map = new mapboxgl.Map(mapConfig);

          // Add navigation controls
          this.map.addControl(new mapboxgl.NavigationControl(), 'top-right');

          // Wait for map to load
          this.map.on('load', async () => {
            console.log('[MapView] Map loaded, adding markers and routes');

            // Add markers
            this.addMarkers(geoMarks);

            // Fetch and add routes, then fit bounds to include them
            await this.addRoutes(geoMarks);

            // After routes are added, fit bounds to include everything
            if (geoMarks.length > 1) {
              this.fitBoundsToContent();
            }
          });
        }

        calculateBounds(geoMarks) {
          if (geoMarks.length === 0) {
            return { center: [0, 0], zoom: 2 };
          }

          if (geoMarks.length === 1) {
            return {
              center: [geoMarks[0].lng, geoMarks[0].lat],
              zoom: 11
            };
          }

          // Calculate center
          const lats = geoMarks.map(gm => gm.lat);
          const lngs = geoMarks.map(gm => gm.lng);
          const centerLat = (Math.min(...lats) + Math.max(...lats)) / 2;
          const centerLng = (Math.min(...lngs) + Math.max(...lngs)) / 2;

          // Calculate zoom based on bounds (with padding consideration)
          const latDiff = Math.max(...lats) - Math.min(...lats);
          const lngDiff = Math.max(...lngs) - Math.min(...lngs);
          const maxDiff = Math.max(latDiff, lngDiff);

          // More granular zoom levels with padding consideration
          let zoom = 10;
          if (maxDiff > 20) zoom = 2;
          else if (maxDiff > 10) zoom = 4;
          else if (maxDiff > 5) zoom = 5;
          else if (maxDiff > 2) zoom = 6;
          else if (maxDiff > 1) zoom = 7;
          else if (maxDiff > 0.5) zoom = 8;
          else if (maxDiff > 0.2) zoom = 9;
          else if (maxDiff > 0.1) zoom = 10;

          return {
            center: [centerLng, centerLat],
            zoom
          };
        }

        addMarkers(geoMarks) {
          geoMarks.forEach((gm, index) => {
            const color = this.COLORS[gm.colorIndex % this.COLORS.length];

            // Create marker element (matching DocumentSplitMap style)
            const markerEl = document.createElement('div');
            markerEl.style.cssText = `
              width: 32px;
              height: 32px;
              border-radius: 16px;
              background-color: ${color};
              border: 3px solid white;
              box-shadow: 0 2px 4px rgba(0,0,0,0.3);
              display: flex;
              align-items: center;
              justify-content: center;
            `;

            const innerEl = document.createElement('div');
            innerEl.style.cssText = `
              width: 12px;
              height: 12px;
              border-radius: 6px;
              background-color: white;
            `;
            markerEl.appendChild(innerEl);

            // Create marker
            const marker = new mapboxgl.Marker({ element: markerEl })
              .setLngLat([gm.lng, gm.lat])
              .setPopup(new mapboxgl.Popup().setHTML(`<strong>${gm.placeName}</strong>`))
              .addTo(this.map);

            this.markers.push(marker);
          });
        }

        async addRoutes(geoMarks) {
          if (geoMarks.length < 2) return;

          const mapboxToken = window.mapboxToken || 'pk.eyJ1IjoibWFkc2JlcnRlbHNlbiIsImEiOiJja2tjeDgxZWYwNHU5MnhtaTVndWRmeHpzIn0.Zs-SFtuSE9I1XAG-TG2fsw';
          this.routeGeometries = []; // Store route geometries for bounds calculation

          // Fetch routes between consecutive locations
          for (let i = 1; i < geoMarks.length; i++) {
            const from = geoMarks[i - 1];
            const to = geoMarks[i];

            // Build coordinates with waypoints
            let coordinates;
            if (to.waypoints && to.waypoints.length > 0) {
              const waypointCoords = to.waypoints.map(wp => `${wp.lng},${wp.lat}`).join(';');
              coordinates = `${from.lng},${from.lat};${waypointCoords};${to.lng},${to.lat}`;
            } else {
              coordinates = `${from.lng},${from.lat};${to.lng},${to.lat}`;
            }

            // Determine transport profile
            const profile = to.transportProfile || 'walking';
            const url = `https://api.mapbox.com/directions/v5/mapbox/${profile}/${coordinates}?geometries=geojson&access_token=${mapboxToken}`;

            try {
              const response = await fetch(url);
              const data = await response.json();

              if (data.routes && data.routes[0]) {
                const routeId = `route-${from.geoId}-${to.geoId}`;
                const color = this.COLORS[to.colorIndex % this.COLORS.length];
                const geometry = data.routes[0].geometry;

                // Store geometry for bounds calculation
                this.routeGeometries.push(geometry);

                // Add route as source and layer
                this.map.addSource(routeId, {
                  type: 'geojson',
                  data: {
                    type: 'Feature',
                    geometry: geometry
                  }
                });

                this.map.addLayer({
                  id: routeId,
                  type: 'line',
                  source: routeId,
                  paint: {
                    'line-color': color,
                    'line-width': 3,
                    'line-opacity': 0.75
                  }
                });

                this.routeLayers.push(routeId);
              }
            } catch (error) {
              console.error('[MapView] Error fetching route:', error);
            }
          }
        }

        fitBoundsToContent() {
          // Calculate bounds that include all route geometries
          const bounds = new mapboxgl.LngLatBounds();

          // Add all route coordinates
          if (this.routeGeometries) {
            this.routeGeometries.forEach(geometry => {
              if (geometry.type === 'LineString' && geometry.coordinates) {
                geometry.coordinates.forEach(coord => {
                  bounds.extend(coord);
                });
              }
            });
          }

          // Fit map to calculated bounds
          if (!bounds.isEmpty()) {
            this.map.fitBounds(bounds, {
              padding: 50,
              duration: 0 // No animation to prevent flickering
            });
          }
        }

        update(node) {
          // Check if node changed (e.g., height attribute)
          if (node.attrs.height !== this.node.attrs.height) {
            this.node = node;
            this.dom.style.height = `${node.attrs.height}px`;
            if (this.map) {
              this.map.resize();
            }
            return true;
          }
          return true;
        }

        destroy() {
          console.log('[MapView] Destroying map');

          // Remove markers
          this.markers.forEach(marker => marker.remove());
          this.markers = [];

          // Remove route layers
          if (this.map) {
            this.routeLayers.forEach(layerId => {
              if (this.map.getLayer(layerId)) {
                this.map.removeLayer(layerId);
              }
              if (this.map.getSource(layerId)) {
                this.map.removeSource(layerId);
              }
            });
            this.routeLayers = [];

            // Remove map
            this.map.remove();
            this.map = null;
          }
        }

        stopEvent() {
          return true; // Prevent ProseMirror from handling events inside the map
        }
      }

      // Create editor view
      editorView = new EditorView(document.querySelector('#editor-container'), {
        state: editorState,
        nodeViews: {
          map(node, view, getPos) {
            return new MapView(node, view, getPos);
          }
        },
        attributes: {
          spellcheck: 'false',
          autocorrect: 'off',
          autocapitalize: 'off'
        },
        dispatchTransaction(transaction) {
          const oldState = editorView.state;
          let newState = oldState.apply(transaction);

          // Auto-apply draft mark to new text insertions
          if (transaction.docChanged && !transaction.getMeta('draftApplied')) {
            const draftMark = schema.marks.draft.create({
              sessionId: draftSessionId,
              timestamp: Date.now()
            });

            // Find newly inserted text and apply draft mark
            let tr = newState.tr;
            let modified = false;

            transaction.steps.forEach((step, i) => {
              if (step.jsonID === 'replace' || step.jsonID === 'replaceAround') {
                const map = transaction.mapping.maps[i];
                map.forEach((oldStart, oldEnd, newStart, newEnd) => {
                  // Only mark if text was inserted (newEnd > newStart)
                  if (newEnd > newStart) {
                    const slice = newState.doc.slice(newStart, newEnd);
                    // Check if inserted content is plain text (not already marked or special nodes)
                    let hasPlainText = false;
                    slice.content.forEach(node => {
                      if (node.isText && !node.marks.some(m => m.type.name === 'draft')) {
                        hasPlainText = true;
                      }
                    });

                    if (hasPlainText) {
                      tr.addMark(newStart, newEnd, draftMark);
                      modified = true;
                    }
                  }
                });
              }
            });

            if (modified) {
              tr.setMeta('draftApplied', true);
              newState = newState.apply(tr);
            }
          }

          editorView.updateState(newState);

          // Update draft button visibility
          updateDraftButtonVisibility();

          // Update typing cursor position on any change
          if (isTypingActive) {
            updateTypingCursor();
          }

          // Send document changes to native
          // NOTE: Even during Y.js collaboration, we need to persist to localStorage
          if (transaction.docChanged) {
            const docJSON = newState.doc.toJSON();
            if (yProvider) {
              console.log('[WebView] Document changed via Y.js, sending to native for persistence');
            } else {
              console.log('[WebView] Document changed, sending to native');
            }
            sendMessageToNative({
              type: 'documentChange',
              doc: docJSON
            });

            // Check for trigger word "assist" - only trigger once
            const docText = newState.doc.textContent.toLowerCase();

            if (!assistTriggered && docText.includes('assist')) {
              assistTriggered = true;
              console.log('[Trigger] âœ… Assist detected! Extracting draft text...');

              // Extract text with draft marks
              let draftText = '';
              newState.doc.descendants((node, pos) => {
                if (node.isText && node.marks.some(m => m.type.name === 'draft')) {
                  draftText += node.text;
                }
              });

              console.log('[Trigger] Draft text extracted:', draftText);

              // Send message to React Native with both full text and draft text
              sendMessageToNative({
                type: 'assistTrigger',
                text: docText,
                draftText: draftText,
                hasDraft: draftText.length > 0,
                timestamp: new Date().toISOString()
              });

              // Reset after 5 seconds to allow triggering again
              setTimeout(function() {
                assistTriggered = false;
                console.log('[Trigger] Assist trigger reset');
              }, 5000);
            }
          }

          // Send selection changes to native
          const oldSelection = oldState.selection;
          const newSelection = newState.selection;
          if (!oldSelection.eq(newSelection)) {
            console.log('[WebView] Selection changed, empty:', newSelection.empty);

            // Calculate selection coordinates for immediate line rendering
            let selectionData = {
              empty: newSelection.empty
            };

            if (!newSelection.empty) {
              try {
                const coordsStart = editorView.coordsAtPos(newSelection.from);
                const coordsEnd = editorView.coordsAtPos(newSelection.to);
                const editorContainer = document.querySelector('#editor-container');
                const editorRect = editorContainer.getBoundingClientRect();
                const midpointY = (coordsStart.top + coordsStart.bottom) / 2;
                // coordsAtPos returns absolute coordinates, just subtract container position (not padding!)
                selectionData.selectionTop = midpointY - editorRect.top;
                selectionData.selectionLeft = coordsStart.left - editorRect.left;
                selectionData.selectionWidth = coordsEnd.right - coordsStart.left;
              } catch (e) {
                console.warn('[WebView] Could not get selection coordinates:', e);
              }
            }

            sendMessageToNative({
              type: 'selectionChange',
              ...selectionData
            });

            // Send toolbar state update
            const toolbarState = getToolbarState();
            sendMessageToNative({
              type: 'toolbarStateChange',
              state: toolbarState
            });
          }

          // Render slash menu on state update
          renderSlashMenu(newState);
        }
      });

      console.log('[WebView] Editor created successfully');
      setStatus('Editor ready');

      // Track if assist trigger has been detected
      let assistTriggered = false;

      // Voice dictation: Listen for composition end (when user presses Done after voice input)
      let compositionText = '';
      let voiceSessionActive = false;
      let voiceSessionStartPos = null;
      let voiceSessionId = null;

      // Draft mode: Track session for auto-marking new text
      const draftSessionId = `draft-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      document.querySelector('.ProseMirror').addEventListener('compositionstart', function(e) {
        console.log('[VoiceDictation] Composition started');
        compositionText = '';

        // Track session details
        voiceSessionStartPos = editorView.state.selection.from;
        voiceSessionId = `voice-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        voiceSessionActive = true;

        console.log('[VoiceDictation] Voice session started:', voiceSessionId, 'at position:', voiceSessionStartPos);
      });

      document.querySelector('.ProseMirror').addEventListener('compositionupdate', function(e) {
        compositionText = e.data || '';
        console.log('[VoiceDictation] Composition updating:', compositionText);
      });

      document.querySelector('.ProseMirror').addEventListener('compositionend', function(e) {
        const finalText = e.data || compositionText;
        voiceSessionActive = false;

        console.log('[VoiceDictation] Composition ended, text:', finalText);

        if (finalText && finalText.length > 3) {
          const { state, dispatch } = editorView;
          const endPos = state.selection.from;
          const startPos = voiceSessionStartPos;

          console.log('[VoiceDictation] Applying pendingVoice mark from', startPos, 'to', endPos);

          // Apply pendingVoice mark to the transcribed text
          const pendingVoiceMark = schema.marks.pendingVoice.create({
            voiceSessionId: voiceSessionId,
            startTime: new Date().toISOString(),
            transcribedText: finalText,
            editedText: null,
            correctionRound: 0
          });

          const tr = state.tr.addMark(startPos, endPos, pendingVoiceMark);
          dispatch(tr);

          console.log('[VoiceDictation] Mark applied, showing control buttons');

          // Show accept/reject buttons
          const controlButtons = document.getElementById('voiceControlButtons');
          if (controlButtons) {
            controlButtons.classList.add('visible');
          }

          // Send to native to process with LLM for location extraction
          sendMessageToNative({
            type: 'voiceDictationComplete',
            text: finalText,
            cursorPos: endPos,
            voiceSessionId: voiceSessionId
          });
        }
      });

      // Helper function to find all nodes with pendingVoice marks
      function getCurrentVoiceSession() {
        const { state } = editorView;
        let voiceMarks = [];

        state.doc.nodesBetween(0, state.doc.content.size, (node, pos) => {
          if (node.isText && node.marks) {
            const voiceMark = node.marks.find(m => m.type === schema.marks.pendingVoice);
            if (voiceMark) {
              voiceMarks.push({
                mark: voiceMark,
                pos: pos,
                size: node.nodeSize
              });
            }
          }
        });

        return voiceMarks;
      }

      // Accept voice button handler
      document.getElementById('acceptVoiceBtn').addEventListener('click', function() {
        console.log('[VoiceDictation] Accept button clicked');
        const { state, dispatch } = editorView;
        const voiceMarks = getCurrentVoiceSession();

        if (voiceMarks.length === 0) {
          console.log('[VoiceDictation] No voice marks found to accept');
          return;
        }

        console.log('[VoiceDictation] Found', voiceMarks.length, 'voice marks to accept');

        // Remove all pendingVoice marks (keep the text)
        let tr = state.tr;
        voiceMarks.forEach(({ pos, size }) => {
          tr = tr.removeMark(pos, pos + size, schema.marks.pendingVoice);
        });

        dispatch(tr);

        // Hide control buttons
        document.getElementById('voiceControlButtons').classList.remove('visible');

        // Extract accepted text for notification
        const acceptedText = voiceMarks.length > 0
          ? state.doc.textBetween(voiceMarks[0].pos, voiceMarks[voiceMarks.length - 1].pos + voiceMarks[voiceMarks.length - 1].size, ' ')
          : '';

        console.log('[VoiceDictation] Voice input accepted:', acceptedText);

        // Notify native
        sendMessageToNative({
          type: 'voiceAccepted',
          text: acceptedText
        });
      });

      // Reject voice button handler
      document.getElementById('rejectVoiceBtn').addEventListener('click', function() {
        console.log('[VoiceDictation] Reject button clicked');
        const { state, dispatch } = editorView;
        const voiceMarks = getCurrentVoiceSession();

        if (voiceMarks.length === 0) {
          console.log('[VoiceDictation] No voice marks found to reject');
          return;
        }

        console.log('[VoiceDictation] Found', voiceMarks.length, 'voice marks to reject');

        // Find the range of text to delete
        let deleteStart = null;
        let deleteEnd = null;

        voiceMarks.forEach(({ pos, size }) => {
          if (deleteStart === null || pos < deleteStart) {
            deleteStart = pos;
          }
          if (deleteEnd === null || pos + size > deleteEnd) {
            deleteEnd = pos + size;
          }
        });

        console.log('[VoiceDictation] Deleting text from', deleteStart, 'to', deleteEnd);

        // Delete all marked text
        let tr = state.tr;
        if (deleteStart !== null && deleteEnd !== null) {
          tr = tr.delete(deleteStart, deleteEnd);
        }

        dispatch(tr);

        // Hide control buttons
        document.getElementById('voiceControlButtons').classList.remove('visible');

        console.log('[VoiceDictation] Voice input rejected and deleted');

        // Notify native
        sendMessageToNative({
          type: 'voiceRejected',
          reason: 'User clicked reject'
        });
      });

      // Draft mode: Accept draft button handler
      document.getElementById('acceptDraftBtn').addEventListener('click', function() {
        console.log('[Draft] Accept button clicked');
        const { state, dispatch } = editorView;

        // Find all draft marks in document
        let tr = state.tr;
        let removed = 0;

        state.doc.descendants((node, pos) => {
          if (node.isText) {
            const draftMark = node.marks.find(m => m.type.name === 'draft');
            if (draftMark) {
              tr = tr.removeMark(pos, pos + node.nodeSize, schema.marks.draft);
              removed++;
            }
          }
        });

        if (removed > 0) {
          dispatch(tr);
          console.log('[Draft] Removed', removed, 'draft marks');

          // Hide draft control buttons
          updateDraftButtonVisibility();

          // Notify native
          sendMessageToNative({
            type: 'draftAccepted',
            marksRemoved: removed
          });
        } else {
          console.log('[Draft] No draft marks found');
        }
      });

      // Draft mode: Check if draft marks exist and show/hide button
      function updateDraftButtonVisibility() {
        const { state } = editorView;
        let hasDraft = false;

        state.doc.descendants((node) => {
          if (node.isText && node.marks.some(m => m.type.name === 'draft')) {
            hasDraft = true;
            return false; // Stop traversal
          }
        });

        const draftButtons = document.getElementById('draftControlButtons');
        if (hasDraft) {
          draftButtons.classList.add('visible');
        } else {
          draftButtons.classList.remove('visible');
        }
      }

      // Add click handler for geo-marks and comments
      document.querySelector('.ProseMirror').addEventListener('click', function(e) {
        console.log('[WebView] Click detected on:', e.target, 'classes:', e.target.classList);
        if (e.target.classList.contains('geo-mark')) {
          const attrs = {
            geoId: e.target.getAttribute('data-geo-id'),
            placeName: e.target.getAttribute('data-place-name'),
            lat: e.target.getAttribute('data-lat'),
            lng: e.target.getAttribute('data-lng'),
            colorIndex: parseInt(e.target.getAttribute('data-color-index') || '0'),
            coordSource: e.target.getAttribute('data-coord-source')
          };
          console.log('[WebView] Geo-mark clicked, showing tool picker:', attrs);

          // Show tool picker for editing this geo-mark
          sendMessageToNative({
            type: 'showToolPicker',
            data: {
              selectedText: e.target.textContent || attrs.placeName,
              markType: 'location',
              isEditing: true,
              existingMarkAttrs: attrs
            }
          });
        }

        if (e.target.classList.contains('comment-mark')) {
          const repliesStr = e.target.getAttribute('data-replies');
          let replies = null;
          if (repliesStr) {
            try {
              replies = JSON.parse(repliesStr);
            } catch (err) {
              console.error('[WebView] Error parsing replies:', err);
            }
          }

          const attrs = {
            commentId: e.target.getAttribute('data-comment-id'),
            userId: e.target.getAttribute('data-user-id'),
            userName: e.target.getAttribute('data-user-name') || '',
            content: e.target.getAttribute('data-content') || '',
            createdAt: e.target.getAttribute('data-created-at'),
            resolved: e.target.getAttribute('data-resolved') === 'true',
            replies: replies
          };
          console.log('[WebView] Comment clicked, showing tool picker:', attrs);

          // Show tool picker for editing this comment
          sendMessageToNative({
            type: 'showToolPicker',
            data: {
              selectedText: e.target.textContent,
              markType: 'comment',
              isEditing: true,
              existingMarkAttrs: attrs
            }
          });
        }
      });

      // Send ready message
      sendMessageToNative({
        type: 'ready',
        message: 'ProseMirror editor initialized'
      });

      // Send initial toolbar state
      const initialToolbarState = getToolbarState();
      sendMessageToNative({
        type: 'toolbarStateChange',
        state: initialToolbarState
      });

      // Listen for iOS custom menu actions
      // iOS will trigger this when custom menu items are selected
      document.addEventListener('selectionchange', function() {
        console.log('[WebView] Selection changed via DOM');
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          const selectedText = selection.toString();
          console.log('[WebView] Selected text from DOM:', selectedText);
        }
      });

      // Intercept iOS UIMenuItem actions via a hidden input trick
      // When iOS menu items are clicked, we can detect it through focus/blur events
      let lastSelectedText = '';
      let pendingGeoMarkCreation = false;

      // Store selection when text is selected
      document.addEventListener('selectionchange', function() {
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          lastSelectedText = selection.toString();
          console.log('[WebView] Stored selected text:', lastSelectedText);
        }
      });

      // Create a global function that iOS can call
      window.createLocationFromSelection = function() {
        console.log('[WebView] createLocationFromSelection called!');
        const { state } = editorView;
        const { selection } = state;

        if (selection.empty) {
          console.warn('[WebView] No text selected');
          return;
        }

        const selectedText = state.doc.textBetween(
          selection.from,
          selection.to,
          ' '
        );

        console.log('[WebView] Creating location from iOS menu for:', selectedText);

        // Send request to show geo-mark editor
        sendMessageToNative({
          type: 'showGeoMarkEditor',
          data: {
            placeName: selectedText,
            from: selection.from,
            to: selection.to
          },
          existingLocations: []
        });
      };

      // Expose to window for iOS to call
      window.handleCreateLocation = window.createLocationFromSelection;

      // Y.js helper functions
      function setupYjsListeners() {
        if (!ydoc || !awareness) {
          console.error('[WebView] Cannot setup Y.js listeners - missing ydoc or awareness');
          return;
        }

        console.log('[WebView] Setting up Y.js listeners');

        // Forward Y.js updates to React Native
        ydoc.on('update', (update, origin) => {
          if (origin !== 'remote') {
            console.log('[WebView] Y.js update detected, forwarding to native');
            sendMessageToNative({
              type: 'yjsUpdate',
              update: Array.from(update)
            });
          }
        });

        // Forward awareness changes
        awareness.on('change', () => {
          const update = window.PM.awarenessProtocol.encodeAwarenessUpdate(
            awareness,
            Array.from(awareness.getStates().keys())
          );
          console.log('[WebView] Awareness update detected, forwarding to native');
          sendMessageToNative({
            type: 'awarenessUpdate',
            update: Array.from(update)
          });
        });

        console.log('[WebView] Y.js listeners setup complete');
      }

      function getRandomColor() {
        const colors = [
          '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',
          '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      // Listen for messages from React Native and native iOS menu
      window.addEventListener('message', function(event) {
        // Verbose logging removed - messages are frequent

        // Handle native iOS menu actions
        if (event.data && event.data.source === 'nativeMenu') {
          console.log('[WebView] Native menu action:', event.data.action);

          if (event.data.action === 'createLocation') {
            console.log('[WebView] Create location from native menu:', event.data.data.selectedText);
            // Trigger the create location function
            if (window.createLocationFromSelection) {
              window.createLocationFromSelection();
            }
            return;
          }

          if (event.data.action === 'addNote') {
            console.log('[WebView] Add note from native menu:', event.data.data.selectedText);
            // Handle add note action
            return;
          }
        }

        try {
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          switch (data.type) {
            case 'evalScript':
              console.log('[WebView] Executing script via postMessage');
              try {
                eval(data.script);
              } catch (evalError) {
                console.error('[WebView] Error executing script:', evalError);
              }
              break;

            case 'supabaseConfig':
              console.log('[WebView] Received Supabase config via postMessage');
              // Store config globally for use during collaboration
              window.__supabaseConfig = data.config;
              break;

            case 'setContent':
              console.log('[WebView] Setting content:', JSON.stringify(data.content));
              if (data.content && editorView) {
                try {
                  const doc = schema.nodeFromJSON(data.content);
                  console.log('[WebView] Created doc from JSON:', doc.toString());
                  console.log('[WebView] Doc content:', doc.content.toString());

                  // Check for headings in the document
                  let hasHeadings = false;
                  doc.descendants((node) => {
                    if (node.type.name === 'heading') {
                      console.log('[WebView] Found heading node, level:', node.attrs.level);
                      hasHeadings = true;
                    }
                  });
                  console.log('[WebView] Document has headings:', hasHeadings);

                  // Create new state with fresh plugins
                  const newState = EditorState.create({
                    doc: doc,
                    schema: schema,
                    plugins: createEditorPlugins()
                  });
                  editorView.updateState(newState);
                  editorState = newState;

                  // Send updated toolbar state after loading content
                  const toolbarState = getToolbarState();
                  sendMessageToNative({
                    type: 'toolbarStateChange',
                    state: toolbarState
                  });
                } catch (e) {
                  console.error('[WebView] Error creating doc from JSON:', e);
                  console.error('[WebView] Content was:', JSON.stringify(data.content));
                }
              }
              break;

            case 'setEditable':
              console.log('[WebView] Setting editable:', data.editable);
              if (editorView) {
                editorView.setProps({ editable: () => data.editable });
              }
              break;

            case 'getState':
              // Verbose logging removed - state requests are frequent
              if (editorView) {
                sendMessageToNative({
                  type: 'stateResponse',
                  state: editorView.state.doc.toJSON()
                });
              }
              break;

            case 'createGeoMarkFromRecent':
              console.log('[WebView] Creating geo-mark from recent text:', data.geoMarkData);
              if (editorView && data.geoMarkData && data.textLength) {
                const { state, dispatch } = editorView;
                // Select the recently typed text by going backwards from current position
                const currentPos = state.selection.to;
                const from = Math.max(0, currentPos - data.textLength);
                const to = currentPos;

                // Create selection
                const newSelection = TextSelection.create(state.doc, from, to);
                let tr = state.tr.setSelection(newSelection);
                dispatch(tr);

                // Now create the geo-mark with the selected text
                const selectedText = state.doc.textBetween(from, to, ' ');
                const geoMarkType = schema.marks.geoMark;
                if (!geoMarkType) {
                  console.error('[WebView] geoMark mark type not found in schema');
                  break;
                }

                const geoMarkMark = geoMarkType.create({
                  geoId: data.geoMarkData.geoId,
                  placeName: data.geoMarkData.placeName,
                  lat: data.geoMarkData.lat,
                  lng: data.geoMarkData.lng,
                  colorIndex: data.geoMarkData.colorIndex || 0,
                  coordSource: data.geoMarkData.coordSource || 'manual',
                  description: data.geoMarkData.description || null,
                  transportFrom: data.geoMarkData.transportFrom || null,
                  transportProfile: data.geoMarkData.transportProfile || null,
                  waypoints: data.geoMarkData.waypoints || null,
                  visitDocument: data.geoMarkData.visitDocument || null,
                  photoName: data.geoMarkData.photoName || null,
                });

                // Apply the mark to the selected text
                const tr2 = editorView.state.tr.addMark(from, to, geoMarkMark);
                dispatch(tr2);
                console.log('[WebView] Geo-mark created from recent text');
              }
              break;

            case 'createGeoMark':
              console.log('[WebView] Creating geo-mark with data:', data.geoMarkData);
              sendMessageToNative({
                type: 'debug',
                message: '[WebView DEBUG] Received createGeoMark message'
              });

              try {
                if (!editorView) {
                  throw new Error('editorView is null');
                }
                if (!data.geoMarkData) {
                  throw new Error('geoMarkData is missing');
                }
                console.log('[WebView] Step 1: editorView and geoMarkData validated');

                const { state, dispatch } = editorView;
                console.log('[WebView] Step 2: Got state and dispatch from editorView');

                const { selection } = state;
                const { from, to } = selection;
                console.log('[WebView] Step 3: Selection bounds:', { from, to });

                sendMessageToNative({
                  type: 'debug',
                  message: `[WebView DEBUG] Selection from ${from} to ${to}, selected text: "${state.doc.textBetween(from, to, ' ')}"`
                });

                // Create a geoMark MARK (not node) with the location data
                const geoMarkType = schema.marks.geoMark;
                if (!geoMarkType) {
                  throw new Error('geoMark mark type not found in schema');
                }
                console.log('[WebView] Step 4: geoMarkType found in schema (as mark)');

                // Get the selected text
                const selectedText = state.doc.textBetween(from, to, ' ');
                console.log('[WebView] Step 5: Selected text:', selectedText);

                // Create geoMark mark with all attributes
                const geoMarkMark = geoMarkType.create({
                  geoId: data.geoMarkData.geoId,
                  placeName: data.geoMarkData.placeName,
                  lat: data.geoMarkData.lat,
                  lng: data.geoMarkData.lng,
                  colorIndex: data.geoMarkData.colorIndex || 0,
                  coordSource: data.geoMarkData.coordSource || 'manual',
                  description: data.geoMarkData.description || null,
                  transportFrom: data.geoMarkData.transportFrom || null,
                  transportProfile: data.geoMarkData.transportProfile || null,
                  waypoints: data.geoMarkData.waypoints || null,
                  visitDocument: data.geoMarkData.visitDocument || null,
                  photoName: data.geoMarkData.photoName || null
                });
                console.log('[WebView] Step 6: geoMarkMark created:', geoMarkMark);

                // Apply the mark to the selected text
                const tr = state.tr.addMark(from, to, geoMarkMark);
                console.log('[WebView] Step 7: Transaction created (addMark)');

                dispatch(tr);
                console.log('[WebView] Step 8: Transaction dispatched');

                console.log('[WebView] Geo-mark MARK applied successfully');
                sendMessageToNative({
                  type: 'info',
                  message: 'Location created: ' + data.geoMarkData.placeName
                });
              } catch (error) {
                console.error('[WebView] ERROR in createGeoMark:', error);
                console.error('[WebView] Error stack:', error.stack);
                sendMessageToNative({
                  type: 'error',
                  message: `Failed to create geo-mark: ${error.message}`
                });
              }
              break;

            case 'command':
              console.log('[WebView] Executing command:', data.command, data.params);
              if (!editorView) {
                console.warn('[WebView] Editor view not available');
                break;
              }

              const { state, dispatch } = editorView;
              const { selection } = state;
              const { from, to } = selection;

              switch (data.command) {
                case 'setParagraph':
                  console.log('[WebView] Setting paragraph');
                  const paragraphTr = state.tr.setBlockType(from, to, schema.nodes.paragraph);
                  dispatch(paragraphTr);
                  editorView.focus();
                  break;

                case 'setHeading':
                  const level = data.params?.level || 1;
                  console.log('[WebView] Setting heading level:', level);
                  // Get the current cursor position
                  const cursorPos = state.selection.$from.pos;
                  // Find the bounds of the current block (paragraph)
                  const $pos = state.doc.resolve(cursorPos);
                  const blockStart = $pos.before($pos.depth);
                  const blockEnd = $pos.after($pos.depth);
                  // Only set heading for the current block
                  const headingTr = state.tr.setBlockType(blockStart, blockEnd, schema.nodes.heading, { level });
                  dispatch(headingTr);
                  console.log('[WebView] Set heading from', blockStart, 'to', blockEnd);
                  editorView.focus();
                  break;

                case 'toggleBold':
                  console.log('[WebView] Toggling bold');
                  if (schema.marks.strong) {
                    const hasBold = state.doc.rangeHasMark(from, to, schema.marks.strong);
                    if (hasBold) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.strong));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.strong.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'toggleItalic':
                  console.log('[WebView] Toggling italic');
                  if (schema.marks.em) {
                    const hasItalic = state.doc.rangeHasMark(from, to, schema.marks.em);
                    if (hasItalic) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.em));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.em.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'undo':
                  console.log('[WebView] Undo');
                  window.PM.history.undo(state, dispatch);
                  editorView.focus();
                  break;

                case 'redo':
                  console.log('[WebView] Redo');
                  window.PM.history.redo(state, dispatch);
                  editorView.focus();
                  break;

                case 'createGeoMark':
                  // Check if there's selected text
                  if (selection.empty) {
                    console.warn('[WebView] No text selected for geo-mark');
                    sendMessageToNative({
                      type: 'error',
                      message: 'Please select text to create a location'
                    });
                    break;
                  }

                  // Get selected text
                  const selectedText = state.doc.textBetween(from, to, ' ');
                  console.log('[WebView] Selected text:', selectedText);

                  // Check if geoMarkData is provided (for animation mode)
                  if (data.params && data.params.geoMarkData) {
                    console.log('[WebView] Animation mode: Creating geo-mark directly with data:', data.params.geoMarkData);
                    try {
                      const geoMarkType = schema.marks.geoMark;
                      if (!geoMarkType) {
                        throw new Error('geoMark mark type not found in schema');
                      }
                      console.log('[WebView] Step 1: geoMarkType found in schema');

                      // Create geoMark MARK with all attributes
                      const geoMarkMark = geoMarkType.create({
                        geoId: data.params.geoMarkData.geoId,
                        placeName: data.params.geoMarkData.placeName,
                        lat: data.params.geoMarkData.lat,
                        lng: data.params.geoMarkData.lng,
                        colorIndex: data.params.geoMarkData.colorIndex || 0,
                        coordSource: data.params.geoMarkData.coordSource || 'manual',
                        description: data.params.geoMarkData.description || null,
                        transportFrom: data.params.geoMarkData.transportFrom || null,
                        transportProfile: data.params.geoMarkData.transportProfile || null,
                        waypoints: data.params.geoMarkData.waypoints || null,
                        visitDocument: data.params.geoMarkData.visitDocument || null,
                        photoName: data.params.geoMarkData.photoName || null
                      });
                      console.log('[WebView] Step 2: geoMarkMark created');

                      // Apply the mark to the selected text
                      const tr = state.tr.addMark(from, to, geoMarkMark);
                      console.log('[WebView] Step 3: Transaction created');

                      dispatch(tr);
                      console.log('[WebView] Step 4: Transaction dispatched');

                      console.log('[WebView] Geo-mark MARK created successfully!');
                      sendMessageToNative({
                        type: 'info',
                        message: 'Location created: ' + data.params.geoMarkData.placeName
                      });
                    } catch (error) {
                      console.error('[WebView] ERROR creating geo-mark:', error);
                      console.error('[WebView] Error stack:', error.stack);
                      sendMessageToNative({
                        type: 'error',
                        message: `Failed to create geo-mark: ${error.message}`
                      });
                    }
                    break;
                  }

                  // Interactive mode: Send request to show geo-mark editor
                  // Calculate selection's position relative to editor container
                  let selectionTop = 200; // Default fallback
                  let selectionLeft = 0; // Default fallback
                  let selectionWidth = 0; // Default fallback
                  try {
                    const coordsStart = editorView.coordsAtPos(from);
                    const coordsEnd = editorView.coordsAtPos(to);
                    const editorContainer = document.querySelector('#editor-container');
                    const editorRect = editorContainer.getBoundingClientRect();
                    // Calculate the exact midpoint between top and bottom coordinates
                    const midpointY = (coordsStart.top + coordsStart.bottom) / 2;
                    // coordsAtPos returns absolute coordinates, just subtract container position (not padding!)
                    selectionTop = midpointY - editorRect.top;
                    selectionLeft = coordsStart.left - editorRect.left;
                    selectionWidth = coordsEnd.right - coordsStart.left; // Width of the selection
                    console.log('[WebView] Selection position (adjusted for padding):', {
                      selectionTop,
                      selectionLeft,
                      selectionWidth,
                      coordsTop: coordsStart.top,
                      coordsBottom: coordsStart.bottom,
                      midpointY: midpointY,
                      editorRectTop: editorRect.top,
                      adjustedForPadding: true
                    });
                  } catch (e) {
                    console.warn('[WebView] Could not get selection coordinates:', e);
                  }

                  sendMessageToNative({
                    type: 'showGeoMarkEditor',
                    data: {
                      selectedText: selectedText,
                      placeName: selectedText,
                      from: selection.from,
                      to: selection.to,
                      selectionTop: selectionTop,
                      selectionLeft: selectionLeft,
                      selectionWidth: selectionWidth
                    },
                    existingLocations: []
                  });
                  break;

                case 'updateGeoMarkWaypoints':
                  // Update a geo-mark's waypoints attribute
                  console.log('[WebView] Updating geo-mark waypoints:', data.params?.geoId, data.params?.waypoints);
                  if (data.params?.geoId && data.params?.waypoints && schema.marks.geoMark) {
                    let geoMarkFound = false;
                    const updateTr = state.tr;

                    // Find all geo-marks and update the one with matching geoId
                    state.doc.nodesBetween(0, state.doc.content.size, (node, pos) => {
                      if (node.marks && node.marks.length > 0) {
                        const geoMark = node.marks.find(m => m.type === schema.marks.geoMark && m.attrs.geoId === data.params.geoId);
                        if (geoMark) {
                          console.log('[WebView] Found geo-mark to update at pos:', pos);
                          // Create updated mark with new waypoints
                          const updatedMark = schema.marks.geoMark.create({
                            ...geoMark.attrs,
                            waypoints: data.params.waypoints
                          });
                          // Remove old mark and add updated one
                          updateTr.removeMark(pos, pos + node.nodeSize, geoMark);
                          updateTr.addMark(pos, pos + node.nodeSize, updatedMark);
                          geoMarkFound = true;
                        }
                      }
                    });

                    if (geoMarkFound) {
                      dispatch(updateTr);
                      console.log('[WebView] Geo-mark waypoints updated successfully');
                      sendMessageToNative({
                        type: 'documentChanged',
                        content: editorView.state.doc.toJSON()
                      });
                    } else {
                      console.warn('[WebView] Geo-mark with ID not found:', data.params.geoId);
                    }
                  }
                  break;

                case 'updateGeoMark':
                  // Update all attributes of a geo-mark
                  console.log('[WebView] Updating geo-mark:', data.params?.geoId);
                  if (data.params?.geoId && data.params?.updatedAttrs && schema.marks.geoMark) {
                    let geoMarkFound = false;
                    const updateFullTr = state.tr;

                    // Find all geo-marks and update the one with matching geoId
                    state.doc.nodesBetween(0, state.doc.content.size, (node, pos) => {
                      if (node.marks && node.marks.length > 0) {
                        const geoMark = node.marks.find(m => m.type === schema.marks.geoMark && m.attrs.geoId === data.params.geoId);
                        if (geoMark) {
                          console.log('[WebView] Found geo-mark to update at pos:', pos);
                          // Create updated mark with all new attributes
                          const updatedMark = schema.marks.geoMark.create({
                            ...geoMark.attrs,
                            ...data.params.updatedAttrs
                          });
                          // Remove old mark and add updated one
                          updateFullTr.removeMark(pos, pos + node.nodeSize, geoMark);
                          updateFullTr.addMark(pos, pos + node.nodeSize, updatedMark);
                          geoMarkFound = true;
                        }
                      }
                    });

                    if (geoMarkFound) {
                      dispatch(updateFullTr);
                      console.log('[WebView] Geo-mark updated successfully');
                      sendMessageToNative({
                        type: 'documentChanged',
                        content: editorView.state.doc.toJSON()
                      });
                    } else {
                      console.warn('[WebView] Geo-mark with ID not found for update:', data.params.geoId);
                    }
                  }
                  break;

                case 'addComment':
                  // Check if there's selected text
                  if (selection.empty) {
                    console.warn('[WebView] No text selected for comment');
                    sendMessageToNative({
                      type: 'error',
                      message: 'Please select text to add a comment'
                    });
                    break;
                  }

                  // Get selected text
                  const commentSelectedText = state.doc.textBetween(from, to, ' ');
                  console.log('[WebView] Selected text for comment:', commentSelectedText);

                  // Send request to show comment editor
                  sendMessageToNative({
                    type: 'showCommentEditor',
                    data: {
                      selectedText: commentSelectedText,
                      from: selection.from,
                      to: selection.to
                    }
                  });
                  break;

                case 'insertMap':
                  console.log('[WebView] Inserting map');
                  if (schema.nodes.map) {
                    // Get the current cursor position
                    const mapPos = state.selection.$from.pos;
                    // Find the position after the current block
                    const $pos = state.doc.resolve(mapPos);
                    const insertPos = $pos.after($pos.depth);

                    // Create map node
                    const mapNode = schema.nodes.map.create({ height: 400 });

                    // Insert map node
                    const mapTr = state.tr.insert(insertPos, mapNode);
                    dispatch(mapTr);

                    console.log('[WebView] Map inserted at position:', insertPos);
                    editorView.focus();

                    // Notify native side that document changed
                    sendMessageToNative({
                      type: 'documentChanged',
                      content: editorView.state.doc.toJSON()
                    });
                  } else {
                    console.error('[WebView] Map node type not found in schema');
                  }
                  break;

                case 'createComment':
                  // Create a comment mark with the provided data
                  if (data.params && schema.marks.comment) {
                    const commentMark = schema.marks.comment.create({
                      commentId: data.params.commentId,
                      userId: data.params.userId,
                      userName: data.params.userName,
                      content: data.params.content,
                      createdAt: data.params.createdAt,
                      resolved: data.params.resolved || false,
                      replies: data.params.replies || null
                    });

                    const commentTr = state.tr.addMark(
                      data.params.from || from,
                      data.params.to || to,
                      commentMark
                    );
                    dispatch(commentTr);
                    console.log('[WebView] Comment created successfully');
                    editorView.focus();
                  }
                  break;


                case 'updateCommentAIReply':
                  // Update a comment mark's aiReply attribute
                  console.log('[WebView] Updating comment AI reply:', data.commentId);
                  if (data.commentId && data.aiReplyDoc && schema.marks.comment) {
                    let commentFound = false;
                    const updateTr = state.tr;

                    // Find all comment marks in the document
                    state.doc.descendants((node, pos) => {
                      if (!node.isText) return;

                      // Check if this text node has a comment mark with matching ID
                      const commentMark = node.marks.find(
                        mark => mark.type.name === 'comment' && mark.attrs.commentId === data.commentId
                      );

                      if (commentMark) {
                        commentFound = true;
                        const nodeStart = pos;
                        const nodeEnd = pos + node.nodeSize;

                        console.log('[WebView] Found comment mark at', nodeStart, '-', nodeEnd);

                        // Create updated comment mark with aiReply
                        const updatedCommentMark = schema.marks.comment.create({
                          ...commentMark.attrs,
                          aiReply: data.aiReplyDoc
                        });

                        // Remove old mark and add updated one
                        updateTr.removeMark(nodeStart, nodeEnd, commentMark);
                        updateTr.addMark(nodeStart, nodeEnd, updatedCommentMark);

                        console.log('[WebView] Updated comment with AI reply');
                      }
                    });

                    if (commentFound) {
                      dispatch(updateTr);
                      console.log('[WebView] Comment AI reply updated successfully');
                      sendMessageToNative({
                        type: 'info',
                        message: 'AI reply received'
                      });
                    } else {
                      console.warn('[WebView] Comment not found:', data.commentId);
                    }
                  }
                  break;

                case 'focusEditor':
                  console.log('[WebView] Focusing editor');
                  // Focus the editor
                  editorView.focus();
                  // Move cursor to end of document
                  const endPos = state.doc.content.size;
                  const focusTr = state.tr.setSelection(
                    window.PM.state.Selection.near(state.doc.resolve(endPos))
                  );
                  dispatch(focusTr);
                  console.log('[WebView] Editor focused, cursor at end');
                  break;

                case 'insertText':
                  console.log('[WebView] Typing text via input:', data.params?.text);
                  // Use direct insertion - ProseMirror handles this correctly
                  const text = data.params?.text || '';

                  if (editorView) {
                    // Just insert the text directly - this is the most reliable method
                    const insertTextTr = editorView.state.tr.insertText(text);
                    editorView.dispatch(insertTextTr);
                    console.log('[WebView] Inserted text:', text);
                  }
                  break;

                case 'insertParagraph':
                  console.log('[WebView] Inserting paragraph');
                  // Split the current block and reset to paragraph
                  let paraTr = state.tr.split(state.selection.to);
                  // After split, set the new block to paragraph (not heading)
                  const newPos = paraTr.selection.$from.pos;
                  const $newPos = paraTr.doc.resolve(newPos);
                  const newBlockStart = $newPos.before($newPos.depth);
                  const newBlockEnd = $newPos.after($newPos.depth);
                  paraTr = paraTr.setBlockType(newBlockStart, newBlockEnd, schema.nodes.paragraph);
                  dispatch(paraTr);
                  console.log('[WebView] Paragraph split/inserted and reset to paragraph type');
                  break;

                case 'setMapboxToken':
                  console.log('[WebView] Received Mapbox token');
                  // Store token globally for use in location map
                  window.__mapboxToken = data.params?.token;
                  break;

                case 'selectText':
                  console.log('[WebView] Selecting text backwards:', data.params?.count);
                  // Animate selection by updating both ProseMirror AND native DOM selection
                  try {
                    const count = data.params?.count || 0;
                    // Get CURRENT cursor position from the latest editor state
                    const currentPos = editorView.state.selection.to;
                    const finalStartPos = Math.max(0, currentPos - count);

                    console.log('[WebView] Selection positions - current:', currentPos, 'final start:', finalStartPos, 'count:', count);

                    // Focus editor
                    if (editorView && editorView.dom) {
                      editorView.focus();
                    }

                    // Animate selection character by character
                    let currentStep = 0;
                    const animateSelection = () => {
                      if (!editorView) return;

                      currentStep++;
                      const startPos = Math.max(finalStartPos, currentPos - currentStep);

                      // Update ProseMirror selection
                      const selectTr = editorView.state.tr.setSelection(
                        window.PM.state.TextSelection.create(editorView.state.doc, startPos, currentPos)
                      );
                      editorView.dispatch(selectTr);

                      // ALSO update native DOM selection for visual feedback
                      try {
                        const domSelection = window.getSelection();
                        if (domSelection) {
                          const startDOM = editorView.domAtPos(startPos);
                          const endDOM = editorView.domAtPos(currentPos);

                          if (startDOM && endDOM) {
                            const range = document.createRange();
                            range.setStart(startDOM.node, startDOM.offset);
                            range.setEnd(endDOM.node, endDOM.offset);
                            domSelection.removeAllRanges();
                            domSelection.addRange(range);
                            console.log('[WebView] Updated DOM selection:', startPos, 'to', currentPos);
                          }
                        }
                      } catch (domError) {
                        console.warn('[WebView] Could not update DOM selection:', domError);
                      }

                      console.log('[WebView] Selection step', currentStep, ':', startPos, 'to', currentPos);

                      // Continue animation if not done
                      if (currentStep < count) {
                        setTimeout(animateSelection, 150); // 150ms per character
                      } else {
                        console.log('[WebView] Selection animation complete from', finalStartPos, 'to', currentPos);
                      }
                    };

                    animateSelection();
                  } catch (error) {
                    console.error('[WebView] Error selecting text:', error);
                  }
                  break;

                case 'selectBackward':
                  console.log('[WebView] Selecting backward:', data.params?.length);
                  sendMessageToNative({
                    type: 'debug',
                    message: `[WebView DEBUG] selectBackward command received, length: ${data.params?.length}`
                  });

                  try {
                    // Select text backwards from cursor by the specified length
                    const length = data.params?.length || 0;
                    const currentPos = state.selection.to;
                    const startPos = Math.max(0, currentPos - length);

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] Before selection: currentPos=${currentPos}, will select from ${startPos} to ${currentPos}`
                    });

                    const selectTr = state.tr.setSelection(
                      window.PM.state.TextSelection.create(state.doc, startPos, currentPos)
                    );

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] Created selection transaction, about to dispatch`
                    });

                    dispatch(selectTr);

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] After selection dispatch: from ${startPos} to ${currentPos}`
                    });
                  } catch (error) {
                    sendMessageToNative({
                      type: 'error',
                      message: `[WebView ERROR] selectBackward failed: ${error.message}`
                    });
                  }
                  break;

                case 'selectRange':
                  console.log('[WebView] Selecting range:', data.params?.from, 'to', data.params?.to);
                  try {
                    const rangeFrom = data.params?.from || 0;
                    const rangeTo = data.params?.to || 0;

                    // Create selection for the specified range
                    const rangeTr = state.tr.setSelection(
                      window.PM.state.TextSelection.create(state.doc, rangeFrom, rangeTo)
                    );
                    dispatch(rangeTr);
                    console.log('[WebView] Range selected from', rangeFrom, 'to', rangeTo);
                  } catch (error) {
                    console.error('[WebView] selectRange failed:', error);
                  }
                  break;

                case 'deleteSelection':
                  console.log('[WebView] Deleting selection');
                  try {
                    // Delete the current selection
                    const deleteTr = state.tr.deleteSelection();
                    dispatch(deleteTr);
                    console.log('[WebView] Selection deleted');
                  } catch (error) {
                    console.error('[WebView] deleteSelection failed:', error);
                  }
                  break;

                case 'showTypingCursor':
                  console.log('[WebView] Showing typing cursor');
                  showTypingCursor();
                  break;

                case 'hideTypingCursor':
                  console.log('[WebView] Hiding typing cursor');
                  hideTypingCursor();
                  break;

                default:
                  console.warn('[WebView] Unknown command:', data.command);
              }
              break;

            case 'replaceDraftWithDocument':
              console.log('[WebView] Replacing draft content with structured document');
              if (editorView && data.document) {
                try {
                  const { state, dispatch } = editorView;

                  // Find all text with draft marks
                  let draftStart = null;
                  let draftEnd = null;
                  state.doc.descendants((node, pos) => {
                    if (node.isText && node.marks.some(m => m.type.name === 'draft')) {
                      if (draftStart === null) {
                        draftStart = pos;
                      }
                      draftEnd = pos + node.nodeSize;
                    }
                  });

                  if (draftStart === null || draftEnd === null) {
                    console.warn('[WebView] No draft text found to replace');
                    break;
                  }

                  console.log('[WebView] Found draft text from', draftStart, 'to', draftEnd);

                  // Parse the new document content
                  const newContent = schema.nodeFromJSON(data.document);
                  console.log('[WebView] Parsed new document:', newContent.toString());

                  // Create transaction to replace draft text with new content
                  let tr = state.tr;

                  // Delete draft text
                  tr = tr.delete(draftStart, draftEnd);

                  // Insert new content at the same position
                  // Extract the content from the document node (skip the doc wrapper)
                  const contentToInsert = newContent.content;
                  tr = tr.insert(draftStart, contentToInsert);

                  // Dispatch the transaction
                  dispatch(tr);

                  console.log('[WebView] Draft content replaced with structured document');

                  // Hide draft control buttons
                  updateDraftButtonVisibility();

                  // Notify React Native
                  sendMessageToNative({
                    type: 'draftReplaced',
                    success: true
                  });
                } catch (error) {
                  console.error('[WebView] Error replacing draft content:', error);
                  sendMessageToNative({
                    type: 'draftReplaced',
                    success: false,
                    error: error.message
                  });
                }
              }
              break;

            case 'replaceDraftWithHTML':
              console.log('[WebView] Replacing draft content with HTML snippet');
              sendMessageToNative({
                type: 'debug',
                message: 'replaceDraftWithHTML handler called'
              });

              if (editorView && data.html) {
                try {
                  const { state, dispatch } = editorView;

                  sendMessageToNative({
                    type: 'debug',
                    message: 'ðŸ”µ NEW CODE v13:36 - About to get schema from state'
                  });

                  const schema = state.schema;  // Get schema from editor state

                  sendMessageToNative({
                    type: 'debug',
                    message: 'ðŸŸ¢ NEW CODE v13:36 - Schema obtained: ' + (schema ? 'SUCCESS' : 'FAILED')
                  });

                  sendMessageToNative({
                    type: 'debug',
                    message: 'ðŸ” Schema nodes available: ' + Object.keys(schema.nodes).join(', ')
                  });

                  sendMessageToNative({
                    type: 'debug',
                    message: 'ðŸ“ schema.nodes.geoMark exists? ' + (schema.nodes.geoMark ? 'YES' : 'NO')
                  });

                  sendMessageToNative({
                    type: 'debug',
                    message: 'EditorView exists, processing HTML: ' + data.html.substring(0, 100)
                  });

                  // Find all text with draft marks
                  let draftStart = null;
                  let draftEnd = null;
                  state.doc.descendants((node, pos) => {
                    if (node.isText && node.marks.some(m => m.type.name === 'draft')) {
                      if (draftStart === null) {
                        draftStart = pos;
                      }
                      draftEnd = pos + node.nodeSize;
                    }
                  });

                  if (draftStart === null || draftEnd === null) {
                    console.warn('[WebView] No draft text found to replace');
                    sendMessageToNative({
                      type: 'debug',
                      message: 'No draft text found to replace'
                    });
                    break;
                  }

                  console.log('[WebView] Found draft text from', draftStart, 'to', draftEnd);
                  console.log('[WebView] HTML to insert:', data.html);
                  sendMessageToNative({
                    type: 'debug',
                    message: `Found draft text from ${draftStart} to ${draftEnd}`
                  });

                  // Parse HTML using DOMParser
                  const parser = new DOMParser();
                  const doc = parser.parseFromString(data.html, 'text/html');

                  // Convert geo-mark spans to ProseMirror text with marks
                  const fragment = [];
                  const walk = (node) => {
                    if (node.nodeType === Node.TEXT_NODE) {
                      if (node.textContent) {
                        fragment.push(schema.text(node.textContent));
                      }
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                      if (node.classList.contains('geo-mark')) {
                        // Parse geo-mark attributes
                        const attrs = {
                          geoId: node.getAttribute('data-geo-id'),
                          placeName: node.getAttribute('data-place-name'),
                          lat: parseFloat(node.getAttribute('data-lat')),
                          lng: parseFloat(node.getAttribute('data-lng')),
                          colorIndex: parseInt(node.getAttribute('data-color-index')),
                          coordSource: node.getAttribute('data-coord-source') || 'nominatim'
                        };

                        // Add transport info if present
                        if (node.getAttribute('data-transport-from')) {
                          attrs.transportFrom = node.getAttribute('data-transport-from');
                        }
                        if (node.getAttribute('data-transport-profile')) {
                          attrs.transportProfile = node.getAttribute('data-transport-profile');
                        }

                        // Create text node with geoMark mark applied
                        const textContent = node.textContent || attrs.placeName;
                        const geoMarkMark = schema.marks.geoMark.create(attrs);
                        const textNode = schema.text(textContent, [geoMarkMark]);
                        fragment.push(textNode);
                      } else {
                        // Regular element, walk its children
                        for (const child of node.childNodes) {
                          walk(child);
                        }
                      }
                    }
                  };

                  // Walk the parsed HTML body
                  for (const child of doc.body.childNodes) {
                    walk(child);
                  }

                  console.log('[WebView] Converted HTML to', fragment.length, 'nodes');
                  sendMessageToNative({
                    type: 'debug',
                    message: `Converted HTML to ${fragment.length} nodes`
                  });

                  // Create transaction to replace draft text
                  let tr = state.tr;
                  tr = tr.delete(draftStart, draftEnd);

                  // Insert each fragment node
                  let insertPos = draftStart;
                  for (const node of fragment) {
                    tr = tr.insert(insertPos, node);
                    insertPos += node.nodeSize;
                  }

                  // Dispatch the transaction
                  dispatch(tr);

                  console.log('[WebView] Draft content replaced with HTML snippet');
                  sendMessageToNative({
                    type: 'debug',
                    message: 'Draft content replaced with HTML snippet successfully'
                  });

                  // Hide draft control buttons
                  updateDraftButtonVisibility();

                  // Notify React Native
                  sendMessageToNative({
                    type: 'draftReplaced',
                    success: true
                  });
                } catch (error) {
                  console.error('[WebView] Error replacing draft with HTML:', error);
                  sendMessageToNative({
                    type: 'debug',
                    message: 'Error replacing draft: ' + error.message
                  });
                  sendMessageToNative({
                    type: 'draftReplaced',
                    success: false,
                    error: error.message
                  });
                }
              } else {
                sendMessageToNative({
                  type: 'debug',
                  message: 'replaceDraftWithHTML: editorView=' + !!editorView + ', html=' + !!data.html
                });
              }
              break;

            case 'startCollaboration':
              console.log('[WebView] Starting Y.js collaboration:', data);

              if (!editorView) {
                console.error('[WebView] Cannot start collaboration - editor not ready');
                sendMessageToNative({
                  type: 'collaborationStarted',
                  success: false,
                  error: 'Editor not ready'
                });
                break;
              }

              if (!window.PM.Y || !window.PM.yProsemirror) {
                console.error('[WebView] Cannot start collaboration - Y.js not loaded');
                sendMessageToNative({
                  type: 'collaborationStarted',
                  success: false,
                  error: 'Y.js not loaded'
                });
                break;
              }

              (async () => {
                try {
                  // Connect to Tiptap Cloud or standalone Hocuspocus server
                  const { documentId, userId, userName, token, serverUrl, hocuspocusUrl } = data;

                  // Determine which URL to use (serverUrl takes priority)
                  let wsUrl = serverUrl || hocuspocusUrl || 'ws://127.0.0.1:1234/collaboration';

                  console.log('[WebView] Starting Y.js collaboration for document:', documentId);
                  console.log('[WebView] serverUrl:', serverUrl);
                  console.log('[WebView] hocuspocusUrl:', hocuspocusUrl);
                  console.log('[WebView] WebSocket URL (raw):', wsUrl);
                  console.log('[WebView] Auth token:', token ? 'present' : 'missing');

                  if (!token) {
                    throw new Error('Authentication required - no token provided');
                  }

                  // Get YProvider from bundled modules (y-partyserver)
                  if (!window.PM.YProvider) {
                    throw new Error('YProvider not available in bundle');
                  }
                  const YProvider = window.PM.YProvider;
                  console.log('[WebView] Using YProvider from y-partyserver for PartyKit/Cloudflare Workers');

                  // Create Y.Doc and fragment
                  ydoc = new window.PM.Y.Doc();
                  yXmlFragment = ydoc.getXmlFragment('prosemirror');
                  awareness = new window.PM.Awareness(ydoc);

                  // Set local awareness state
                  awareness.setLocalStateField('user', {
                    id: userId,
                    name: userName,
                    color: getRandomColor()
                  });

                  console.log('[WebView] Y.Doc created with clientID:', ydoc.clientID);

                  // LOCAL-FIRST: Load initial state from AsyncStorage if provided
                  // BUT: Only apply if we have local state AND we're not about to sync from server
                  // The Hocuspocus provider will merge any server state automatically via CRDT
                  if (data.yjsState) {
                    console.log('[WebView] ðŸ“¥ Loading Y.js state from AsyncStorage');
                    try {
                      // Decode base64 to Uint8Array
                      const binaryString = atob(data.yjsState);
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }

                      // Apply the state to our Y.Doc BEFORE connecting to Hocuspocus
                      // This ensures local edits are preserved when merging with server state
                      window.PM.Y.applyUpdate(ydoc, bytes);
                      console.log('[WebView] âœ… Y.js state loaded successfully. YXmlFragment length:', yXmlFragment.length);
                    } catch (error) {
                      console.error('[WebView] âŒ Failed to load Y.js state:', error);
                    }
                  } else {
                    console.log('[WebView] No local Y.js state to load - will sync from server');
                  }

                  // PRESERVE CURRENT DOCUMENT CONTENT
                  // If the user has edited the document before enabling collaboration,
                  // we need to transfer that content to the Y.js CRDT structure.
                  // This prevents data loss when switching from local-only to collaborative mode.
                  if (editorView && editorView.state.doc) {
                    const currentDoc = editorView.state.doc;
                    const currentDocJSON = JSON.stringify(currentDoc.toJSON());

                    // Get the Y.js document content (if any)
                    let yjsDocJSON = '{}';
                    if (yXmlFragment.length > 0) {
                      try {
                        // Convert Y.js fragment to ProseMirror and then to JSON for comparison
                        const yjsDoc = window.PM.yProsemirror.yXmlFragmentToProsemirrorJSON(yXmlFragment, schema);
                        yjsDocJSON = JSON.stringify(yjsDoc);
                      } catch (e) {
                        console.warn('[WebView] Could not convert Y.js to JSON for comparison:', e);
                      }
                    }

                    // Only preserve if the current editor content differs from Y.js content
                    const contentDiffers = currentDocJSON !== yjsDocJSON;
                    const yjsIsEmpty = yXmlFragment.length === 0;
                    const editorHasContent = currentDoc.content.childCount > 0;

                    console.log('[WebView] Content comparison:', {
                      yjsIsEmpty,
                      editorHasContent,
                      contentDiffers,
                      currentDocLength: currentDocJSON.length,
                      yjsDocLength: yjsDocJSON.length
                    });

                    if (yjsIsEmpty && editorHasContent) {
                      // Y.js is empty, editor has content â†’ Preserve editor content
                      console.log('[WebView] ðŸ“‹ Y.js empty, preserving editor content into Y.js');
                      if (window.PM.yProsemirror && window.PM.yProsemirror.prosemirrorToYXmlFragment) {
                        window.PM.yProsemirror.prosemirrorToYXmlFragment(currentDoc, yXmlFragment);
                        console.log('[WebView] âœ… Editor content preserved to Y.js');
                      } else {
                        console.error('[WebView] âŒ prosemirrorToYXmlFragment not available');
                      }
                    } else if (!yjsIsEmpty && editorHasContent && contentDiffers) {
                      // Both have content but different â†’ Y.js wins (loaded from storage or server)
                      console.log('[WebView] âš ï¸  Y.js and editor both have content but differ - Y.js takes precedence');
                    } else if (!yjsIsEmpty) {
                      // Y.js has content (same or different) â†’ Use Y.js
                      console.log('[WebView] âœ… Y.js has content - will use Y.js state');
                    } else {
                      // Both empty
                      console.log('[WebView] â„¹ï¸  Both Y.js and editor are empty - starting fresh');
                    }
                  }

                  // LOCAL-FIRST: Monitor Y.Doc updates and persist to AsyncStorage (debounced)
                  let saveTimeout = null;
                  ydoc.on('update', (update, origin) => {
                    // Debounce saves to AsyncStorage (every 2 seconds)
                    if (saveTimeout) clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                      // Check if document has content
                      const docSize = yXmlFragment.length;
                      if (docSize === 0) return;

                      const state = window.PM.Y.encodeStateAsUpdate(ydoc);
                      const base64State = btoa(String.fromCharCode(...new Uint8Array(state)));
                      console.log('[WebView] Saving Y.js state:', state.byteLength, 'bytes');
                      sendMessageToNative({
                        type: 'saveYjsState',
                        state: base64State
                      });
                    }, 2000);
                  });

                  // Create PartyKit provider for Cloudflare Workers
                  console.log('[WebView] Connecting to PartyKit server...');

                  // Extract host from WebSocket URL (WITHOUT protocol)
                  // YProvider expects just the hostname, not wss:// or ws://
                  // Handle formats: "wss://host", "ws://host", or just "host"
                  let host;
                  const wsMatch = wsUrl.match(/^wss?:\/\/([^\/]+)/);
                  if (wsMatch) {
                    host = wsMatch[1];  // Extract just the host: "tourvision-collab.workers.dev"
                  } else {
                    // If no protocol, assume it's just the host
                    host = wsUrl.split('/')[0];
                  }

                  console.log('[WebView] Raw URL:', wsUrl);
                  console.log('[WebView] Extracted host (no protocol):', host);
                  console.log('[WebView] Room (documentId):', documentId);

                  // Create YProvider from y-partyserver
                  // Uses standard PartyKit routing: /parties/:party/:room
                  // Our Durable Object binding is "YJS_ROOM" which becomes "yjs-room" in kebab-case
                  yProvider = new YProvider(
                    host,  // e.g., "tourvision-collab.workers.dev"
                    documentId,  // Room name (document ID)
                    ydoc,
                    {
                      party: "yjs-room",  // Durable Object binding name (kebab-case of "YJS_ROOM")
                      params: { token: token },  // Pass token as query parameter
                      awareness: awareness,
                      connect: true
                    }
                  );

                  // Listen to connection events
                  yProvider.on('status', ({ status }) => {
                    console.log('[WebView] ðŸ“¡ WebSocket status:', status);
                    if (status === 'connected') {
                      console.log('[WebView] âœ… WebSocket connected successfully');
                    } else if (status === 'disconnected') {
                      console.log('[WebView] âŒ WebSocket disconnected');
                    }
                  });

                  yProvider.on('sync', (synced) => {
                    if (synced) {
                      console.log('[WebView] âœ… Document synced with server');
                      // NOTE: We don't send stateResponse here anymore
                      // The Y.Doc update observer will handle persistence to AsyncStorage
                    }
                  });

                  console.log('[WebView] PartyKit provider created and connecting...');

                  // Recreate editor with Y.js plugins
                  // NOTE: Do NOT pass a doc parameter - ySyncPlugin will create the doc from YXmlFragment
                  const newState = EditorState.create({
                    schema: schema,
                    plugins: [
                      window.PM.yProsemirror.ySyncPlugin(yXmlFragment),
                      window.PM.yProsemirror.yCursorPlugin(awareness),
                      window.PM.yProsemirror.yUndoPlugin(),
                      window.PM.keymap({ 'Mod-z': window.PM.history.undo, 'Mod-y': window.PM.history.redo }),
                      // Custom Enter key handler for tool picker (must be before baseKeymap to override)
                      window.PM.keymap({
                        'Enter': (state, dispatch, view) => {
                          return createEnterKeyHandler(view)(state, dispatch);
                        }
                      }),
                      window.PM.keymap(window.PM.commands.baseKeymap)
                    ]
                  });

                  editorView.updateState(newState);
                  console.log('[WebView] Y.js collaboration started');

                  // Update UI
                  const statusEl = document.getElementById('collab-status');
                  if (statusEl) {
                    statusEl.textContent = 'Connected (Y.js)';
                    statusEl.className = 'connected';
                  }

                  // Notify React Native
                  sendMessageToNative({
                    type: 'collaborationStarted',
                    success: true,
                    clientId: ydoc.clientID
                  });

                  console.log('[WebView] Y.js collaboration started successfully');
                } catch (error) {
                  console.error('[WebView] Failed to start Y.js collaboration:', error);
                  sendMessageToNative({
                    type: 'collaborationStarted',
                    success: false,
                    error: error.message
                  });
                }
              })();
              break;

            case 'stopCollaboration':
              console.log('[WebView] Stopping Y.js collaboration');

              (async () => {
                try {
                  // Destroy Hocuspocus provider
                  if (yProvider) {
                    yProvider.destroy();
                    yProvider = null;
                    console.log('[WebView] Hocuspocus provider destroyed');
                  }

                  // Clean up Y.js resources
                  if (ydoc) {
                    ydoc.destroy();
                    ydoc = null;
                    yXmlFragment = null;
                    awareness = null;
                    console.log('[WebView] Y.js resources cleaned up');
                  }

                  // Remove Y.js plugins and restore editor with basic plugins
                  if (editorView) {
                    const currentDoc = editorView.state.doc;
                    const newState = EditorState.create({
                      schema: schema,
                      doc: currentDoc,
                      plugins: createEditorPlugins()
                    });
                    editorView.updateState(newState);
                    console.log('[WebView] Editor restored with basic plugins');
                  }

                  // Update UI
                  const statusEl = document.getElementById('collab-status');
                  if (statusEl) {
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'disconnected';
                  }

                  sendMessageToNative({
                    type: 'collaborationStopped',
                    success: true
                  });

                  console.log('[WebView] Y.js collaboration stopped successfully');
                } catch (error) {
                  console.error('[WebView] Error stopping Y.js collaboration:', error);
                  sendMessageToNative({
                    type: 'collaborationStopped',
                    success: false,
                    error: error.message
                  });
                }
              })();
              break;

            case 'applySteps':
              console.log('[WebView] Applying steps from', data.clientID, '- version:', data.version, '- steps:', data.steps.length);
              if (editorView && data.steps && data.steps.length > 0) {
                try {
                  let tr = editorView.state.tr;

                  // Apply each step to the transaction
                  for (const stepJSON of data.steps) {
                    const step = Step.fromJSON(schema, stepJSON);
                    tr.step(step);
                  }

                  // Apply the transaction to update the editor
                  editorView.dispatch(tr);
                  editorState = editorView.state;

                  console.log('[WebView] Successfully applied', data.steps.length, 'steps');

                  // Notify React Native that document changed
                  sendMessageToNative({
                    type: 'documentChange',
                    document: editorView.state.doc.toJSON()
                  });
                } catch (e) {
                  console.error('[WebView] Error applying steps:', e);
                }
              }
              break;

            case 'yjsUpdate':
              // Handle incoming Y.js update from React Native (base64 encoded)
              console.log('[WebView] yjsUpdate message received, data:', {
                hasUpdateBase64: !!data.updateBase64,
                updateBase64Type: typeof data.updateBase64,
                updateBase64Length: data.updateBase64 ? data.updateBase64.length : 0,
                ydocReady: !!ydoc
              });

              if (data.updateBase64) {
                try {
                  // Decode base64 to Uint8Array
                  const binary = atob(data.updateBase64);
                  const bytes = new Uint8Array(binary.length);
                  for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                  }
                  console.log('[WebView] Decoded base64 update, byte size:', bytes.length);

                  if (ydoc) {
                    // Y.js is initialized, apply update immediately
                    console.log('[WebView] Applying Y.js update from native, size:', bytes.length);
                    window.PM.Y.applyUpdate(ydoc, bytes, 'remote');
                    console.log('[WebView] Y.js update applied successfully');
                  } else {
                    // Buffer the update until Y.js is initialized
                    console.log('[WebView] Buffering Y.js update (ydoc not ready yet)');
                    pendingYjsUpdates.push(bytes);
                  }
                } catch (error) {
                  console.error('[WebView] Error decoding/applying Y.js update:', error);
                }
              } else {
                console.warn('[WebView] Received yjsUpdate but no updateBase64 data');
              }
              break;

            case 'awarenessUpdate':
              // Handle incoming awareness update from React Native
              if (awareness && data.update) {
                try {
                  const update = new Uint8Array(data.update);
                  console.log('[WebView] Applying awareness update from native, size:', update.length);
                  window.PM.awarenessProtocol.applyAwarenessUpdate(
                    awareness,
                    update,
                    'remote'
                  );
                  console.log('[WebView] Awareness update applied successfully');
                } catch (error) {
                  console.error('[WebView] Error applying awareness update:', error);
                }
              } else {
                console.warn('[WebView] Received awarenessUpdate but awareness not initialized or no update data');
              }
              break;

            default:
              console.warn('[WebView] Unknown message type:', data.type);
          }
        } catch (e) {
          console.error('[WebView] Error handling message:', e);
        }
      });
    }
  </script>
</body>
</html>
