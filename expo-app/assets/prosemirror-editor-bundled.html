<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ProseMirror Editor</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f5f5;
    }

    #editor-container {
      padding: 0;
      min-height: 100vh;
      background: white;
    }

    .ProseMirror {
      outline: none;
      padding: 0;
      min-height: 300px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
    }

    .ProseMirror h1 {
      font-size: 2em;
      margin: 0.67em 0;
      font-weight: bold;
    }

    .ProseMirror h2 {
      font-size: 1.5em;
      margin: 0.75em 0;
      font-weight: bold;
    }

    .ProseMirror p {
      margin: 1em 0;
    }

    .ProseMirror ul, .ProseMirror ol {
      padding-left: 30px;
    }

    .ProseMirror strong {
      font-weight: bold;
    }

    .ProseMirror em {
      font-style: italic;
    }

    .ProseMirror .geo-mark {
      background-color: rgba(59, 130, 246, 0.2);
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      border-bottom: 2px solid rgba(59, 130, 246, 0.5);
      transition: all 0.2s ease;
    }

    .ProseMirror .geo-mark:hover {
      background-color: rgba(59, 130, 246, 0.3);
      border-bottom-color: rgba(59, 130, 246, 0.8);
    }

    .status-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #4caf50;
      color: white;
      padding: 8px 16px;
      font-size: 12px;
      z-index: 1000;
    }

    .status-bar.error {
      background: #f44336;
    }

    #editor-wrapper {
      margin-top: 40px;
    }

    #toolbar {
      display: flex;
      gap: 4px;
      padding: 8px;
      background: #f9fafb;
      border-bottom: 1px solid #e5e7eb;
      flex-wrap: wrap;
      align-items: center;
    }

    #toolbar button {
      padding: 6px 12px;
      background: white;
      border: 1px solid #d1d5db;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      color: #374151;
      transition: all 0.15s ease;
      -webkit-tap-highlight-color: transparent;
    }

    #toolbar button:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }

    #toolbar button:active {
      background: #e5e7eb;
      transform: scale(0.98);
    }

    #toolbar button.active {
      background: #3b82f6;
      color: white;
      border-color: #2563eb;
    }

    #toolbar button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #toolbar .separator {
      width: 1px;
      height: 24px;
      background: #e5e7eb;
      margin: 0 4px;
    }

    #editor-container {
      padding: 0;
    }
  </style>
</head>
<body>
  <div class="status-bar" id="status">Loading ProseMirror...</div>
  <div id="editor-wrapper">
    <div id="toolbar">
      <button id="btn-paragraph" title="Paragraph">P</button>
      <button id="btn-h1" title="Heading 1">H1</button>
      <button id="btn-h2" title="Heading 2">H2</button>
      <button id="btn-h3" title="Heading 3">H3</button>
      <div class="separator"></div>
      <button id="btn-bold" title="Bold">B</button>
      <button id="btn-italic" title="Italic">I</button>
    </div>
    <div id="editor-container"></div>
  </div>

  <script>
    console.log('[WebView] Script starting...');

    // Set up message handler
    function sendMessageToNative(message) {
      try {
        const json = JSON.stringify(message);
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(json);
        } else {
          console.warn('[WebView] ReactNativeWebView not available');
        }
      } catch (e) {
        console.error('[WebView] Error sending message:', e);
      }
    }

    function setStatus(text, isError = false) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = text;
      statusEl.className = isError ? 'status-bar error' : 'status-bar';
    }

    // Handle errors
    window.addEventListener('error', function(e) {
      console.error('[WebView] Error:', e.message, e.filename, e.lineno);
      setStatus('Error: ' + e.message, true);
      sendMessageToNative({
        type: 'error',
        message: e.message,
        filename: e.filename,
        lineno: e.lineno
      });
    });

    // Load ProseMirror bundle
    console.log('[WebView] About to load ProseMirror bundle...');
    setStatus('Loading ProseMirror bundle...');
  </script>

  <!-- INLINE PROSEMIRROR BUNDLE WILL BE INSERTED HERE -->
  <script id="prosemirror-bundle">
    // This will be replaced with the actual bundle content
    console.log('[WebView] ProseMirror bundle placeholder');
  </script>

  <script>
    console.log('[WebView] Checking if ProseMirror loaded...');
    console.log('[WebView] window.PM exists:', typeof window.PM !== 'undefined');
    console.log('[WebView] PM contents:', window.PM);

    if (typeof window.PM === 'undefined') {
      setStatus('ERROR: ProseMirror failed to load', true);
      sendMessageToNative({
        type: 'error',
        message: 'ProseMirror bundle did not load'
      });
    } else {
      setStatus('ProseMirror loaded successfully!');

      // Initialize editor
      const { EditorState } = window.PM.state;
      const { EditorView } = window.PM.view;
      const { schema } = window.PM;
      const { keymap } = window.PM;
      const { history, undo, redo } = window.PM.history;
      const { baseKeymap } = window.PM.commands;

      console.log('[WebView] Creating editor state...');

      let editorView = null;

      // Create initial document with some test content
      const { DOMParser: PMDOMParser } = window.PM.model;

      // Create a simple test document
      const doc = schema.node('doc', null, [
        schema.node('paragraph', null, [
          schema.text('Welcome to ProseMirror! This editor is working correctly.')
        ]),
        schema.node('paragraph', null, [
          schema.text('Click "Load Sample" to load the test content, or enable "Edit Mode" to start typing.')
        ])
      ]);

      // Create initial editor state
      let state = EditorState.create({
        doc: doc,
        schema: schema,
        plugins: [
          history(),
          keymap({ 'Mod-z': undo, 'Mod-y': redo }),
          keymap(baseKeymap)
        ]
      });

      console.log('[WebView] Creating editor view...');

      // Create editor view
      editorView = new EditorView(document.querySelector('#editor-container'), {
        state: state,
        dispatchTransaction(transaction) {
          const oldState = editorView.state;
          const newState = oldState.apply(transaction);
          editorView.updateState(newState);

          // Send document changes to native
          if (transaction.docChanged) {
            sendMessageToNative({
              type: 'documentChange',
              doc: newState.doc.toJSON()
            });
          }

          // Send selection changes to native
          const oldSelection = oldState.selection;
          const newSelection = newState.selection;
          if (!oldSelection.eq(newSelection)) {
            console.log('[WebView] Selection changed, empty:', newSelection.empty);
            sendMessageToNative({
              type: 'selectionChange',
              empty: newSelection.empty
            });
          }

          // Update toolbar button states
          if (typeof updateToolbar === 'function') {
            updateToolbar();
          }
        }
      });

      console.log('[WebView] Editor created successfully');
      setStatus('Editor ready');

      // Toolbar command functions
      function setBlockType(nodeType, attrs = {}) {
        return function(state, dispatch) {
          const { from, to } = state.selection;
          const { $from } = state.selection;

          // Get the parent node
          const parentDepth = $from.depth;
          const parent = $from.node(parentDepth);

          if (dispatch) {
            const tr = state.tr.setBlockType(from, to, nodeType, attrs);
            dispatch(tr);
          }
          return true;
        };
      }

      function toggleMark(markType) {
        return function(state, dispatch) {
          const { from, to } = state.selection;
          const hasMark = state.doc.rangeHasMark(from, to, markType);

          if (dispatch) {
            if (hasMark) {
              dispatch(state.tr.removeMark(from, to, markType));
            } else {
              dispatch(state.tr.addMark(from, to, markType.create()));
            }
          }
          return true;
        };
      }

      function isNodeTypeActive(state, nodeType, attrs = {}) {
        const { $from, to } = state.selection;
        const node = $from.parent;

        if (node.type.name !== nodeType.name) {
          return false;
        }

        // Check attributes match
        for (let key in attrs) {
          if (node.attrs[key] !== attrs[key]) {
            return false;
          }
        }

        return true;
      }

      function isMarkActive(state, markType) {
        const { from, to } = state.selection;
        return state.doc.rangeHasMark(from, to, markType);
      }

      // Update toolbar button states
      function updateToolbar() {
        const state = editorView.state;

        // Update block type buttons
        document.getElementById('btn-paragraph').classList.toggle(
          'active',
          isNodeTypeActive(state, schema.nodes.paragraph)
        );
        document.getElementById('btn-h1').classList.toggle(
          'active',
          isNodeTypeActive(state, schema.nodes.heading, { level: 1 })
        );
        document.getElementById('btn-h2').classList.toggle(
          'active',
          isNodeTypeActive(state, schema.nodes.heading, { level: 2 })
        );
        document.getElementById('btn-h3').classList.toggle(
          'active',
          isNodeTypeActive(state, schema.nodes.heading, { level: 3 })
        );

        // Update mark buttons
        if (schema.marks.strong) {
          document.getElementById('btn-bold').classList.toggle(
            'active',
            isMarkActive(state, schema.marks.strong)
          );
        }
        if (schema.marks.em) {
          document.getElementById('btn-italic').classList.toggle(
            'active',
            isMarkActive(state, schema.marks.em)
          );
        }
      }

      // Wire up toolbar buttons
      document.getElementById('btn-paragraph').addEventListener('click', function() {
        const command = setBlockType(schema.nodes.paragraph);
        command(editorView.state, editorView.dispatch);
        editorView.focus();
      });

      document.getElementById('btn-h1').addEventListener('click', function() {
        const command = setBlockType(schema.nodes.heading, { level: 1 });
        command(editorView.state, editorView.dispatch);
        editorView.focus();
      });

      document.getElementById('btn-h2').addEventListener('click', function() {
        const command = setBlockType(schema.nodes.heading, { level: 2 });
        command(editorView.state, editorView.dispatch);
        editorView.focus();
      });

      document.getElementById('btn-h3').addEventListener('click', function() {
        const command = setBlockType(schema.nodes.heading, { level: 3 });
        command(editorView.state, editorView.dispatch);
        editorView.focus();
      });

      if (schema.marks.strong) {
        document.getElementById('btn-bold').addEventListener('click', function() {
          const command = toggleMark(schema.marks.strong);
          command(editorView.state, editorView.dispatch);
          editorView.focus();
        });
      }

      if (schema.marks.em) {
        document.getElementById('btn-italic').addEventListener('click', function() {
          const command = toggleMark(schema.marks.em);
          command(editorView.state, editorView.dispatch);
          editorView.focus();
        });
      }

      // Update toolbar on initial load
      updateToolbar();

      // Add click handler for geo-marks
      document.querySelector('#editor-container').addEventListener('click', function(e) {
        if (e.target.classList.contains('geo-mark')) {
          const attrs = {
            geoId: e.target.getAttribute('data-geo-id'),
            placeName: e.target.getAttribute('data-place-name'),
            lat: e.target.getAttribute('data-lat'),
            lng: e.target.getAttribute('data-lng'),
            colorIndex: parseInt(e.target.getAttribute('data-color-index') || '0'),
            coordSource: e.target.getAttribute('data-coord-source')
          };
          console.log('[WebView] Geo-mark clicked:', attrs);
          sendMessageToNative({
            type: 'geoMarkNavigate',
            attrs: attrs
          });
        }
      });

      // Send ready message
      sendMessageToNative({
        type: 'ready',
        message: 'ProseMirror editor initialized'
      });

      // Listen for iOS custom menu actions
      // iOS will trigger this when custom menu items are selected
      document.addEventListener('selectionchange', function() {
        console.log('[WebView] Selection changed via DOM');
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          const selectedText = selection.toString();
          console.log('[WebView] Selected text from DOM:', selectedText);
        }
      });

      // Intercept iOS UIMenuItem actions via a hidden input trick
      // When iOS menu items are clicked, we can detect it through focus/blur events
      let lastSelectedText = '';
      let pendingGeoMarkCreation = false;

      // Store selection when text is selected
      document.addEventListener('selectionchange', function() {
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          lastSelectedText = selection.toString();
          console.log('[WebView] Stored selected text:', lastSelectedText);
        }
      });

      // Create a global function that iOS can call
      window.createLocationFromSelection = function() {
        console.log('[WebView] createLocationFromSelection called!');
        const { state } = editorView;
        const { selection } = state;

        if (selection.empty) {
          console.warn('[WebView] No text selected');
          return;
        }

        const selectedText = state.doc.textBetween(
          selection.from,
          selection.to,
          ' '
        );

        console.log('[WebView] Creating location from iOS menu for:', selectedText);

        // Send request to show geo-mark editor
        sendMessageToNative({
          type: 'showGeoMarkEditor',
          data: {
            placeName: selectedText,
            from: selection.from,
            to: selection.to
          },
          existingLocations: []
        });
      };

      // Expose to window for iOS to call
      window.handleCreateLocation = window.createLocationFromSelection;

      // Listen for messages from React Native and native iOS menu
      window.addEventListener('message', function(event) {
        console.log('[WebView] Received message:', event.data);

        // Handle native iOS menu actions
        if (event.data && event.data.source === 'nativeMenu') {
          console.log('[WebView] Native menu action:', event.data.action);

          if (event.data.action === 'createLocation') {
            console.log('[WebView] Create location from native menu:', event.data.data.selectedText);
            // Trigger the create location function
            if (window.createLocationFromSelection) {
              window.createLocationFromSelection();
            }
            return;
          }

          if (event.data.action === 'addNote') {
            console.log('[WebView] Add note from native menu:', event.data.data.selectedText);
            // Handle add note action
            return;
          }
        }

        try {
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          switch (data.type) {
            case 'setContent':
              console.log('[WebView] Setting content:', data.content);
              if (data.content && editorView) {
                const newState = EditorState.create({
                  doc: schema.nodeFromJSON(data.content),
                  plugins: state.plugins
                });
                editorView.updateState(newState);
                state = newState;
              }
              break;

            case 'setEditable':
              console.log('[WebView] Setting editable:', data.editable);
              if (editorView) {
                editorView.setProps({ editable: () => data.editable });
              }
              break;

            case 'getState':
              console.log('[WebView] Getting state');
              if (editorView) {
                sendMessageToNative({
                  type: 'stateResponse',
                  state: editorView.state.doc.toJSON()
                });
              }
              break;

            case 'createGeoMark':
              console.log('[WebView] Creating geo-mark with data:', data.geoMarkData);
              if (editorView && data.geoMarkData) {
                const { state, dispatch } = editorView;
                const { selection } = state;
                const { from, to } = selection;

                // Create a geoMark mark with the location data
                const geoMarkType = schema.marks.geoMark;
                if (!geoMarkType) {
                  console.error('[WebView] geoMark mark type not found in schema');
                  break;
                }

                const mark = geoMarkType.create({
                  geoId: data.geoMarkData.geoId,
                  placeName: data.geoMarkData.placeName,
                  lat: data.geoMarkData.lat,
                  lng: data.geoMarkData.lng,
                  colorIndex: data.geoMarkData.colorIndex || 0,
                  coordSource: data.geoMarkData.coordSource || 'manual'
                });

                // Add the mark to the selected text
                const tr = state.tr.addMark(from, to, mark);
                dispatch(tr);

                console.log('[WebView] Geo-mark created successfully');
                sendMessageToNative({
                  type: 'info',
                  message: 'Location created: ' + data.geoMarkData.placeName
                });
              }
              break;

            case 'command':
              console.log('[WebView] Executing command:', data.command);
              if (data.command === 'createGeoMark' && editorView) {
                const { state, dispatch } = editorView;
                const { selection } = state;

                // Check if there's selected text
                if (selection.empty) {
                  console.warn('[WebView] No text selected for geo-mark');
                  sendMessageToNative({
                    type: 'error',
                    message: 'Please select text to create a location'
                  });
                  break;
                }

                // Get selected text
                const selectedText = state.doc.textBetween(
                  selection.from,
                  selection.to,
                  ' '
                );

                console.log('[WebView] Selected text:', selectedText);

                // Send request to show geo-mark editor with selected text
                sendMessageToNative({
                  type: 'showGeoMarkEditor',
                  data: {
                    placeName: selectedText,
                    from: selection.from,
                    to: selection.to
                  },
                  existingLocations: []
                });
              }
              break;

            default:
              console.warn('[WebView] Unknown message type:', data.type);
          }
        } catch (e) {
          console.error('[WebView] Error handling message:', e);
        }
      });
    }
  </script>
</body>
</html>
