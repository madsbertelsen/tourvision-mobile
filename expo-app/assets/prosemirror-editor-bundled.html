<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ProseMirror Editor</title>
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #ffffff;
    }

    #editor-container {
      padding: 0;
      min-height: 100vh;
      background: white;
    }

    .ProseMirror {
      outline: none;
      padding: 0;
      min-height: 300px;
      background: white;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
    }

    .ProseMirror h1 {
      font-size: 2em;
      margin: 0.67em 0;
      font-weight: bold;
    }

    .ProseMirror h2 {
      font-size: 1.5em;
      margin: 0.75em 0;
      font-weight: bold;
    }

    .ProseMirror p {
      margin: 1em 0;
    }

    .ProseMirror ul, .ProseMirror ol {
      padding-left: 30px;
    }

    .ProseMirror strong {
      font-weight: bold;
    }

    .ProseMirror em {
      font-style: italic;
    }

    .ProseMirror .geo-mark {
      background-color: rgba(59, 130, 246, 0.2);
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      border-bottom: 2px solid rgba(59, 130, 246, 0.5);
      transition: all 0.2s ease;
    }

    .ProseMirror .geo-mark:hover {
      background-color: rgba(59, 130, 246, 0.3);
      border-bottom-color: rgba(59, 130, 246, 0.8);
    }

    .status-bar {
      display: none; /* Hidden to save space */
    }

    #editor-container {
      padding: 0;
      height: 100%;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="status-bar" id="status">Loading ProseMirror...</div>
  <div id="editor-container"></div>

  <script>
    console.log('[WebView] Script starting...');

    // Set up message handler
    function sendMessageToNative(message) {
      try {
        const json = JSON.stringify(message);
        if (window.ReactNativeWebView) {
          window.ReactNativeWebView.postMessage(json);
        } else {
          console.warn('[WebView] ReactNativeWebView not available');
        }
      } catch (e) {
        console.error('[WebView] Error sending message:', e);
      }
    }

    function setStatus(text, isError = false) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = text;
      statusEl.className = isError ? 'status-bar error' : 'status-bar';
    }

    // Handle errors
    window.addEventListener('error', function(e) {
      console.error('[WebView] Error:', e.message, e.filename, e.lineno);
      setStatus('Error: ' + e.message, true);
      sendMessageToNative({
        type: 'error',
        message: e.message,
        filename: e.filename,
        lineno: e.lineno
      });
    });

    // Load ProseMirror bundle
    console.log('[WebView] About to load ProseMirror bundle...');
    setStatus('Loading ProseMirror bundle...');
  </script>

  <!-- INLINE PROSEMIRROR BUNDLE WILL BE INSERTED HERE -->
  <script id="prosemirror-bundle">
    // This will be replaced with the actual bundle content
    console.log('[WebView] ProseMirror bundle placeholder');
  </script>

  <script>
    console.log('[WebView] Checking if ProseMirror loaded...');
    console.log('[WebView] window.PM exists:', typeof window.PM !== 'undefined');
    console.log('[WebView] PM contents:', window.PM);

    if (typeof window.PM === 'undefined') {
      setStatus('ERROR: ProseMirror failed to load', true);
      sendMessageToNative({
        type: 'error',
        message: 'ProseMirror bundle did not load'
      });
    } else {
      setStatus('ProseMirror loaded successfully!');

      // Initialize editor
      const { EditorState } = window.PM.state;
      const { EditorView } = window.PM.view;
      const { schema } = window.PM;
      const { keymap } = window.PM;
      const { history, undo, redo } = window.PM.history;
      const { baseKeymap } = window.PM.commands;

      console.log('[WebView] Creating editor state...');

      let editorView = null;

      // Create initial document with some test content
      const { DOMParser: PMDOMParser } = window.PM.model;

      // Create a simple test document
      const doc = schema.node('doc', null, [
        schema.node('paragraph', null, [
          schema.text('Welcome to ProseMirror! This editor is working correctly.')
        ]),
        schema.node('paragraph', null, [
          schema.text('Click "Load Sample" to load the test content, or enable "Edit Mode" to start typing.')
        ])
      ]);

      // Create initial editor state
      let state = EditorState.create({
        doc: doc,
        schema: schema,
        plugins: [
          history(),
          keymap({ 'Mod-z': undo, 'Mod-y': redo }),
          keymap(baseKeymap)
        ]
      });

      console.log('[WebView] Creating editor view...');

      // Create editor view
      editorView = new EditorView(document.querySelector('#editor-container'), {
        state: state,
        dispatchTransaction(transaction) {
          const oldState = editorView.state;
          const newState = oldState.apply(transaction);
          editorView.updateState(newState);

          // Send document changes to native
          if (transaction.docChanged) {
            sendMessageToNative({
              type: 'documentChange',
              doc: newState.doc.toJSON()
            });
          }

          // Send selection changes to native
          const oldSelection = oldState.selection;
          const newSelection = newState.selection;
          if (!oldSelection.eq(newSelection)) {
            console.log('[WebView] Selection changed, empty:', newSelection.empty);
            sendMessageToNative({
              type: 'selectionChange',
              empty: newSelection.empty
            });

            // Send toolbar state update
            const toolbarState = getToolbarState();
            sendMessageToNative({
              type: 'toolbarStateChange',
              state: toolbarState
            });
          }
        }
      });

      console.log('[WebView] Editor created successfully');
      setStatus('Editor ready');

      // Helper functions for toolbar state
      function isNodeTypeActive(state, nodeType, attrs = {}) {
        const { $from } = state.selection;
        const node = $from.parent;

        if (node.type.name !== nodeType.name) {
          return false;
        }

        // Check attributes match
        for (let key in attrs) {
          if (node.attrs[key] !== attrs[key]) {
            return false;
          }
        }

        return true;
      }

      function isMarkActive(state, markType) {
        const { from, to } = state.selection;
        return state.doc.rangeHasMark(from, to, markType);
      }

      // Get current toolbar state based on selection
      function getToolbarState() {
        const state = editorView.state;
        return {
          paragraph: isNodeTypeActive(state, schema.nodes.paragraph),
          h1: isNodeTypeActive(state, schema.nodes.heading, { level: 1 }),
          h2: isNodeTypeActive(state, schema.nodes.heading, { level: 2 }),
          h3: isNodeTypeActive(state, schema.nodes.heading, { level: 3 }),
          bold: schema.marks.strong ? isMarkActive(state, schema.marks.strong) : false,
          italic: schema.marks.em ? isMarkActive(state, schema.marks.em) : false
        };
      }

      // Add click handler for geo-marks
      document.querySelector('#editor-container').addEventListener('click', function(e) {
        if (e.target.classList.contains('geo-mark')) {
          const attrs = {
            geoId: e.target.getAttribute('data-geo-id'),
            placeName: e.target.getAttribute('data-place-name'),
            lat: e.target.getAttribute('data-lat'),
            lng: e.target.getAttribute('data-lng'),
            colorIndex: parseInt(e.target.getAttribute('data-color-index') || '0'),
            coordSource: e.target.getAttribute('data-coord-source')
          };
          console.log('[WebView] Geo-mark clicked:', attrs);
          sendMessageToNative({
            type: 'geoMarkNavigate',
            attrs: attrs
          });
        }
      });

      // Send ready message
      sendMessageToNative({
        type: 'ready',
        message: 'ProseMirror editor initialized'
      });

      // Send initial toolbar state
      const initialToolbarState = getToolbarState();
      sendMessageToNative({
        type: 'toolbarStateChange',
        state: initialToolbarState
      });

      // Listen for iOS custom menu actions
      // iOS will trigger this when custom menu items are selected
      document.addEventListener('selectionchange', function() {
        console.log('[WebView] Selection changed via DOM');
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          const selectedText = selection.toString();
          console.log('[WebView] Selected text from DOM:', selectedText);
        }
      });

      // Intercept iOS UIMenuItem actions via a hidden input trick
      // When iOS menu items are clicked, we can detect it through focus/blur events
      let lastSelectedText = '';
      let pendingGeoMarkCreation = false;

      // Store selection when text is selected
      document.addEventListener('selectionchange', function() {
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          lastSelectedText = selection.toString();
          console.log('[WebView] Stored selected text:', lastSelectedText);
        }
      });

      // Create a global function that iOS can call
      window.createLocationFromSelection = function() {
        console.log('[WebView] createLocationFromSelection called!');
        const { state } = editorView;
        const { selection } = state;

        if (selection.empty) {
          console.warn('[WebView] No text selected');
          return;
        }

        const selectedText = state.doc.textBetween(
          selection.from,
          selection.to,
          ' '
        );

        console.log('[WebView] Creating location from iOS menu for:', selectedText);

        // Send request to show geo-mark editor
        sendMessageToNative({
          type: 'showGeoMarkEditor',
          data: {
            placeName: selectedText,
            from: selection.from,
            to: selection.to
          },
          existingLocations: []
        });
      };

      // Expose to window for iOS to call
      window.handleCreateLocation = window.createLocationFromSelection;

      // Listen for messages from React Native and native iOS menu
      window.addEventListener('message', function(event) {
        console.log('[WebView] Received message:', event.data);

        // Handle native iOS menu actions
        if (event.data && event.data.source === 'nativeMenu') {
          console.log('[WebView] Native menu action:', event.data.action);

          if (event.data.action === 'createLocation') {
            console.log('[WebView] Create location from native menu:', event.data.data.selectedText);
            // Trigger the create location function
            if (window.createLocationFromSelection) {
              window.createLocationFromSelection();
            }
            return;
          }

          if (event.data.action === 'addNote') {
            console.log('[WebView] Add note from native menu:', event.data.data.selectedText);
            // Handle add note action
            return;
          }
        }

        try {
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          switch (data.type) {
            case 'setContent':
              console.log('[WebView] Setting content:', data.content);
              if (data.content && editorView) {
                const newState = EditorState.create({
                  doc: schema.nodeFromJSON(data.content),
                  plugins: state.plugins
                });
                editorView.updateState(newState);
                state = newState;

                // Send updated toolbar state after loading content
                const toolbarState = getToolbarState();
                sendMessageToNative({
                  type: 'toolbarStateChange',
                  state: toolbarState
                });
              }
              break;

            case 'setEditable':
              console.log('[WebView] Setting editable:', data.editable);
              if (editorView) {
                editorView.setProps({ editable: () => data.editable });
              }
              break;

            case 'getState':
              console.log('[WebView] Getting state');
              if (editorView) {
                sendMessageToNative({
                  type: 'stateResponse',
                  state: editorView.state.doc.toJSON()
                });
              }
              break;

            case 'createGeoMark':
              console.log('[WebView] Creating geo-mark with data:', data.geoMarkData);
              if (editorView && data.geoMarkData) {
                const { state, dispatch } = editorView;
                const { selection } = state;
                const { from, to } = selection;

                // Create a geoMark mark with the location data
                const geoMarkType = schema.marks.geoMark;
                if (!geoMarkType) {
                  console.error('[WebView] geoMark mark type not found in schema');
                  break;
                }

                const mark = geoMarkType.create({
                  geoId: data.geoMarkData.geoId,
                  placeName: data.geoMarkData.placeName,
                  lat: data.geoMarkData.lat,
                  lng: data.geoMarkData.lng,
                  colorIndex: data.geoMarkData.colorIndex || 0,
                  coordSource: data.geoMarkData.coordSource || 'manual'
                });

                // Add the mark to the selected text
                const tr = state.tr.addMark(from, to, mark);
                dispatch(tr);

                console.log('[WebView] Geo-mark created successfully');
                sendMessageToNative({
                  type: 'info',
                  message: 'Location created: ' + data.geoMarkData.placeName
                });
              }
              break;

            case 'command':
              console.log('[WebView] Executing command:', data.command, data.params);
              if (!editorView) {
                console.warn('[WebView] Editor view not available');
                break;
              }

              const { state, dispatch } = editorView;
              const { selection } = state;
              const { from, to } = selection;

              switch (data.command) {
                case 'setParagraph':
                  console.log('[WebView] Setting paragraph');
                  const paragraphTr = state.tr.setBlockType(from, to, schema.nodes.paragraph);
                  dispatch(paragraphTr);
                  editorView.focus();
                  break;

                case 'setHeading':
                  const level = data.params?.level || 1;
                  console.log('[WebView] Setting heading level:', level);
                  const headingTr = state.tr.setBlockType(from, to, schema.nodes.heading, { level });
                  dispatch(headingTr);
                  editorView.focus();
                  break;

                case 'toggleBold':
                  console.log('[WebView] Toggling bold');
                  if (schema.marks.strong) {
                    const hasBold = state.doc.rangeHasMark(from, to, schema.marks.strong);
                    if (hasBold) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.strong));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.strong.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'toggleItalic':
                  console.log('[WebView] Toggling italic');
                  if (schema.marks.em) {
                    const hasItalic = state.doc.rangeHasMark(from, to, schema.marks.em);
                    if (hasItalic) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.em));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.em.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'createGeoMark':
                  // Check if there's selected text
                  if (selection.empty) {
                    console.warn('[WebView] No text selected for geo-mark');
                    sendMessageToNative({
                      type: 'error',
                      message: 'Please select text to create a location'
                    });
                    break;
                  }

                  // Get selected text
                  const selectedText = state.doc.textBetween(from, to, ' ');
                  console.log('[WebView] Selected text:', selectedText);

                  // Send request to show geo-mark editor with selected text
                  sendMessageToNative({
                    type: 'showGeoMarkEditor',
                    data: {
                      placeName: selectedText,
                      from: selection.from,
                      to: selection.to
                    },
                    existingLocations: []
                  });
                  break;

                default:
                  console.warn('[WebView] Unknown command:', data.command);
              }
              break;

            default:
              console.warn('[WebView] Unknown message type:', data.type);
          }
        } catch (e) {
          console.error('[WebView] Error handling message:', e);
        }
      });
    }
  </script>
</body>
</html>
