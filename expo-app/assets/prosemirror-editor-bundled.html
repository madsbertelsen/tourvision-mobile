<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>ProseMirror Editor</title>
  <!-- Socket.io client for collaboration -->
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #ffffff;
    }

    #editor-container {
      padding: 0;
      height: 100%;
      background: white;
    }

    .ProseMirror {
      outline: none;
      padding: 0;
      min-height: 100%;
      background: white;
      border: none;
      border-radius: 0;
      caret-color: #3b82f6; /* Bright blue cursor */
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
    }

    /* Disable spell checking underlines */
    .ProseMirror * {
      -webkit-text-decoration-skip: none;
      text-decoration-skip-ink: none;
    }

    /* Make cursor/caret more visible with animation */
    @keyframes blink {
      0%, 49% { opacity: 1; }
      50%, 100% { opacity: 0; }
    }

    /* Enhanced selection highlighting */
    .ProseMirror ::selection {
      background-color: #3b82f6; /* Bright blue */
      color: white;
    }

    .ProseMirror ::-moz-selection {
      background-color: #3b82f6;
      color: white;
    }

    /* ProseMirror's own selection styling */
    .ProseMirror-selectednode {
      outline: 3px solid #3b82f6;
      outline-offset: 2px;
    }

    /* Make the gapcursor more visible */
    .ProseMirror-gapcursor {
      display: block;
      pointer-events: none;
      position: absolute;
    }

    .ProseMirror-gapcursor:after {
      content: "";
      display: block;
      position: absolute;
      top: -2px;
      width: 20px;
      border-top: 2px solid #3b82f6;
      animation: blink 1.2s step-end infinite;
    }

    /* Custom typing cursor indicator */
    #typing-cursor {
      position: absolute;
      width: 3px;
      background-color: #EF4444; /* Bright red for visibility */
      pointer-events: none;
      z-index: 1000;
      animation: blink 0.8s ease-in-out infinite;
      display: none; /* Hidden by default, shown during typing */
      box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);
    }

    #typing-cursor.visible {
      display: block;
    }

    /* Collaboration cursors and selections */
    .collab-cursor {
      position: relative;
      display: inline-block;
      width: 0;
      height: 1em;
    }

    .collab-cursor-label {
      position: absolute;
      bottom: 100%;
      left: -2px;
      background-color: #3b82f6;
      color: white;
      font-size: 11px;
      padding: 2px 4px;
      border-radius: 3px;
      white-space: nowrap;
      pointer-events: none;
      z-index: 10;
    }

    .collab-selection {
      background-color: rgba(59, 130, 246, 0.2);
    }

    /* Collaboration status indicator */
    #collab-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      font-size: 11px;
      border-radius: 4px;
      z-index: 100;
      display: none;
    }

    #collab-status.connected {
      background: rgba(16, 185, 129, 0.9);
      display: block;
    }

    #collab-status.disconnected {
      background: rgba(239, 68, 68, 0.9);
      display: block;
    }

    #collab-users {
      position: fixed;
      top: 10px;
      left: 10px;
      display: flex;
      gap: 8px;
      z-index: 100;
    }

    .collab-user {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      color: white;
      font-weight: 500;
    }

    .ProseMirror h1 {
      font-size: 2em;
      margin: 0.67em 0;
      font-weight: bold;
    }

    .ProseMirror h2 {
      font-size: 1.5em;
      margin: 0.75em 0;
      font-weight: bold;
    }

    .ProseMirror p {
      margin: 1em 0;
    }

    .ProseMirror ul, .ProseMirror ol {
      padding-left: 30px;
    }

    .ProseMirror strong {
      font-weight: bold;
    }

    .ProseMirror em {
      font-style: italic;
    }

    .ProseMirror .geo-mark {
      background-color: rgba(59, 130, 246, 0.2);
      padding: 2px 4px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none !important;
      border: none !important;
      border-bottom: none !important;
      -webkit-text-decoration: none !important;
    }

    .ProseMirror .geo-mark:hover {
      background-color: rgba(59, 130, 246, 0.3);
    }

    .ProseMirror .comment-mark {
      background-color: rgba(251, 191, 36, 0.3);
      border-bottom: 2px solid rgba(251, 191, 36, 0.6);
      cursor: pointer;
      padding: 1px 0;
      transition: all 0.2s ease;
    }

    .ProseMirror .comment-mark:hover {
      background-color: rgba(251, 191, 36, 0.4);
      border-bottom-color: rgba(251, 191, 36, 0.9);
    }

    .ProseMirror .comment-mark[data-resolved="true"] {
      background-color: rgba(156, 163, 175, 0.2);
      border-bottom-color: rgba(156, 163, 175, 0.4);
      opacity: 0.7;
    }

    .status-bar {
      display: none; /* Hidden to save space */
    }

    #editor-container {
      padding: 0;
      height: 100%;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="status-bar" id="status">Loading ProseMirror...</div>
  <div id="collab-status">Disconnected</div>
  <div id="collab-users"></div>
  <div id="editor-container"></div>
  <div id="typing-cursor"></div>

  <script>
    console.log('[WebView] Script starting...');

    // Set up message handler
    function sendMessageToNative(message) {
      try {
        const json = JSON.stringify(message);
        if (window.ReactNativeWebView) {
          // Native WebView (iOS/Android)
          window.ReactNativeWebView.postMessage(json);
        } else if (window.parent && window.parent !== window) {
          // Web iframe
          window.parent.postMessage(json, '*');
        } else {
          console.warn('[WebView] No message handler available');
        }
      } catch (e) {
        console.error('[WebView] Error sending message:', e);
      }
    }

    function setStatus(text, isError = false) {
      const statusEl = document.getElementById('status');
      statusEl.textContent = text;
      statusEl.className = isError ? 'status-bar error' : 'status-bar';
    }

    // Handle errors
    window.addEventListener('error', function(e) {
      console.error('[WebView] Error:', e.message, e.filename, e.lineno);
      setStatus('Error: ' + e.message, true);
      sendMessageToNative({
        type: 'error',
        message: e.message,
        filename: e.filename,
        lineno: e.lineno
      });
    });

    // Load ProseMirror bundle
    console.log('[WebView] About to load ProseMirror bundle...');
    setStatus('Loading ProseMirror bundle...');
  </script>

  <!-- INLINE PROSEMIRROR BUNDLE WILL BE INSERTED HERE -->
  <script id="prosemirror-bundle">
    // This will be replaced with the actual bundle content
    console.log('[WebView] ProseMirror bundle placeholder');
  </script>

  <script>
    console.log('[WebView] [v4-fixed] Checking if ProseMirror loaded...');
    console.log('[WebView] window.PM exists:', typeof window.PM !== 'undefined');
    console.log('[WebView] PM contents:', window.PM);

    if (typeof window.PM === 'undefined') {
      setStatus('ERROR: ProseMirror failed to load', true);
      sendMessageToNative({
        type: 'error',
        message: 'ProseMirror bundle did not load'
      });
    } else {
      setStatus('ProseMirror loaded successfully!');

      // Initialize editor
      const { EditorState, Plugin, PluginKey } = window.PM.state;
      const { EditorView, Decoration, DecorationSet } = window.PM.view;
      const { schema } = window.PM;
      const { keymap } = window.PM;
      const { history, undo, redo } = window.PM.history;
      const { baseKeymap } = window.PM.commands;
      const { Step } = window.PM.transform;

      console.log('[WebView] Creating editor state...');

      let editorView = null;
      let collabConnection = null;
      let collabPlugin = null;
      let socket = null;

      // Create initial document - empty, content will be sent from React Native
      const { DOMParser: PMDOMParser } = window.PM.model;

      // Start with empty document
      const doc = schema.node('doc', null, [
        schema.node('paragraph', null, [])
      ]);

      // Create initial editor state
      let editorState = EditorState.create({
        doc: doc,
        schema: schema,
        plugins: [
          history(),
          keymap({ 'Mod-z': undo, 'Mod-y': redo }),
          keymap(baseKeymap)
        ]
      });

      console.log('[WebView] Creating editor view...');

      // Color palette for geo-marks
      const COLORS = [
        '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',
        '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'
      ];

      // NodeView for geo-marks
      function createGeoMarkNodeView(node) {
        const span = document.createElement('span');
        span.className = 'geo-mark';

        // Apply background color based on colorIndex
        const colorIndex = node.attrs.colorIndex || 0;
        const color = COLORS[colorIndex % COLORS.length];
        span.style.backgroundColor = color + '33'; // 33 = 20% opacity
        span.style.padding = '2px 4px';
        span.style.borderRadius = '3px';
        span.style.cursor = 'pointer';
        span.style.transition = 'all 0.2s ease';
        span.style.textDecoration = 'none';
        span.style.border = 'none';
        span.style.borderBottom = 'none';

        // Store attributes as data attributes for click handling
        if (node.attrs.geoId) span.setAttribute('data-geo-id', node.attrs.geoId);
        if (node.attrs.placeName) span.setAttribute('data-place-name', node.attrs.placeName);
        if (node.attrs.lat) span.setAttribute('data-lat', node.attrs.lat);
        if (node.attrs.lng) span.setAttribute('data-lng', node.attrs.lng);
        if (node.attrs.colorIndex !== undefined) span.setAttribute('data-color-index', node.attrs.colorIndex);
        if (node.attrs.coordSource) span.setAttribute('data-coord-source', node.attrs.coordSource);

        console.log('[WebView] Created geo-mark NodeView with color:', color, 'for:', node.attrs.placeName);

        return {
          dom: span,
          contentDOM: span
        };
      }

      // Typing cursor management
      const typingCursor = document.getElementById('typing-cursor');
      let isTypingActive = false;

      function updateTypingCursor() {
        if (!isTypingActive || !editorView) {
          typingCursor.classList.remove('visible');
          return;
        }

        const { state } = editorView;
        const { selection } = state;
        const { from } = selection;

        // Get the coordinates of the cursor position
        try {
          const coords = editorView.coordsAtPos(from);
          const editorContainer = document.querySelector('#editor-container');
          const editorRect = editorContainer.getBoundingClientRect();

          // Calculate cursor height based on line height
          const cursorHeight = coords.bottom - coords.top;

          // Position and size the cursor indicator
          typingCursor.style.left = (coords.left - editorRect.left) + 'px';
          typingCursor.style.top = (coords.top - editorRect.top) + 'px';
          typingCursor.style.height = cursorHeight + 'px';
          typingCursor.classList.add('visible');

          console.log('[WebView] Cursor updated: height =', cursorHeight);
        } catch (e) {
          console.warn('[WebView] Could not get cursor coordinates:', e);
          typingCursor.classList.remove('visible');
        }
      }

      function showTypingCursor() {
        isTypingActive = true;
        updateTypingCursor();
        console.log('[WebView] Typing cursor shown');
      }

      function hideTypingCursor() {
        isTypingActive = false;
        typingCursor.classList.remove('visible');
        console.log('[WebView] Typing cursor hidden');
      }

      // Expose for native to control
      window.showTypingCursor = showTypingCursor;
      window.hideTypingCursor = hideTypingCursor;

      // Helper functions for toolbar state (must be defined before EditorView)
      // Helper function to update collaboration users display
      function updateCollabUsers() {
        if (!collabConnection) return;

        const usersEl = document.getElementById('collab-users');
        usersEl.innerHTML = '';

        collabConnection.users.forEach((user, userId) => {
          if (userId !== collabConnection.userId) {
            const userEl = document.createElement('div');
            userEl.className = 'collab-user';
            userEl.style.backgroundColor = user.color;
            userEl.textContent = user.name;
            usersEl.appendChild(userEl);
          }
        });
      }

      function isNodeTypeActive(state, nodeType, attrs = {}) {
        const { $from } = state.selection;
        const node = $from.parent;

        if (node.type.name !== nodeType.name) {
          return false;
        }

        // Check attributes match
        for (let key in attrs) {
          if (node.attrs[key] !== attrs[key]) {
            return false;
          }
        }

        return true;
      }

      function isMarkActive(state, markType) {
        const { from, to } = state.selection;
        return state.doc.rangeHasMark(from, to, markType);
      }

      // Get current toolbar state based on selection
      function getToolbarState() {
        const state = editorView.state;
        return {
          paragraph: isNodeTypeActive(state, schema.nodes.paragraph),
          h1: isNodeTypeActive(state, schema.nodes.heading, { level: 1 }),
          h2: isNodeTypeActive(state, schema.nodes.heading, { level: 2 }),
          h3: isNodeTypeActive(state, schema.nodes.heading, { level: 3 }),
          bold: schema.marks.strong ? isMarkActive(state, schema.marks.strong) : false,
          italic: schema.marks.em ? isMarkActive(state, schema.marks.em) : false
        };
      }

      // Create editor view
      editorView = new EditorView(document.querySelector('#editor-container'), {
        state: editorState,
        nodeViews: {
          geoMark: createGeoMarkNodeView
        },
        attributes: {
          spellcheck: 'false',
          autocorrect: 'off',
          autocapitalize: 'off'
        },
        dispatchTransaction(transaction) {
          const oldState = editorView.state;
          const newState = oldState.apply(transaction);
          editorView.updateState(newState);

          // Update typing cursor position on any change
          if (isTypingActive) {
            updateTypingCursor();
          }

          // Send document changes to native
          if (transaction.docChanged) {
            const docJSON = newState.doc.toJSON();
            console.log('[WebView] Document changed, sending to native:', JSON.stringify(docJSON));
            sendMessageToNative({
              type: 'documentChange',
              doc: docJSON
            });
          }

          // Send selection changes to native
          const oldSelection = oldState.selection;
          const newSelection = newState.selection;
          if (!oldSelection.eq(newSelection)) {
            console.log('[WebView] Selection changed, empty:', newSelection.empty);
            sendMessageToNative({
              type: 'selectionChange',
              empty: newSelection.empty
            });

            // Send toolbar state update
            const toolbarState = getToolbarState();
            sendMessageToNative({
              type: 'toolbarStateChange',
              state: toolbarState
            });
          }
        }
      });

      console.log('[WebView] Editor created successfully');
      setStatus('Editor ready');

      // Add click handler for geo-marks and comments
      document.querySelector('#editor-container').addEventListener('click', function(e) {
        if (e.target.classList.contains('geo-mark')) {
          const attrs = {
            geoId: e.target.getAttribute('data-geo-id'),
            placeName: e.target.getAttribute('data-place-name'),
            lat: e.target.getAttribute('data-lat'),
            lng: e.target.getAttribute('data-lng'),
            colorIndex: parseInt(e.target.getAttribute('data-color-index') || '0'),
            coordSource: e.target.getAttribute('data-coord-source')
          };
          console.log('[WebView] Geo-mark clicked:', attrs);
          sendMessageToNative({
            type: 'geoMarkNavigate',
            attrs: attrs
          });
        }

        if (e.target.classList.contains('comment-mark')) {
          const repliesStr = e.target.getAttribute('data-replies');
          let replies = null;
          if (repliesStr) {
            try {
              replies = JSON.parse(repliesStr);
            } catch (err) {
              console.error('[WebView] Error parsing replies:', err);
            }
          }

          const attrs = {
            commentId: e.target.getAttribute('data-comment-id'),
            userId: e.target.getAttribute('data-user-id'),
            userName: e.target.getAttribute('data-user-name') || '',
            content: e.target.getAttribute('data-content') || '',
            createdAt: e.target.getAttribute('data-created-at'),
            resolved: e.target.getAttribute('data-resolved') === 'true',
            replies: replies
          };
          console.log('[WebView] Comment clicked:', attrs);
          sendMessageToNative({
            type: 'commentClick',
            attrs: attrs
          });
        }
      });

      // Send ready message
      sendMessageToNative({
        type: 'ready',
        message: 'ProseMirror editor initialized'
      });

      // Send initial toolbar state
      const initialToolbarState = getToolbarState();
      sendMessageToNative({
        type: 'toolbarStateChange',
        state: initialToolbarState
      });

      // Listen for iOS custom menu actions
      // iOS will trigger this when custom menu items are selected
      document.addEventListener('selectionchange', function() {
        console.log('[WebView] Selection changed via DOM');
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          const selectedText = selection.toString();
          console.log('[WebView] Selected text from DOM:', selectedText);
        }
      });

      // Intercept iOS UIMenuItem actions via a hidden input trick
      // When iOS menu items are clicked, we can detect it through focus/blur events
      let lastSelectedText = '';
      let pendingGeoMarkCreation = false;

      // Store selection when text is selected
      document.addEventListener('selectionchange', function() {
        const selection = window.getSelection();
        if (selection && !selection.isCollapsed) {
          lastSelectedText = selection.toString();
          console.log('[WebView] Stored selected text:', lastSelectedText);
        }
      });

      // Create a global function that iOS can call
      window.createLocationFromSelection = function() {
        console.log('[WebView] createLocationFromSelection called!');
        const { state } = editorView;
        const { selection } = state;

        if (selection.empty) {
          console.warn('[WebView] No text selected');
          return;
        }

        const selectedText = state.doc.textBetween(
          selection.from,
          selection.to,
          ' '
        );

        console.log('[WebView] Creating location from iOS menu for:', selectedText);

        // Send request to show geo-mark editor
        sendMessageToNative({
          type: 'showGeoMarkEditor',
          data: {
            placeName: selectedText,
            from: selection.from,
            to: selection.to
          },
          existingLocations: []
        });
      };

      // Expose to window for iOS to call
      window.handleCreateLocation = window.createLocationFromSelection;

      // Listen for messages from React Native and native iOS menu
      window.addEventListener('message', function(event) {
        console.log('[WebView] Received message:', event.data);

        // Handle native iOS menu actions
        if (event.data && event.data.source === 'nativeMenu') {
          console.log('[WebView] Native menu action:', event.data.action);

          if (event.data.action === 'createLocation') {
            console.log('[WebView] Create location from native menu:', event.data.data.selectedText);
            // Trigger the create location function
            if (window.createLocationFromSelection) {
              window.createLocationFromSelection();
            }
            return;
          }

          if (event.data.action === 'addNote') {
            console.log('[WebView] Add note from native menu:', event.data.data.selectedText);
            // Handle add note action
            return;
          }
        }

        try {
          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;

          switch (data.type) {
            case 'setContent':
              console.log('[WebView] Setting content:', JSON.stringify(data.content));
              if (data.content && editorView) {
                try {
                  const doc = schema.nodeFromJSON(data.content);
                  console.log('[WebView] Created doc from JSON:', doc.toString());
                  console.log('[WebView] Doc content:', doc.content.toString());

                  // Check for headings in the document
                  let hasHeadings = false;
                  doc.descendants((node) => {
                    if (node.type.name === 'heading') {
                      console.log('[WebView] Found heading node, level:', node.attrs.level);
                      hasHeadings = true;
                    }
                  });
                  console.log('[WebView] Document has headings:', hasHeadings);

                  // Create new state with fresh plugins
                  const newState = EditorState.create({
                    doc: doc,
                    schema: schema,
                    plugins: [
                      history(),
                      keymap({ 'Mod-z': undo, 'Mod-y': redo }),
                      keymap(baseKeymap)
                    ]
                  });
                  editorView.updateState(newState);
                  editorState = newState;

                  // Send updated toolbar state after loading content
                  const toolbarState = getToolbarState();
                  sendMessageToNative({
                    type: 'toolbarStateChange',
                    state: toolbarState
                  });
                } catch (e) {
                  console.error('[WebView] Error creating doc from JSON:', e);
                  console.error('[WebView] Content was:', JSON.stringify(data.content));
                }
              }
              break;

            case 'setEditable':
              console.log('[WebView] Setting editable:', data.editable);
              if (editorView) {
                editorView.setProps({ editable: () => data.editable });
              }
              break;

            case 'getState':
              console.log('[WebView] Getting state');
              if (editorView) {
                sendMessageToNative({
                  type: 'stateResponse',
                  state: editorView.state.doc.toJSON()
                });
              }
              break;

            case 'createGeoMark':
              console.log('[WebView] Creating geo-mark with data:', data.geoMarkData);
              sendMessageToNative({
                type: 'debug',
                message: '[WebView DEBUG] Received createGeoMark message'
              });

              if (editorView && data.geoMarkData) {
                const { state, dispatch } = editorView;
                const { selection } = state;
                const { from, to } = selection;

                sendMessageToNative({
                  type: 'debug',
                  message: `[WebView DEBUG] Selection from ${from} to ${to}, selected text: "${state.doc.textBetween(from, to, ' ')}"`
                });

                // Create a geoMark NODE (not mark) with the location data
                const geoMarkType = schema.nodes.geoMark;
                if (!geoMarkType) {
                  console.error('[WebView] geoMark node type not found in schema');
                  break;
                }

                // Get the selected text
                const selectedText = state.doc.textBetween(from, to, ' ');

                // Create geoMark node with text content and all attributes
                const geoMarkNode = geoMarkType.create(
                  {
                    geoId: data.geoMarkData.geoId,
                    placeName: data.geoMarkData.placeName,
                    lat: data.geoMarkData.lat,
                    lng: data.geoMarkData.lng,
                    colorIndex: data.geoMarkData.colorIndex || 0,
                    coordSource: data.geoMarkData.coordSource || 'manual',
                    description: data.geoMarkData.description || null,
                    transportFrom: data.geoMarkData.transportFrom || null,
                    transportProfile: data.geoMarkData.transportProfile || null,
                    waypoints: data.geoMarkData.waypoints || null,
                    visitDocument: data.geoMarkData.visitDocument || null,
                    photoName: data.geoMarkData.photoName || null
                  },
                  schema.text(selectedText)
                );

                // Replace the selected text with the geo-mark node
                const tr = state.tr.replaceSelectionWith(geoMarkNode);
                dispatch(tr);

                console.log('[WebView] Geo-mark NODE created successfully');
                sendMessageToNative({
                  type: 'info',
                  message: 'Location created: ' + data.geoMarkData.placeName
                });
              }
              break;

            case 'command':
              console.log('[WebView] Executing command:', data.command, data.params);
              if (!editorView) {
                console.warn('[WebView] Editor view not available');
                break;
              }

              const { state, dispatch } = editorView;
              const { selection } = state;
              const { from, to } = selection;

              switch (data.command) {
                case 'setParagraph':
                  console.log('[WebView] Setting paragraph');
                  const paragraphTr = state.tr.setBlockType(from, to, schema.nodes.paragraph);
                  dispatch(paragraphTr);
                  editorView.focus();
                  break;

                case 'setHeading':
                  const level = data.params?.level || 1;
                  console.log('[WebView] Setting heading level:', level);
                  // Get the current cursor position
                  const cursorPos = state.selection.$from.pos;
                  // Find the bounds of the current block (paragraph)
                  const $pos = state.doc.resolve(cursorPos);
                  const blockStart = $pos.before($pos.depth);
                  const blockEnd = $pos.after($pos.depth);
                  // Only set heading for the current block
                  const headingTr = state.tr.setBlockType(blockStart, blockEnd, schema.nodes.heading, { level });
                  dispatch(headingTr);
                  console.log('[WebView] Set heading from', blockStart, 'to', blockEnd);
                  editorView.focus();
                  break;

                case 'toggleBold':
                  console.log('[WebView] Toggling bold');
                  if (schema.marks.strong) {
                    const hasBold = state.doc.rangeHasMark(from, to, schema.marks.strong);
                    if (hasBold) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.strong));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.strong.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'toggleItalic':
                  console.log('[WebView] Toggling italic');
                  if (schema.marks.em) {
                    const hasItalic = state.doc.rangeHasMark(from, to, schema.marks.em);
                    if (hasItalic) {
                      dispatch(state.tr.removeMark(from, to, schema.marks.em));
                    } else {
                      dispatch(state.tr.addMark(from, to, schema.marks.em.create()));
                    }
                    editorView.focus();
                  }
                  break;

                case 'createGeoMark':
                  // Check if there's selected text
                  if (selection.empty) {
                    console.warn('[WebView] No text selected for geo-mark');
                    sendMessageToNative({
                      type: 'error',
                      message: 'Please select text to create a location'
                    });
                    break;
                  }

                  // Get selected text
                  const selectedText = state.doc.textBetween(from, to, ' ');
                  console.log('[WebView] Selected text:', selectedText);

                  // Send request to show geo-mark editor with selected text
                  sendMessageToNative({
                    type: 'showGeoMarkEditor',
                    data: {
                      placeName: selectedText,
                      from: selection.from,
                      to: selection.to
                    },
                    existingLocations: []
                  });
                  break;

                case 'addComment':
                  // Check if there's selected text
                  if (selection.empty) {
                    console.warn('[WebView] No text selected for comment');
                    sendMessageToNative({
                      type: 'error',
                      message: 'Please select text to add a comment'
                    });
                    break;
                  }

                  // Get selected text
                  const commentSelectedText = state.doc.textBetween(from, to, ' ');
                  console.log('[WebView] Selected text for comment:', commentSelectedText);

                  // Send request to show comment editor
                  sendMessageToNative({
                    type: 'showCommentEditor',
                    data: {
                      selectedText: commentSelectedText,
                      from: selection.from,
                      to: selection.to
                    }
                  });
                  break;

                case 'createComment':
                  // Create a comment mark with the provided data
                  if (data.params && schema.marks.comment) {
                    const commentMark = schema.marks.comment.create({
                      commentId: data.params.commentId,
                      userId: data.params.userId,
                      userName: data.params.userName,
                      content: data.params.content,
                      createdAt: data.params.createdAt,
                      resolved: data.params.resolved || false,
                      replies: data.params.replies || null
                    });

                    const commentTr = state.tr.addMark(
                      data.params.from || from,
                      data.params.to || to,
                      commentMark
                    );
                    dispatch(commentTr);
                    console.log('[WebView] Comment created successfully');
                    editorView.focus();
                  }
                  break;

                case 'updateCommentAIReply':
                  // Update a comment mark's aiReply attribute
                  console.log('[WebView] Updating comment AI reply:', data.commentId);
                  if (data.commentId && data.aiReplyDoc && schema.marks.comment) {
                    let commentFound = false;
                    const updateTr = state.tr;

                    // Find all comment marks in the document
                    state.doc.descendants((node, pos) => {
                      if (!node.isText) return;

                      // Check if this text node has a comment mark with matching ID
                      const commentMark = node.marks.find(
                        mark => mark.type.name === 'comment' && mark.attrs.commentId === data.commentId
                      );

                      if (commentMark) {
                        commentFound = true;
                        const nodeStart = pos;
                        const nodeEnd = pos + node.nodeSize;

                        console.log('[WebView] Found comment mark at', nodeStart, '-', nodeEnd);

                        // Create updated comment mark with aiReply
                        const updatedCommentMark = schema.marks.comment.create({
                          ...commentMark.attrs,
                          aiReply: data.aiReplyDoc
                        });

                        // Remove old mark and add updated one
                        updateTr.removeMark(nodeStart, nodeEnd, commentMark);
                        updateTr.addMark(nodeStart, nodeEnd, updatedCommentMark);

                        console.log('[WebView] Updated comment with AI reply');
                      }
                    });

                    if (commentFound) {
                      dispatch(updateTr);
                      console.log('[WebView] Comment AI reply updated successfully');
                      sendMessageToNative({
                        type: 'info',
                        message: 'AI reply received'
                      });
                    } else {
                      console.warn('[WebView] Comment not found:', data.commentId);
                    }
                  }
                  break;

                case 'focusEditor':
                  console.log('[WebView] Focusing editor');
                  // Focus the editor
                  editorView.focus();
                  // Move cursor to end of document
                  const endPos = state.doc.content.size;
                  const focusTr = state.tr.setSelection(
                    window.PM.state.Selection.near(state.doc.resolve(endPos))
                  );
                  dispatch(focusTr);
                  console.log('[WebView] Editor focused, cursor at end');
                  break;

                case 'insertText':
                  console.log('[WebView] Inserting text:', data.params?.text);
                  // Insert text at current cursor position
                  const text = data.params?.text || '';
                  const insertTextTr = state.tr.insertText(text);
                  dispatch(insertTextTr);
                  console.log('[WebView] Text inserted at pos:', state.selection.$from.pos);
                  break;

                case 'insertParagraph':
                  console.log('[WebView] Inserting paragraph');
                  // Split the current block and reset to paragraph
                  let paraTr = state.tr.split(state.selection.to);
                  // After split, set the new block to paragraph (not heading)
                  const newPos = paraTr.selection.$from.pos;
                  const $newPos = paraTr.doc.resolve(newPos);
                  const newBlockStart = $newPos.before($newPos.depth);
                  const newBlockEnd = $newPos.after($newPos.depth);
                  paraTr = paraTr.setBlockType(newBlockStart, newBlockEnd, schema.nodes.paragraph);
                  dispatch(paraTr);
                  console.log('[WebView] Paragraph split/inserted and reset to paragraph type');
                  break;

                case 'selectBackward':
                  console.log('[WebView] Selecting backward:', data.params?.length);
                  sendMessageToNative({
                    type: 'debug',
                    message: `[WebView DEBUG] selectBackward command received, length: ${data.params?.length}`
                  });

                  try {
                    // Select text backwards from cursor by the specified length
                    const length = data.params?.length || 0;
                    const currentPos = state.selection.to;
                    const startPos = Math.max(0, currentPos - length);

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] Before selection: currentPos=${currentPos}, will select from ${startPos} to ${currentPos}`
                    });

                    const selectTr = state.tr.setSelection(
                      window.PM.state.TextSelection.create(state.doc, startPos, currentPos)
                    );

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] Created selection transaction, about to dispatch`
                    });

                    dispatch(selectTr);

                    sendMessageToNative({
                      type: 'debug',
                      message: `[WebView DEBUG] After selection dispatch: from ${startPos} to ${currentPos}`
                    });
                  } catch (error) {
                    sendMessageToNative({
                      type: 'error',
                      message: `[WebView ERROR] selectBackward failed: ${error.message}`
                    });
                  }
                  break;

                case 'selectRange':
                  console.log('[WebView] Selecting range:', data.params?.from, 'to', data.params?.to);
                  try {
                    const rangeFrom = data.params?.from || 0;
                    const rangeTo = data.params?.to || 0;

                    // Create selection for the specified range
                    const rangeTr = state.tr.setSelection(
                      window.PM.state.TextSelection.create(state.doc, rangeFrom, rangeTo)
                    );
                    dispatch(rangeTr);
                    console.log('[WebView] Range selected from', rangeFrom, 'to', rangeTo);
                  } catch (error) {
                    console.error('[WebView] selectRange failed:', error);
                  }
                  break;

                case 'deleteSelection':
                  console.log('[WebView] Deleting selection');
                  try {
                    // Delete the current selection
                    const deleteTr = state.tr.deleteSelection();
                    dispatch(deleteTr);
                    console.log('[WebView] Selection deleted');
                  } catch (error) {
                    console.error('[WebView] deleteSelection failed:', error);
                  }
                  break;

                case 'showTypingCursor':
                  console.log('[WebView] Showing typing cursor');
                  showTypingCursor();
                  break;

                case 'hideTypingCursor':
                  console.log('[WebView] Hiding typing cursor');
                  hideTypingCursor();
                  break;

                default:
                  console.warn('[WebView] Unknown command:', data.command);
              }
              break;

            case 'startCollaboration':
              console.log('[WebView] Starting collaboration:', data);
              if (editorView && window.io && window.PM.collab) {
                const { serverUrl, documentId, userId, userName } = data;

                // Connect to WebSocket server
                socket = window.io(serverUrl, {
                  transports: ['websocket'],
                  reconnectionDelayMax: 10000
                });

                // Initialize collaboration
                const { CollabConnection, createCollabPlugin } = window.PM.collab;
                collabConnection = new CollabConnection(socket, documentId, userId, userName);
                collabPlugin = createCollabPlugin(collabConnection);

                // Update editor state with collaboration plugin
                const plugins = editorView.state.plugins.filter(p => !p.spec.key || p.spec.key.key !== 'collab');
                plugins.push(collabPlugin);

                const newState = editorView.state.reconfigure({ plugins });
                editorView.updateState(newState);

                // Update UI
                const statusEl = document.getElementById('collab-status');
                statusEl.textContent = 'Connecting...';
                statusEl.className = 'disconnected';

                // Socket event handlers for UI updates
                socket.on('connect', () => {
                  console.log('[WebView] Connected to collaboration server');
                  statusEl.textContent = 'Connected';
                  statusEl.className = 'connected';

                  sendMessageToNative({
                    type: 'collaborationStatus',
                    status: 'connected'
                  });
                });

                socket.on('disconnect', () => {
                  console.log('[WebView] Disconnected from collaboration server');
                  statusEl.textContent = 'Disconnected';
                  statusEl.className = 'disconnected';

                  sendMessageToNative({
                    type: 'collaborationStatus',
                    status: 'disconnected'
                  });
                });

                socket.on('user-joined', ({ userId, userName, userColor }) => {
                  console.log('[WebView] User joined:', userName);
                  updateCollabUsers();
                });

                socket.on('user-left', ({ userId }) => {
                  console.log('[WebView] User left:', userId);
                  updateCollabUsers();
                });

                sendMessageToNative({
                  type: 'collaborationStarted',
                  success: true
                });
              } else {
                console.error('[WebView] Cannot start collaboration - missing dependencies');
                sendMessageToNative({
                  type: 'collaborationStarted',
                  success: false,
                  error: 'Missing Socket.io or collaboration plugin'
                });
              }
              break;

            case 'stopCollaboration':
              console.log('[WebView] Stopping collaboration');
              if (socket) {
                socket.disconnect();
                socket = null;
              }
              if (collabConnection) {
                collabConnection.disconnect();
                collabConnection = null;
              }

              // Remove collaboration plugin
              if (editorView && collabPlugin) {
                const plugins = editorView.state.plugins.filter(p => p !== collabPlugin);
                const newState = editorView.state.reconfigure({ plugins });
                editorView.updateState(newState);
                collabPlugin = null;
              }

              // Update UI
              const statusEl = document.getElementById('collab-status');
              statusEl.textContent = 'Disconnected';
              statusEl.className = 'disconnected';
              document.getElementById('collab-users').innerHTML = '';

              sendMessageToNative({
                type: 'collaborationStopped'
              });
              break;

            case 'applySteps':
              console.log('[WebView] Applying steps from', data.clientID, '- version:', data.version, '- steps:', data.steps.length);
              if (editorView && data.steps && data.steps.length > 0) {
                try {
                  let tr = editorView.state.tr;

                  // Apply each step to the transaction
                  for (const stepJSON of data.steps) {
                    const step = Step.fromJSON(schema, stepJSON);
                    tr.step(step);
                  }

                  // Apply the transaction to update the editor
                  editorView.dispatch(tr);
                  editorState = editorView.state;

                  console.log('[WebView] Successfully applied', data.steps.length, 'steps');

                  // Notify React Native that document changed
                  sendMessageToNative({
                    type: 'documentChange',
                    document: editorView.state.doc.toJSON()
                  });
                } catch (e) {
                  console.error('[WebView] Error applying steps:', e);
                }
              }
              break;

            default:
              console.warn('[WebView] Unknown message type:', data.type);
          }
        } catch (e) {
          console.error('[WebView] Error handling message:', e);
        }
      });
    }
  </script>
</body>
</html>
