// Auto-generated file - do not edit directly
// Generated from: prosemirror-editor-bundled.html + prosemirror-bundle-src.js
// To rebuild: node build-prosemirror.js

export default "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n  <title>ProseMirror Editor</title>\n  <!-- Socket.io client for collaboration -->\n  <script src=\"https://cdn.socket.io/4.6.1/socket.io.min.js\"></script>\n  <style>\n    * {\n      box-sizing: border-box;\n    }\n\n    html, body {\n      margin: 0;\n      padding: 0;\n      height: 100%;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      background: #ffffff;\n    }\n\n    #editor-container {\n      padding: 0;\n      height: 100%;\n      background: white;\n    }\n\n    .ProseMirror {\n      outline: none;\n      padding: 0;\n      min-height: 100%;\n      background: white;\n      border: none;\n      border-radius: 0;\n      caret-color: #3b82f6; /* Bright blue cursor */\n      -webkit-text-size-adjust: 100%;\n      -webkit-tap-highlight-color: transparent;\n    }\n\n    /* Disable spell checking underlines */\n    .ProseMirror * {\n      -webkit-text-decoration-skip: none;\n      text-decoration-skip-ink: none;\n    }\n\n    /* Make cursor/caret more visible with animation */\n    @keyframes blink {\n      0%, 49% { opacity: 1; }\n      50%, 100% { opacity: 0; }\n    }\n\n    /* Enhanced selection highlighting */\n    .ProseMirror ::selection {\n      background-color: #3b82f6; /* Bright blue */\n      color: white;\n    }\n\n    .ProseMirror ::-moz-selection {\n      background-color: #3b82f6;\n      color: white;\n    }\n\n    /* ProseMirror's own selection styling */\n    .ProseMirror-selectednode {\n      outline: 3px solid #3b82f6;\n      outline-offset: 2px;\n    }\n\n    /* Make the gapcursor more visible */\n    .ProseMirror-gapcursor {\n      display: block;\n      pointer-events: none;\n      position: absolute;\n    }\n\n    .ProseMirror-gapcursor:after {\n      content: \"\";\n      display: block;\n      position: absolute;\n      top: -2px;\n      width: 20px;\n      border-top: 2px solid #3b82f6;\n      animation: blink 1.2s step-end infinite;\n    }\n\n    /* Custom typing cursor indicator */\n    #typing-cursor {\n      position: absolute;\n      width: 3px;\n      background-color: #EF4444; /* Bright red for visibility */\n      pointer-events: none;\n      z-index: 1000;\n      animation: blink 0.8s ease-in-out infinite;\n      display: none; /* Hidden by default, shown during typing */\n      box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);\n    }\n\n    #typing-cursor.visible {\n      display: block;\n    }\n\n    /* Collaboration cursors and selections */\n    .collab-cursor {\n      position: relative;\n      display: inline-block;\n      width: 0;\n      height: 1em;\n    }\n\n    .collab-cursor-label {\n      position: absolute;\n      bottom: 100%;\n      left: -2px;\n      background-color: #3b82f6;\n      color: white;\n      font-size: 11px;\n      padding: 2px 4px;\n      border-radius: 3px;\n      white-space: nowrap;\n      pointer-events: none;\n      z-index: 10;\n    }\n\n    .collab-selection {\n      background-color: rgba(59, 130, 246, 0.2);\n    }\n\n    /* Collaboration status indicator */\n    #collab-status {\n      position: fixed;\n      top: 10px;\n      right: 10px;\n      padding: 4px 8px;\n      background: rgba(0, 0, 0, 0.8);\n      color: white;\n      font-size: 11px;\n      border-radius: 4px;\n      z-index: 100;\n      display: none;\n    }\n\n    #collab-status.connected {\n      background: rgba(16, 185, 129, 0.9);\n      display: block;\n    }\n\n    #collab-status.disconnected {\n      background: rgba(239, 68, 68, 0.9);\n      display: block;\n    }\n\n    #collab-users {\n      position: fixed;\n      top: 10px;\n      left: 10px;\n      display: flex;\n      gap: 8px;\n      z-index: 100;\n    }\n\n    .collab-user {\n      padding: 4px 8px;\n      border-radius: 4px;\n      font-size: 11px;\n      color: white;\n      font-weight: 500;\n    }\n\n    .ProseMirror h1 {\n      font-size: 2em;\n      margin: 0.67em 0;\n      font-weight: bold;\n    }\n\n    .ProseMirror h2 {\n      font-size: 1.5em;\n      margin: 0.75em 0;\n      font-weight: bold;\n    }\n\n    .ProseMirror p {\n      margin: 1em 0;\n    }\n\n    .ProseMirror ul, .ProseMirror ol {\n      padding-left: 30px;\n    }\n\n    .ProseMirror strong {\n      font-weight: bold;\n    }\n\n    .ProseMirror em {\n      font-style: italic;\n    }\n\n    .ProseMirror .geo-mark {\n      background-color: rgba(59, 130, 246, 0.2);\n      padding: 2px 4px;\n      border-radius: 3px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      text-decoration: none !important;\n      border: none !important;\n      border-bottom: none !important;\n      -webkit-text-decoration: none !important;\n    }\n\n    .ProseMirror .geo-mark:hover {\n      background-color: rgba(59, 130, 246, 0.3);\n    }\n\n    .ProseMirror .comment-mark {\n      background-color: rgba(251, 191, 36, 0.3);\n      border-bottom: 2px solid rgba(251, 191, 36, 0.6);\n      cursor: pointer;\n      padding: 1px 0;\n      transition: all 0.2s ease;\n    }\n\n    .ProseMirror .comment-mark:hover {\n      background-color: rgba(251, 191, 36, 0.4);\n      border-bottom-color: rgba(251, 191, 36, 0.9);\n    }\n\n    .ProseMirror .comment-mark[data-resolved=\"true\"] {\n      background-color: rgba(156, 163, 175, 0.2);\n      border-bottom-color: rgba(156, 163, 175, 0.4);\n      opacity: 0.7;\n    }\n\n    .status-bar {\n      display: none; /* Hidden to save space */\n    }\n\n    #editor-container {\n      padding: 0;\n      height: 100%;\n      overflow-y: auto;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"status-bar\" id=\"status\">Loading ProseMirror...</div>\n  <div id=\"collab-status\">Disconnected</div>\n  <div id=\"collab-users\"></div>\n  <div id=\"editor-container\"></div>\n  <div id=\"typing-cursor\"></div>\n\n  <script>\n    console.log('[WebView] Script starting...');\n\n    // Set up message handler\n    function sendMessageToNative(message) {\n      try {\n        const json = JSON.stringify(message);\n        if (window.ReactNativeWebView) {\n          // Native WebView (iOS/Android)\n          window.ReactNativeWebView.postMessage(json);\n        } else if (window.parent && window.parent !== window) {\n          // Web iframe\n          window.parent.postMessage(json, '*');\n        } else {\n          console.warn('[WebView] No message handler available');\n        }\n      } catch (e) {\n        console.error('[WebView] Error sending message:', e);\n      }\n    }\n\n    function setStatus(text, isError = false) {\n      const statusEl = document.getElementById('status');\n      statusEl.textContent = text;\n      statusEl.className = isError ? 'status-bar error' : 'status-bar';\n    }\n\n    // Handle errors\n    window.addEventListener('error', function(e) {\n      console.error('[WebView] Error:', e.message, e.filename, e.lineno);\n      setStatus('Error: ' + e.message, true);\n      sendMessageToNative({\n        type: 'error',\n        message: e.message,\n        filename: e.filename,\n        lineno: e.lineno\n      });\n    });\n\n    // Load ProseMirror bundle\n    console.log('[WebView] About to load ProseMirror bundle...');\n    setStatus('Loading ProseMirror bundle...');\n  </script>\n\n  <!-- INLINE PROSEMIRROR BUNDLE WILL BE INSERTED HERE -->\n  <script id=\"prosemirror-bundle\">\n\"use strict\";\nvar PMBundle = (() => {\n  // node_modules/orderedmap/dist/index.js\n  function OrderedMap(content) {\n    this.content = content;\n  }\n  OrderedMap.prototype = {\n    constructor: OrderedMap,\n    find: function(key) {\n      for (var i = 0; i < this.content.length; i += 2)\n        if (this.content[i] === key) return i;\n      return -1;\n    },\n    // :: (string) → ?any\n    // Retrieve the value stored under `key`, or return undefined when\n    // no such key exists.\n    get: function(key) {\n      var found2 = this.find(key);\n      return found2 == -1 ? void 0 : this.content[found2 + 1];\n    },\n    // :: (string, any, ?string) → OrderedMap\n    // Create a new map by replacing the value of `key` with a new\n    // value, or adding a binding to the end of the map. If `newKey` is\n    // given, the key of the binding will be replaced with that key.\n    update: function(key, value, newKey) {\n      var self = newKey && newKey != key ? this.remove(newKey) : this;\n      var found2 = self.find(key), content = self.content.slice();\n      if (found2 == -1) {\n        content.push(newKey || key, value);\n      } else {\n        content[found2 + 1] = value;\n        if (newKey) content[found2] = newKey;\n      }\n      return new OrderedMap(content);\n    },\n    // :: (string) → OrderedMap\n    // Return a map with the given key removed, if it existed.\n    remove: function(key) {\n      var found2 = this.find(key);\n      if (found2 == -1) return this;\n      var content = this.content.slice();\n      content.splice(found2, 2);\n      return new OrderedMap(content);\n    },\n    // :: (string, any) → OrderedMap\n    // Add a new key to the start of the map.\n    addToStart: function(key, value) {\n      return new OrderedMap([key, value].concat(this.remove(key).content));\n    },\n    // :: (string, any) → OrderedMap\n    // Add a new key to the end of the map.\n    addToEnd: function(key, value) {\n      var content = this.remove(key).content.slice();\n      content.push(key, value);\n      return new OrderedMap(content);\n    },\n    // :: (string, string, any) → OrderedMap\n    // Add a key after the given key. If `place` is not found, the new\n    // key is added to the end.\n    addBefore: function(place, key, value) {\n      var without = this.remove(key), content = without.content.slice();\n      var found2 = without.find(place);\n      content.splice(found2 == -1 ? content.length : found2, 0, key, value);\n      return new OrderedMap(content);\n    },\n    // :: ((key: string, value: any))\n    // Call the given function for each key/value pair in the map, in\n    // order.\n    forEach: function(f) {\n      for (var i = 0; i < this.content.length; i += 2)\n        f(this.content[i], this.content[i + 1]);\n    },\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a new map by prepending the keys in this map that don't\n    // appear in `map` before the keys in `map`.\n    prepend: function(map2) {\n      map2 = OrderedMap.from(map2);\n      if (!map2.size) return this;\n      return new OrderedMap(map2.content.concat(this.subtract(map2).content));\n    },\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a new map by appending the keys in this map that don't\n    // appear in `map` after the keys in `map`.\n    append: function(map2) {\n      map2 = OrderedMap.from(map2);\n      if (!map2.size) return this;\n      return new OrderedMap(this.subtract(map2).content.concat(map2.content));\n    },\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a map containing all the keys in this map that don't\n    // appear in `map`.\n    subtract: function(map2) {\n      var result = this;\n      map2 = OrderedMap.from(map2);\n      for (var i = 0; i < map2.content.length; i += 2)\n        result = result.remove(map2.content[i]);\n      return result;\n    },\n    // :: () → Object\n    // Turn ordered map into a plain object.\n    toObject: function() {\n      var result = {};\n      this.forEach(function(key, value) {\n        result[key] = value;\n      });\n      return result;\n    },\n    // :: number\n    // The amount of keys in this map.\n    get size() {\n      return this.content.length >> 1;\n    }\n  };\n  OrderedMap.from = function(value) {\n    if (value instanceof OrderedMap) return value;\n    var content = [];\n    if (value) for (var prop in value) content.push(prop, value[prop]);\n    return new OrderedMap(content);\n  };\n  var dist_default = OrderedMap;\n\n  // node_modules/prosemirror-model/dist/index.js\n  function findDiffStart(a, b, pos) {\n    for (let i = 0; ; i++) {\n      if (i == a.childCount || i == b.childCount)\n        return a.childCount == b.childCount ? null : pos;\n      let childA = a.child(i), childB = b.child(i);\n      if (childA == childB) {\n        pos += childA.nodeSize;\n        continue;\n      }\n      if (!childA.sameMarkup(childB))\n        return pos;\n      if (childA.isText && childA.text != childB.text) {\n        for (let j = 0; childA.text[j] == childB.text[j]; j++)\n          pos++;\n        return pos;\n      }\n      if (childA.content.size || childB.content.size) {\n        let inner = findDiffStart(childA.content, childB.content, pos + 1);\n        if (inner != null)\n          return inner;\n      }\n      pos += childA.nodeSize;\n    }\n  }\n  function findDiffEnd(a, b, posA, posB) {\n    for (let iA = a.childCount, iB = b.childCount; ; ) {\n      if (iA == 0 || iB == 0)\n        return iA == iB ? null : { a: posA, b: posB };\n      let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n      if (childA == childB) {\n        posA -= size;\n        posB -= size;\n        continue;\n      }\n      if (!childA.sameMarkup(childB))\n        return { a: posA, b: posB };\n      if (childA.isText && childA.text != childB.text) {\n        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n          same++;\n          posA--;\n          posB--;\n        }\n        return { a: posA, b: posB };\n      }\n      if (childA.content.size || childB.content.size) {\n        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n        if (inner)\n          return inner;\n      }\n      posA -= size;\n      posB -= size;\n    }\n  }\n  var Fragment = class _Fragment {\n    /**\n    @internal\n    */\n    constructor(content, size) {\n      this.content = content;\n      this.size = size || 0;\n      if (size == null)\n        for (let i = 0; i < content.length; i++)\n          this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn't descend\n    into a node when the callback returns `false`.\n    */\n    nodesBetween(from2, to, f, nodeStart = 0, parent) {\n      for (let i = 0, pos = 0; pos < to; i++) {\n        let child = this.content[i], end = pos + child.nodeSize;\n        if (end > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n          let start = pos + 1;\n          child.nodesBetween(Math.max(0, from2 - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n        }\n        pos = end;\n      }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */\n    descendants(f) {\n      this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */\n    textBetween(from2, to, blockSeparator, leafText) {\n      let text = \"\", first = true;\n      this.nodesBetween(from2, to, (node, pos) => {\n        let nodeText = node.isText ? node.text.slice(Math.max(from2, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n          if (first)\n            first = false;\n          else\n            text += blockSeparator;\n        }\n        text += nodeText;\n      }, 0);\n      return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */\n    append(other) {\n      if (!other.size)\n        return this;\n      if (!this.size)\n        return other;\n      let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n      if (last.isText && last.sameMarkup(first)) {\n        content[content.length - 1] = last.withText(last.text + first.text);\n        i = 1;\n      }\n      for (; i < other.content.length; i++)\n        content.push(other.content[i]);\n      return new _Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */\n    cut(from2, to = this.size) {\n      if (from2 == 0 && to == this.size)\n        return this;\n      let result = [], size = 0;\n      if (to > from2)\n        for (let i = 0, pos = 0; pos < to; i++) {\n          let child = this.content[i], end = pos + child.nodeSize;\n          if (end > from2) {\n            if (pos < from2 || end > to) {\n              if (child.isText)\n                child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));\n              else\n                child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));\n            }\n            result.push(child);\n            size += child.nodeSize;\n          }\n          pos = end;\n        }\n      return new _Fragment(result, size);\n    }\n    /**\n    @internal\n    */\n    cutByIndex(from2, to) {\n      if (from2 == to)\n        return _Fragment.empty;\n      if (from2 == 0 && to == this.content.length)\n        return this;\n      return new _Fragment(this.content.slice(from2, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */\n    replaceChild(index, node) {\n      let current = this.content[index];\n      if (current == node)\n        return this;\n      let copy2 = this.content.slice();\n      let size = this.size + node.nodeSize - current.nodeSize;\n      copy2[index] = node;\n      return new _Fragment(copy2, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */\n    addToStart(node) {\n      return new _Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */\n    addToEnd(node) {\n      return new _Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */\n    eq(other) {\n      if (this.content.length != other.content.length)\n        return false;\n      for (let i = 0; i < this.content.length; i++)\n        if (!this.content[i].eq(other.content[i]))\n          return false;\n      return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */\n    get firstChild() {\n      return this.content.length ? this.content[0] : null;\n    }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */\n    get lastChild() {\n      return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n    /**\n    The number of child nodes in this fragment.\n    */\n    get childCount() {\n      return this.content.length;\n    }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */\n    child(index) {\n      let found2 = this.content[index];\n      if (!found2)\n        throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n      return found2;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) {\n      return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) {\n      for (let i = 0, p = 0; i < this.content.length; i++) {\n        let child = this.content[i];\n        f(child, p, i);\n        p += child.nodeSize;\n      }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */\n    findDiffStart(other, pos = 0) {\n      return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */\n    findDiffEnd(other, pos = this.size, otherPos = other.size) {\n      return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. @internal\n    */\n    findIndex(pos) {\n      if (pos == 0)\n        return retIndex(0, pos);\n      if (pos == this.size)\n        return retIndex(this.content.length, pos);\n      if (pos > this.size || pos < 0)\n        throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n      for (let i = 0, curPos = 0; ; i++) {\n        let cur = this.child(i), end = curPos + cur.nodeSize;\n        if (end >= pos) {\n          if (end == pos)\n            return retIndex(i + 1, end);\n          return retIndex(i, curPos);\n        }\n        curPos = end;\n      }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */\n    toString() {\n      return \"<\" + this.toStringInner() + \">\";\n    }\n    /**\n    @internal\n    */\n    toStringInner() {\n      return this.content.join(\", \");\n    }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */\n    toJSON() {\n      return this.content.length ? this.content.map((n) => n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */\n    static fromJSON(schema2, value) {\n      if (!value)\n        return _Fragment.empty;\n      if (!Array.isArray(value))\n        throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n      return new _Fragment(value.map(schema2.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */\n    static fromArray(array) {\n      if (!array.length)\n        return _Fragment.empty;\n      let joined, size = 0;\n      for (let i = 0; i < array.length; i++) {\n        let node = array[i];\n        size += node.nodeSize;\n        if (i && node.isText && array[i - 1].sameMarkup(node)) {\n          if (!joined)\n            joined = array.slice(0, i);\n          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n        } else if (joined) {\n          joined.push(node);\n        }\n      }\n      return new _Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */\n    static from(nodes2) {\n      if (!nodes2)\n        return _Fragment.empty;\n      if (nodes2 instanceof _Fragment)\n        return nodes2;\n      if (Array.isArray(nodes2))\n        return this.fromArray(nodes2);\n      if (nodes2.attrs)\n        return new _Fragment([nodes2], nodes2.nodeSize);\n      throw new RangeError(\"Can not convert \" + nodes2 + \" to a Fragment\" + (nodes2.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n  };\n  Fragment.empty = new Fragment([], 0);\n  var found = { index: 0, offset: 0 };\n  function retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n  }\n  function compareDeep(a, b) {\n    if (a === b)\n      return true;\n    if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\"))\n      return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array)\n      return false;\n    if (array) {\n      if (a.length != b.length)\n        return false;\n      for (let i = 0; i < a.length; i++)\n        if (!compareDeep(a[i], b[i]))\n          return false;\n    } else {\n      for (let p in a)\n        if (!(p in b) || !compareDeep(a[p], b[p]))\n          return false;\n      for (let p in b)\n        if (!(p in a))\n          return false;\n    }\n    return true;\n  }\n  var Mark = class _Mark {\n    /**\n    @internal\n    */\n    constructor(type, attrs) {\n      this.type = type;\n      this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */\n    addToSet(set) {\n      let copy2, placed = false;\n      for (let i = 0; i < set.length; i++) {\n        let other = set[i];\n        if (this.eq(other))\n          return set;\n        if (this.type.excludes(other.type)) {\n          if (!copy2)\n            copy2 = set.slice(0, i);\n        } else if (other.type.excludes(this.type)) {\n          return set;\n        } else {\n          if (!placed && other.type.rank > this.type.rank) {\n            if (!copy2)\n              copy2 = set.slice(0, i);\n            copy2.push(this);\n            placed = true;\n          }\n          if (copy2)\n            copy2.push(other);\n        }\n      }\n      if (!copy2)\n        copy2 = set.slice();\n      if (!placed)\n        copy2.push(this);\n      return copy2;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */\n    removeFromSet(set) {\n      for (let i = 0; i < set.length; i++)\n        if (this.eq(set[i]))\n          return set.slice(0, i).concat(set.slice(i + 1));\n      return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */\n    isInSet(set) {\n      for (let i = 0; i < set.length; i++)\n        if (this.eq(set[i]))\n          return true;\n      return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */\n    eq(other) {\n      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */\n    toJSON() {\n      let obj = { type: this.type.name };\n      for (let _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */\n    static fromJSON(schema2, json) {\n      if (!json)\n        throw new RangeError(\"Invalid input for Mark.fromJSON\");\n      let type = schema2.marks[json.type];\n      if (!type)\n        throw new RangeError(`There is no mark type ${json.type} in this schema`);\n      let mark = type.create(json.attrs);\n      type.checkAttrs(mark.attrs);\n      return mark;\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */\n    static sameSet(a, b) {\n      if (a == b)\n        return true;\n      if (a.length != b.length)\n        return false;\n      for (let i = 0; i < a.length; i++)\n        if (!a[i].eq(b[i]))\n          return false;\n      return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */\n    static setFrom(marks2) {\n      if (!marks2 || Array.isArray(marks2) && marks2.length == 0)\n        return _Mark.none;\n      if (marks2 instanceof _Mark)\n        return [marks2];\n      let copy2 = marks2.slice();\n      copy2.sort((a, b) => a.type.rank - b.type.rank);\n      return copy2;\n    }\n  };\n  Mark.none = [];\n  var ReplaceError = class extends Error {\n  };\n  var Slice = class _Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can't be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema's content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */\n    constructor(content, openStart, openEnd) {\n      this.content = content;\n      this.openStart = openStart;\n      this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */\n    get size() {\n      return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */\n    insertAt(pos, fragment) {\n      let content = insertInto(this.content, pos + this.openStart, fragment);\n      return content && new _Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */\n    removeBetween(from2, to) {\n      return new _Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */\n    eq(other) {\n      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */\n    toString() {\n      return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */\n    toJSON() {\n      if (!this.content.size)\n        return null;\n      let json = { content: this.content.toJSON() };\n      if (this.openStart > 0)\n        json.openStart = this.openStart;\n      if (this.openEnd > 0)\n        json.openEnd = this.openEnd;\n      return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */\n    static fromJSON(schema2, json) {\n      if (!json)\n        return _Slice.empty;\n      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n      if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n        throw new RangeError(\"Invalid input for Slice.fromJSON\");\n      return new _Slice(Fragment.fromJSON(schema2, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */\n    static maxOpen(fragment, openIsolating = true) {\n      let openStart = 0, openEnd = 0;\n      for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)\n        openStart++;\n      for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)\n        openEnd++;\n      return new _Slice(fragment, openStart, openEnd);\n    }\n  };\n  Slice.empty = new Slice(Fragment.empty, 0, 0);\n  function removeRange(content, from2, to) {\n    let { index, offset } = content.findIndex(from2), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from2 || child.isText) {\n      if (offsetTo != to && !content.child(indexTo).isText)\n        throw new RangeError(\"Removing non-flat range\");\n      return content.cut(0, from2).append(content.cut(to));\n    }\n    if (index != indexTo)\n      throw new RangeError(\"Removing non-flat range\");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from2 - offset - 1, to - offset - 1)));\n  }\n  function insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n      if (parent && !parent.canReplace(index, index, insert))\n        return null;\n      return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert, child);\n    return inner && content.replaceChild(index, child.copy(inner));\n  }\n  function replace($from, $to, slice2) {\n    if (slice2.openStart > $from.depth)\n      throw new ReplaceError(\"Inserted content deeper than insertion position\");\n    if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)\n      throw new ReplaceError(\"Inconsistent open depths\");\n    return replaceOuter($from, $to, slice2, 0);\n  }\n  function replaceOuter($from, $to, slice2, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {\n      let inner = replaceOuter($from, $to, slice2, depth + 1);\n      return node.copy(node.content.replaceChild(index, inner));\n    } else if (!slice2.content.size) {\n      return close(node, replaceTwoWay($from, $to, depth));\n    } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {\n      let parent = $from.parent, content = parent.content;\n      return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));\n    } else {\n      let { start, end } = prepareSliceForReplace(slice2, $from);\n      return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n  }\n  function checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type))\n      throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n  }\n  function joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n  }\n  function addNode(child, target) {\n    let last = target.length - 1;\n    if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n      target[last] = child.withText(target[last].text + child.text);\n    else\n      target.push(child);\n  }\n  function addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n      startIndex = $start.index(depth);\n      if ($start.depth > depth) {\n        startIndex++;\n      } else if ($start.textOffset) {\n        addNode($start.nodeAfter, target);\n        startIndex++;\n      }\n    }\n    for (let i = startIndex; i < endIndex; i++)\n      addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset)\n      addNode($end.nodeBefore, target);\n  }\n  function close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n  }\n  function replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n      checkJoin(openStart, openEnd);\n      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    } else {\n      if (openStart)\n        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n      addRange($start, $end, depth, content);\n      if (openEnd)\n        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n  }\n  function replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n      let type = joinable($from, $to, depth + 1);\n      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n  }\n  function prepareSliceForReplace(slice2, $along) {\n    let extra = $along.depth - slice2.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice2.content);\n    for (let i = extra - 1; i >= 0; i--)\n      node = $along.node(i).copy(Fragment.from(node));\n    return {\n      start: node.resolveNoCache(slice2.openStart + extra),\n      end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)\n    };\n  }\n  var ResolvedPos = class _ResolvedPos {\n    /**\n    @internal\n    */\n    constructor(pos, path, parentOffset) {\n      this.pos = pos;\n      this.path = path;\n      this.parentOffset = parentOffset;\n      this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */\n    resolveDepth(val) {\n      if (val == null)\n        return this.depth;\n      if (val < 0)\n        return this.depth + val;\n      return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */\n    get parent() {\n      return this.node(this.depth);\n    }\n    /**\n    The root node in which the position was resolved.\n    */\n    get doc() {\n      return this.node(0);\n    }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */\n    node(depth) {\n      return this.path[this.resolveDepth(depth) * 3];\n    }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */\n    index(depth) {\n      return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */\n    indexAfter(depth) {\n      depth = this.resolveDepth(depth);\n      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */\n    start(depth) {\n      depth = this.resolveDepth(depth);\n      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */\n    end(depth) {\n      depth = this.resolveDepth(depth);\n      return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */\n    before(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth)\n        throw new RangeError(\"There is no position before the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */\n    after(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth)\n        throw new RangeError(\"There is no position after the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */\n    get textOffset() {\n      return this.pos - this.path[this.path.length - 1];\n    }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */\n    get nodeAfter() {\n      let parent = this.parent, index = this.index(this.depth);\n      if (index == parent.childCount)\n        return null;\n      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n      return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */\n    get nodeBefore() {\n      let index = this.index(this.depth);\n      let dOff = this.pos - this.path[this.path.length - 1];\n      if (dOff)\n        return this.parent.child(index).cut(0, dOff);\n      return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */\n    posAtIndex(index, depth) {\n      depth = this.resolveDepth(depth);\n      let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n      for (let i = 0; i < index; i++)\n        pos += node.child(i).nodeSize;\n      return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */\n    marks() {\n      let parent = this.parent, index = this.index();\n      if (parent.content.size == 0)\n        return Mark.none;\n      if (this.textOffset)\n        return parent.child(index).marks;\n      let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n      if (!main) {\n        let tmp = main;\n        main = other;\n        other = tmp;\n      }\n      let marks2 = main.marks;\n      for (var i = 0; i < marks2.length; i++)\n        if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks)))\n          marks2 = marks2[i--].removeFromSet(marks2);\n      return marks2;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */\n    marksAcross($end) {\n      let after = this.parent.maybeChild(this.index());\n      if (!after || !after.isInline)\n        return null;\n      let marks2 = after.marks, next = $end.parent.maybeChild($end.index());\n      for (var i = 0; i < marks2.length; i++)\n        if (marks2[i].type.spec.inclusive === false && (!next || !marks2[i].isInSet(next.marks)))\n          marks2 = marks2[i--].removeFromSet(marks2);\n      return marks2;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */\n    sharedDepth(pos) {\n      for (let depth = this.depth; depth > 0; depth--)\n        if (this.start(depth) <= pos && this.end(depth) >= pos)\n          return depth;\n      return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */\n    blockRange(other = this, pred) {\n      if (other.pos < this.pos)\n        return other.blockRange(this);\n      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n          return new NodeRange(this, other, d);\n      return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */\n    sameParent(other) {\n      return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */\n    max(other) {\n      return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */\n    min(other) {\n      return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */\n    toString() {\n      let str = \"\";\n      for (let i = 1; i <= this.depth; i++)\n        str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n      return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */\n    static resolve(doc3, pos) {\n      if (!(pos >= 0 && pos <= doc3.content.size))\n        throw new RangeError(\"Position \" + pos + \" out of range\");\n      let path = [];\n      let start = 0, parentOffset = pos;\n      for (let node = doc3; ; ) {\n        let { index, offset } = node.content.findIndex(parentOffset);\n        let rem = parentOffset - offset;\n        path.push(node, index, start + offset);\n        if (!rem)\n          break;\n        node = node.child(index);\n        if (node.isText)\n          break;\n        parentOffset = rem - 1;\n        start += offset + 1;\n      }\n      return new _ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */\n    static resolveCached(doc3, pos) {\n      let cache = resolveCache.get(doc3);\n      if (cache) {\n        for (let i = 0; i < cache.elts.length; i++) {\n          let elt = cache.elts[i];\n          if (elt.pos == pos)\n            return elt;\n        }\n      } else {\n        resolveCache.set(doc3, cache = new ResolveCache());\n      }\n      let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc3, pos);\n      cache.i = (cache.i + 1) % resolveCacheSize;\n      return result;\n    }\n  };\n  var ResolveCache = class {\n    constructor() {\n      this.elts = [];\n      this.i = 0;\n    }\n  };\n  var resolveCacheSize = 12;\n  var resolveCache = /* @__PURE__ */ new WeakMap();\n  var NodeRange = class {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */\n    constructor($from, $to, depth) {\n      this.$from = $from;\n      this.$to = $to;\n      this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */\n    get start() {\n      return this.$from.before(this.depth + 1);\n    }\n    /**\n    The position at the end of the range.\n    */\n    get end() {\n      return this.$to.after(this.depth + 1);\n    }\n    /**\n    The parent node that the range points into.\n    */\n    get parent() {\n      return this.$from.node(this.depth);\n    }\n    /**\n    The start index of the range in the parent node.\n    */\n    get startIndex() {\n      return this.$from.index(this.depth);\n    }\n    /**\n    The end index of the range in the parent node.\n    */\n    get endIndex() {\n      return this.$to.indexAfter(this.depth);\n    }\n  };\n  var emptyAttrs = /* @__PURE__ */ Object.create(null);\n  var Node = class _Node {\n    /**\n    @internal\n    */\n    constructor(type, attrs, content, marks2 = Mark.none) {\n      this.type = type;\n      this.attrs = attrs;\n      this.marks = marks2;\n      this.content = content || Fragment.empty;\n    }\n    /**\n    The array of this node's child nodes.\n    */\n    get children() {\n      return this.content.content;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */\n    get nodeSize() {\n      return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n    /**\n    The number of children that the node has.\n    */\n    get childCount() {\n      return this.content.childCount;\n    }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */\n    child(index) {\n      return this.content.child(index);\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) {\n      return this.content.maybeChild(index);\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) {\n      this.content.forEach(f);\n    }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */\n    nodesBetween(from2, to, f, startPos = 0) {\n      this.content.nodesBetween(from2, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */\n    descendants(f) {\n      this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */\n    get textContent() {\n      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.\n    */\n    textBetween(from2, to, blockSeparator, leafText) {\n      return this.content.textBetween(from2, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */\n    get firstChild() {\n      return this.content.firstChild;\n    }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */\n    get lastChild() {\n      return this.content.lastChild;\n    }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */\n    eq(other) {\n      return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */\n    sameMarkup(other) {\n      return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */\n    hasMarkup(type, attrs, marks2) {\n      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks2 || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */\n    copy(content = null) {\n      if (content == this.content)\n        return this;\n      return new _Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */\n    mark(marks2) {\n      return marks2 == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks2);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */\n    cut(from2, to = this.content.size) {\n      if (from2 == 0 && to == this.content.size)\n        return this;\n      return this.copy(this.content.cut(from2, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */\n    slice(from2, to = this.content.size, includeParents = false) {\n      if (from2 == to)\n        return Slice.empty;\n      let $from = this.resolve(from2), $to = this.resolve(to);\n      let depth = includeParents ? 0 : $from.sharedDepth(to);\n      let start = $from.start(depth), node = $from.node(depth);\n      let content = node.content.cut($from.pos - start, $to.pos - start);\n      return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */\n    replace(from2, to, slice2) {\n      return replace(this.resolve(from2), this.resolve(to), slice2);\n    }\n    /**\n    Find the node directly after the given position.\n    */\n    nodeAt(pos) {\n      for (let node = this; ; ) {\n        let { index, offset } = node.content.findIndex(pos);\n        node = node.maybeChild(index);\n        if (!node)\n          return null;\n        if (offset == pos || node.isText)\n          return node;\n        pos -= offset + 1;\n      }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childAfter(pos) {\n      let { index, offset } = this.content.findIndex(pos);\n      return { node: this.content.maybeChild(index), index, offset };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childBefore(pos) {\n      if (pos == 0)\n        return { node: null, index: 0, offset: 0 };\n      let { index, offset } = this.content.findIndex(pos);\n      if (offset < pos)\n        return { node: this.content.child(index), index, offset };\n      let node = this.content.child(index - 1);\n      return { node, index: index - 1, offset: offset - node.nodeSize };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */\n    resolve(pos) {\n      return ResolvedPos.resolveCached(this, pos);\n    }\n    /**\n    @internal\n    */\n    resolveNoCache(pos) {\n      return ResolvedPos.resolve(this, pos);\n    }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */\n    rangeHasMark(from2, to, type) {\n      let found2 = false;\n      if (to > from2)\n        this.nodesBetween(from2, to, (node) => {\n          if (type.isInSet(node.marks))\n            found2 = true;\n          return !found2;\n        });\n      return found2;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */\n    get isBlock() {\n      return this.type.isBlock;\n    }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */\n    get isTextblock() {\n      return this.type.isTextblock;\n    }\n    /**\n    True when this node allows inline content.\n    */\n    get inlineContent() {\n      return this.type.inlineContent;\n    }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */\n    get isInline() {\n      return this.type.isInline;\n    }\n    /**\n    True when this is a text node.\n    */\n    get isText() {\n      return this.type.isText;\n    }\n    /**\n    True when this is a leaf node.\n    */\n    get isLeaf() {\n      return this.type.isLeaf;\n    }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */\n    get isAtom() {\n      return this.type.isAtom;\n    }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */\n    toString() {\n      if (this.type.spec.toDebugString)\n        return this.type.spec.toDebugString(this);\n      let name = this.type.name;\n      if (this.content.size)\n        name += \"(\" + this.content.toStringInner() + \")\";\n      return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */\n    contentMatchAt(index) {\n      let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n      if (!match)\n        throw new Error(\"Called contentMatchAt on a node with invalid content\");\n      return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */\n    canReplace(from2, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n      let one = this.contentMatchAt(from2).matchFragment(replacement, start, end);\n      let two = one && one.matchFragment(this.content, to);\n      if (!two || !two.validEnd)\n        return false;\n      for (let i = start; i < end; i++)\n        if (!this.type.allowsMarks(replacement.child(i).marks))\n          return false;\n      return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */\n    canReplaceWith(from2, to, type, marks2) {\n      if (marks2 && !this.type.allowsMarks(marks2))\n        return false;\n      let start = this.contentMatchAt(from2).matchType(type);\n      let end = start && start.matchFragment(this.content, to);\n      return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */\n    canAppend(other) {\n      if (other.content.size)\n        return this.canReplace(this.childCount, this.childCount, other.content);\n      else\n        return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise an exception when they do not.\n    */\n    check() {\n      this.type.checkContent(this.content);\n      this.type.checkAttrs(this.attrs);\n      let copy2 = Mark.none;\n      for (let i = 0; i < this.marks.length; i++) {\n        let mark = this.marks[i];\n        mark.type.checkAttrs(mark.attrs);\n        copy2 = mark.addToSet(copy2);\n      }\n      if (!Mark.sameSet(copy2, this.marks))\n        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);\n      this.content.forEach((node) => node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */\n    toJSON() {\n      let obj = { type: this.type.name };\n      for (let _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      if (this.content.size)\n        obj.content = this.content.toJSON();\n      if (this.marks.length)\n        obj.marks = this.marks.map((n) => n.toJSON());\n      return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */\n    static fromJSON(schema2, json) {\n      if (!json)\n        throw new RangeError(\"Invalid input for Node.fromJSON\");\n      let marks2 = void 0;\n      if (json.marks) {\n        if (!Array.isArray(json.marks))\n          throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n        marks2 = json.marks.map(schema2.markFromJSON);\n      }\n      if (json.type == \"text\") {\n        if (typeof json.text != \"string\")\n          throw new RangeError(\"Invalid text node in JSON\");\n        return schema2.text(json.text, marks2);\n      }\n      let content = Fragment.fromJSON(schema2, json.content);\n      let node = schema2.nodeType(json.type).create(json.attrs, content, marks2);\n      node.type.checkAttrs(node.attrs);\n      return node;\n    }\n  };\n  Node.prototype.text = void 0;\n  var TextNode = class _TextNode extends Node {\n    /**\n    @internal\n    */\n    constructor(type, attrs, content, marks2) {\n      super(type, attrs, null, marks2);\n      if (!content)\n        throw new RangeError(\"Empty text nodes are not allowed\");\n      this.text = content;\n    }\n    toString() {\n      if (this.type.spec.toDebugString)\n        return this.type.spec.toDebugString(this);\n      return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() {\n      return this.text;\n    }\n    textBetween(from2, to) {\n      return this.text.slice(from2, to);\n    }\n    get nodeSize() {\n      return this.text.length;\n    }\n    mark(marks2) {\n      return marks2 == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks2);\n    }\n    withText(text) {\n      if (text == this.text)\n        return this;\n      return new _TextNode(this.type, this.attrs, text, this.marks);\n    }\n    cut(from2 = 0, to = this.text.length) {\n      if (from2 == 0 && to == this.text.length)\n        return this;\n      return this.withText(this.text.slice(from2, to));\n    }\n    eq(other) {\n      return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n      let base2 = super.toJSON();\n      base2.text = this.text;\n      return base2;\n    }\n  };\n  function wrapMarks(marks2, str) {\n    for (let i = marks2.length - 1; i >= 0; i--)\n      str = marks2[i].type.name + \"(\" + str + \")\";\n    return str;\n  }\n  var ContentMatch = class _ContentMatch {\n    /**\n    @internal\n    */\n    constructor(validEnd) {\n      this.validEnd = validEnd;\n      this.next = [];\n      this.wrapCache = [];\n    }\n    /**\n    @internal\n    */\n    static parse(string, nodeTypes) {\n      let stream = new TokenStream(string, nodeTypes);\n      if (stream.next == null)\n        return _ContentMatch.empty;\n      let expr = parseExpr(stream);\n      if (stream.next)\n        stream.err(\"Unexpected trailing text\");\n      let match = dfa(nfa(expr));\n      checkForDeadEnds(match, stream);\n      return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */\n    matchType(type) {\n      for (let i = 0; i < this.next.length; i++)\n        if (this.next[i].type == type)\n          return this.next[i].next;\n      return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */\n    matchFragment(frag, start = 0, end = frag.childCount) {\n      let cur = this;\n      for (let i = start; cur && i < end; i++)\n        cur = cur.matchType(frag.child(i).type);\n      return cur;\n    }\n    /**\n    @internal\n    */\n    get inlineContent() {\n      return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */\n    get defaultType() {\n      for (let i = 0; i < this.next.length; i++) {\n        let { type } = this.next[i];\n        if (!(type.isText || type.hasRequiredAttrs()))\n          return type;\n      }\n      return null;\n    }\n    /**\n    @internal\n    */\n    compatible(other) {\n      for (let i = 0; i < this.next.length; i++)\n        for (let j = 0; j < other.next.length; j++)\n          if (this.next[i].type == other.next[j].type)\n            return true;\n      return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */\n    fillBefore(after, toEnd = false, startIndex = 0) {\n      let seen = [this];\n      function search(match, types) {\n        let finished = match.matchFragment(after, startIndex);\n        if (finished && (!toEnd || finished.validEnd))\n          return Fragment.from(types.map((tp) => tp.createAndFill()));\n        for (let i = 0; i < match.next.length; i++) {\n          let { type, next } = match.next[i];\n          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n            seen.push(next);\n            let found2 = search(next, types.concat(type));\n            if (found2)\n              return found2;\n          }\n        }\n        return null;\n      }\n      return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */\n    findWrapping(target) {\n      for (let i = 0; i < this.wrapCache.length; i += 2)\n        if (this.wrapCache[i] == target)\n          return this.wrapCache[i + 1];\n      let computed = this.computeWrapping(target);\n      this.wrapCache.push(target, computed);\n      return computed;\n    }\n    /**\n    @internal\n    */\n    computeWrapping(target) {\n      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];\n      while (active.length) {\n        let current = active.shift(), match = current.match;\n        if (match.matchType(target)) {\n          let result = [];\n          for (let obj = current; obj.type; obj = obj.via)\n            result.push(obj.type);\n          return result.reverse();\n        }\n        for (let i = 0; i < match.next.length; i++) {\n          let { type, next } = match.next[i];\n          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n            active.push({ match: type.contentMatch, type, via: current });\n            seen[type.name] = true;\n          }\n        }\n      }\n      return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */\n    get edgeCount() {\n      return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */\n    edge(n) {\n      if (n >= this.next.length)\n        throw new RangeError(`There's no ${n}th edge in this content match`);\n      return this.next[n];\n    }\n    /**\n    @internal\n    */\n    toString() {\n      let seen = [];\n      function scan(m) {\n        seen.push(m);\n        for (let i = 0; i < m.next.length; i++)\n          if (seen.indexOf(m.next[i].next) == -1)\n            scan(m.next[i].next);\n      }\n      scan(this);\n      return seen.map((m, i) => {\n        let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n        for (let i2 = 0; i2 < m.next.length; i2++)\n          out += (i2 ? \", \" : \"\") + m.next[i2].type.name + \"->\" + seen.indexOf(m.next[i2].next);\n        return out;\n      }).join(\"\\n\");\n    }\n  };\n  ContentMatch.empty = new ContentMatch(true);\n  var TokenStream = class {\n    constructor(string, nodeTypes) {\n      this.string = string;\n      this.nodeTypes = nodeTypes;\n      this.inline = null;\n      this.pos = 0;\n      this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n      if (this.tokens[this.tokens.length - 1] == \"\")\n        this.tokens.pop();\n      if (this.tokens[0] == \"\")\n        this.tokens.shift();\n    }\n    get next() {\n      return this.tokens[this.pos];\n    }\n    eat(tok) {\n      return this.next == tok && (this.pos++ || true);\n    }\n    err(str) {\n      throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n  };\n  function parseExpr(stream) {\n    let exprs = [];\n    do {\n      exprs.push(parseExprSeq(stream));\n    } while (stream.eat(\"|\"));\n    return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n  }\n  function parseExprSeq(stream) {\n    let exprs = [];\n    do {\n      exprs.push(parseExprSubscript(stream));\n    } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n    return exprs.length == 1 ? exprs[0] : { type: \"seq\", exprs };\n  }\n  function parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for (; ; ) {\n      if (stream.eat(\"+\"))\n        expr = { type: \"plus\", expr };\n      else if (stream.eat(\"*\"))\n        expr = { type: \"star\", expr };\n      else if (stream.eat(\"?\"))\n        expr = { type: \"opt\", expr };\n      else if (stream.eat(\"{\"))\n        expr = parseExprRange(stream, expr);\n      else\n        break;\n    }\n    return expr;\n  }\n  function parseNum(stream) {\n    if (/\\D/.test(stream.next))\n      stream.err(\"Expected number, got '\" + stream.next + \"'\");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n  }\n  function parseExprRange(stream, expr) {\n    let min = parseNum(stream), max = min;\n    if (stream.eat(\",\")) {\n      if (stream.next != \"}\")\n        max = parseNum(stream);\n      else\n        max = -1;\n    }\n    if (!stream.eat(\"}\"))\n      stream.err(\"Unclosed braced range\");\n    return { type: \"range\", min, max, expr };\n  }\n  function resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type)\n      return [type];\n    let result = [];\n    for (let typeName in types) {\n      let type2 = types[typeName];\n      if (type2.isInGroup(name))\n        result.push(type2);\n    }\n    if (result.length == 0)\n      stream.err(\"No node type or group '\" + name + \"' found\");\n    return result;\n  }\n  function parseExprAtom(stream) {\n    if (stream.eat(\"(\")) {\n      let expr = parseExpr(stream);\n      if (!stream.eat(\")\"))\n        stream.err(\"Missing closing paren\");\n      return expr;\n    } else if (!/\\W/.test(stream.next)) {\n      let exprs = resolveName(stream, stream.next).map((type) => {\n        if (stream.inline == null)\n          stream.inline = type.isInline;\n        else if (stream.inline != type.isInline)\n          stream.err(\"Mixing inline and block content\");\n        return { type: \"name\", value: type };\n      });\n      stream.pos++;\n      return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n    } else {\n      stream.err(\"Unexpected token '\" + stream.next + \"'\");\n    }\n  }\n  function nfa(expr) {\n    let nfa2 = [[]];\n    connect(compile(expr, 0), node());\n    return nfa2;\n    function node() {\n      return nfa2.push([]) - 1;\n    }\n    function edge(from2, to, term) {\n      let edge2 = { term, to };\n      nfa2[from2].push(edge2);\n      return edge2;\n    }\n    function connect(edges, to) {\n      edges.forEach((edge2) => edge2.to = to);\n    }\n    function compile(expr2, from2) {\n      if (expr2.type == \"choice\") {\n        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);\n      } else if (expr2.type == \"seq\") {\n        for (let i = 0; ; i++) {\n          let next = compile(expr2.exprs[i], from2);\n          if (i == expr2.exprs.length - 1)\n            return next;\n          connect(next, from2 = node());\n        }\n      } else if (expr2.type == \"star\") {\n        let loop = node();\n        edge(from2, loop);\n        connect(compile(expr2.expr, loop), loop);\n        return [edge(loop)];\n      } else if (expr2.type == \"plus\") {\n        let loop = node();\n        connect(compile(expr2.expr, from2), loop);\n        connect(compile(expr2.expr, loop), loop);\n        return [edge(loop)];\n      } else if (expr2.type == \"opt\") {\n        return [edge(from2)].concat(compile(expr2.expr, from2));\n      } else if (expr2.type == \"range\") {\n        let cur = from2;\n        for (let i = 0; i < expr2.min; i++) {\n          let next = node();\n          connect(compile(expr2.expr, cur), next);\n          cur = next;\n        }\n        if (expr2.max == -1) {\n          connect(compile(expr2.expr, cur), cur);\n        } else {\n          for (let i = expr2.min; i < expr2.max; i++) {\n            let next = node();\n            edge(cur, next);\n            connect(compile(expr2.expr, cur), next);\n            cur = next;\n          }\n        }\n        return [edge(cur)];\n      } else if (expr2.type == \"name\") {\n        return [edge(from2, void 0, expr2.value)];\n      } else {\n        throw new Error(\"Unknown expr type\");\n      }\n    }\n  }\n  function cmp(a, b) {\n    return b - a;\n  }\n  function nullFrom(nfa2, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node2) {\n      let edges = nfa2[node2];\n      if (edges.length == 1 && !edges[0].term)\n        return scan(edges[0].to);\n      result.push(node2);\n      for (let i = 0; i < edges.length; i++) {\n        let { term, to } = edges[i];\n        if (!term && result.indexOf(to) == -1)\n          scan(to);\n      }\n    }\n  }\n  function dfa(nfa2) {\n    let labeled = /* @__PURE__ */ Object.create(null);\n    return explore(nullFrom(nfa2, 0));\n    function explore(states) {\n      let out = [];\n      states.forEach((node) => {\n        nfa2[node].forEach(({ term, to }) => {\n          if (!term)\n            return;\n          let set;\n          for (let i = 0; i < out.length; i++)\n            if (out[i][0] == term)\n              set = out[i][1];\n          nullFrom(nfa2, to).forEach((node2) => {\n            if (!set)\n              out.push([term, set = []]);\n            if (set.indexOf(node2) == -1)\n              set.push(node2);\n          });\n        });\n      });\n      let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);\n      for (let i = 0; i < out.length; i++) {\n        let states2 = out[i][1].sort(cmp);\n        state.next.push({ type: out[i][0], next: labeled[states2.join(\",\")] || explore(states2) });\n      }\n      return state;\n    }\n  }\n  function checkForDeadEnds(match, stream) {\n    for (let i = 0, work = [match]; i < work.length; i++) {\n      let state = work[i], dead = !state.validEnd, nodes2 = [];\n      for (let j = 0; j < state.next.length; j++) {\n        let { type, next } = state.next[j];\n        nodes2.push(type.name);\n        if (dead && !(type.isText || type.hasRequiredAttrs()))\n          dead = false;\n        if (work.indexOf(next) == -1)\n          work.push(next);\n      }\n      if (dead)\n        stream.err(\"Only non-generatable nodes (\" + nodes2.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n  }\n  function defaultAttrs(attrs) {\n    let defaults = /* @__PURE__ */ Object.create(null);\n    for (let attrName in attrs) {\n      let attr = attrs[attrName];\n      if (!attr.hasDefault)\n        return null;\n      defaults[attrName] = attr.default;\n    }\n    return defaults;\n  }\n  function computeAttrs(attrs, value) {\n    let built = /* @__PURE__ */ Object.create(null);\n    for (let name in attrs) {\n      let given = value && value[name];\n      if (given === void 0) {\n        let attr = attrs[name];\n        if (attr.hasDefault)\n          given = attr.default;\n        else\n          throw new RangeError(\"No value supplied for attribute \" + name);\n      }\n      built[name] = given;\n    }\n    return built;\n  }\n  function checkAttrs(attrs, values, type, name) {\n    for (let name2 in values)\n      if (!(name2 in attrs))\n        throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);\n    for (let name2 in attrs) {\n      let attr = attrs[name2];\n      if (attr.validate)\n        attr.validate(values[name2]);\n    }\n  }\n  function initAttrs(typeName, attrs) {\n    let result = /* @__PURE__ */ Object.create(null);\n    if (attrs)\n      for (let name in attrs)\n        result[name] = new Attribute(typeName, name, attrs[name]);\n    return result;\n  }\n  var NodeType = class _NodeType {\n    /**\n    @internal\n    */\n    constructor(name, schema2, spec) {\n      this.name = name;\n      this.schema = schema2;\n      this.spec = spec;\n      this.markSet = null;\n      this.groups = spec.group ? spec.group.split(\" \") : [];\n      this.attrs = initAttrs(name, spec.attrs);\n      this.defaultAttrs = defaultAttrs(this.attrs);\n      this.contentMatch = null;\n      this.inlineContent = null;\n      this.isBlock = !(spec.inline || name == \"text\");\n      this.isText = name == \"text\";\n    }\n    /**\n    True if this is an inline type.\n    */\n    get isInline() {\n      return !this.isBlock;\n    }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */\n    get isTextblock() {\n      return this.isBlock && this.inlineContent;\n    }\n    /**\n    True for node types that allow no content.\n    */\n    get isLeaf() {\n      return this.contentMatch == ContentMatch.empty;\n    }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */\n    get isAtom() {\n      return this.isLeaf || !!this.spec.atom;\n    }\n    /**\n    Return true when this node type is part of the given\n    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).\n    */\n    isInGroup(group) {\n      return this.groups.indexOf(group) > -1;\n    }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */\n    get whitespace() {\n      return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */\n    hasRequiredAttrs() {\n      for (let n in this.attrs)\n        if (this.attrs[n].isRequired)\n          return true;\n      return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */\n    compatibleContent(other) {\n      return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */\n    computeAttrs(attrs) {\n      if (!attrs && this.defaultAttrs)\n        return this.defaultAttrs;\n      else\n        return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */\n    create(attrs = null, content, marks2) {\n      if (this.isText)\n        throw new Error(\"NodeType.create can't construct text nodes\");\n      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks2));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */\n    createChecked(attrs = null, content, marks2) {\n      content = Fragment.from(content);\n      this.checkContent(content);\n      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks2));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */\n    createAndFill(attrs = null, content, marks2) {\n      attrs = this.computeAttrs(attrs);\n      content = Fragment.from(content);\n      if (content.size) {\n        let before = this.contentMatch.fillBefore(content);\n        if (!before)\n          return null;\n        content = before.append(content);\n      }\n      let matched = this.contentMatch.matchFragment(content);\n      let after = matched && matched.fillBefore(Fragment.empty, true);\n      if (!after)\n        return null;\n      return new Node(this, attrs, content.append(after), Mark.setFrom(marks2));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type.\n    */\n    validContent(content) {\n      let result = this.contentMatch.matchFragment(content);\n      if (!result || !result.validEnd)\n        return false;\n      for (let i = 0; i < content.childCount; i++)\n        if (!this.allowsMarks(content.child(i).marks))\n          return false;\n      return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */\n    checkContent(content) {\n      if (!this.validContent(content))\n        throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    @internal\n    */\n    checkAttrs(attrs) {\n      checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */\n    allowsMarkType(markType) {\n      return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */\n    allowsMarks(marks2) {\n      if (this.markSet == null)\n        return true;\n      for (let i = 0; i < marks2.length; i++)\n        if (!this.allowsMarkType(marks2[i].type))\n          return false;\n      return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */\n    allowedMarks(marks2) {\n      if (this.markSet == null)\n        return marks2;\n      let copy2;\n      for (let i = 0; i < marks2.length; i++) {\n        if (!this.allowsMarkType(marks2[i].type)) {\n          if (!copy2)\n            copy2 = marks2.slice(0, i);\n        } else if (copy2) {\n          copy2.push(marks2[i]);\n        }\n      }\n      return !copy2 ? marks2 : copy2.length ? copy2 : Mark.none;\n    }\n    /**\n    @internal\n    */\n    static compile(nodes2, schema2) {\n      let result = /* @__PURE__ */ Object.create(null);\n      nodes2.forEach((name, spec) => result[name] = new _NodeType(name, schema2, spec));\n      let topType = schema2.spec.topNode || \"doc\";\n      if (!result[topType])\n        throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n      if (!result.text)\n        throw new RangeError(\"Every schema needs a 'text' type\");\n      for (let _ in result.text.attrs)\n        throw new RangeError(\"The text node type should not have attributes\");\n      return result;\n    }\n  };\n  function validateType(typeName, attrName, type) {\n    let types = type.split(\"|\");\n    return (value) => {\n      let name = value === null ? \"null\" : typeof value;\n      if (types.indexOf(name) < 0)\n        throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);\n    };\n  }\n  var Attribute = class {\n    constructor(typeName, attrName, options) {\n      this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n      this.default = options.default;\n      this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n    }\n    get isRequired() {\n      return !this.hasDefault;\n    }\n  };\n  var MarkType = class _MarkType {\n    /**\n    @internal\n    */\n    constructor(name, rank, schema2, spec) {\n      this.name = name;\n      this.rank = rank;\n      this.schema = schema2;\n      this.spec = spec;\n      this.attrs = initAttrs(name, spec.attrs);\n      this.excluded = null;\n      let defaults = defaultAttrs(this.attrs);\n      this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark's attributes. The others, if\n    they have defaults, will be added.\n    */\n    create(attrs = null) {\n      if (!attrs && this.instance)\n        return this.instance;\n      return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */\n    static compile(marks2, schema2) {\n      let result = /* @__PURE__ */ Object.create(null), rank = 0;\n      marks2.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema2, spec));\n      return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */\n    removeFromSet(set) {\n      for (var i = 0; i < set.length; i++)\n        if (set[i].type == this) {\n          set = set.slice(0, i).concat(set.slice(i + 1));\n          i--;\n        }\n      return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */\n    isInSet(set) {\n      for (let i = 0; i < set.length; i++)\n        if (set[i].type == this)\n          return set[i];\n    }\n    /**\n    @internal\n    */\n    checkAttrs(attrs) {\n      checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */\n    excludes(other) {\n      return this.excluded.indexOf(other) > -1;\n    }\n  };\n  var Schema = class {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */\n    constructor(spec) {\n      this.linebreakReplacement = null;\n      this.cached = /* @__PURE__ */ Object.create(null);\n      let instanceSpec = this.spec = {};\n      for (let prop in spec)\n        instanceSpec[prop] = spec[prop];\n      instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n      this.marks = MarkType.compile(this.spec.marks, this);\n      let contentExprCache = /* @__PURE__ */ Object.create(null);\n      for (let prop in this.nodes) {\n        if (prop in this.marks)\n          throw new RangeError(prop + \" can not be both a node and a mark\");\n        let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n        type.inlineContent = type.contentMatch.inlineContent;\n        if (type.spec.linebreakReplacement) {\n          if (this.linebreakReplacement)\n            throw new RangeError(\"Multiple linebreak nodes defined\");\n          if (!type.isInline || !type.isLeaf)\n            throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n          this.linebreakReplacement = type;\n        }\n        type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n      }\n      for (let prop in this.marks) {\n        let type = this.marks[prop], excl = type.spec.excludes;\n        type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n      }\n      this.nodeFromJSON = (json) => Node.fromJSON(this, json);\n      this.markFromJSON = (json) => Mark.fromJSON(this, json);\n      this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n      this.cached.wrappings = /* @__PURE__ */ Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */\n    node(type, attrs = null, content, marks2) {\n      if (typeof type == \"string\")\n        type = this.nodeType(type);\n      else if (!(type instanceof NodeType))\n        throw new RangeError(\"Invalid node type: \" + type);\n      else if (type.schema != this)\n        throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n      return type.createChecked(attrs, content, marks2);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */\n    text(text, marks2) {\n      let type = this.nodes.text;\n      return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks2));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */\n    mark(type, attrs) {\n      if (typeof type == \"string\")\n        type = this.marks[type];\n      return type.create(attrs);\n    }\n    /**\n    @internal\n    */\n    nodeType(name) {\n      let found2 = this.nodes[name];\n      if (!found2)\n        throw new RangeError(\"Unknown node type: \" + name);\n      return found2;\n    }\n  };\n  function gatherMarks(schema2, marks2) {\n    let found2 = [];\n    for (let i = 0; i < marks2.length; i++) {\n      let name = marks2[i], mark = schema2.marks[name], ok = mark;\n      if (mark) {\n        found2.push(mark);\n      } else {\n        for (let prop in schema2.marks) {\n          let mark2 = schema2.marks[prop];\n          if (name == \"_\" || mark2.spec.group && mark2.spec.group.split(\" \").indexOf(name) > -1)\n            found2.push(ok = mark2);\n        }\n      }\n      if (!ok)\n        throw new SyntaxError(\"Unknown mark type: '\" + marks2[i] + \"'\");\n    }\n    return found2;\n  }\n  function isTagRule(rule) {\n    return rule.tag != null;\n  }\n  function isStyleRule(rule) {\n    return rule.style != null;\n  }\n  var DOMParser = class _DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */\n    constructor(schema2, rules) {\n      this.schema = schema2;\n      this.rules = rules;\n      this.tags = [];\n      this.styles = [];\n      let matchedStyles = this.matchedStyles = [];\n      rules.forEach((rule) => {\n        if (isTagRule(rule)) {\n          this.tags.push(rule);\n        } else if (isStyleRule(rule)) {\n          let prop = /[^=]*/.exec(rule.style)[0];\n          if (matchedStyles.indexOf(prop) < 0)\n            matchedStyles.push(prop);\n          this.styles.push(rule);\n        }\n      });\n      this.normalizeLists = !this.tags.some((r) => {\n        if (!/^(ul|ol)\\b/.test(r.tag) || !r.node)\n          return false;\n        let node = schema2.nodes[r.node];\n        return node.contentMatch.matchType(node);\n      });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */\n    parse(dom, options = {}) {\n      let context = new ParseContext(this, options, false);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */\n    parseSlice(dom, options = {}) {\n      let context = new ParseContext(this, options, true);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */\n    matchTag(dom, context, after) {\n      for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n        let rule = this.tags[i];\n        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n          if (rule.getAttrs) {\n            let result = rule.getAttrs(dom);\n            if (result === false)\n              continue;\n            rule.attrs = result || void 0;\n          }\n          return rule;\n        }\n      }\n    }\n    /**\n    @internal\n    */\n    matchStyle(prop, value, context, after) {\n      for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n        let rule = this.styles[i], style = rule.style;\n        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))\n          continue;\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(value);\n          if (result === false)\n            continue;\n          rule.attrs = result || void 0;\n        }\n        return rule;\n      }\n    }\n    /**\n    @internal\n    */\n    static schemaRules(schema2) {\n      let result = [];\n      function insert(rule) {\n        let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n        for (; i < result.length; i++) {\n          let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n          if (nextPriority < priority)\n            break;\n        }\n        result.splice(i, 0, rule);\n      }\n      for (let name in schema2.marks) {\n        let rules = schema2.marks[name].spec.parseDOM;\n        if (rules)\n          rules.forEach((rule) => {\n            insert(rule = copy(rule));\n            if (!(rule.mark || rule.ignore || rule.clearMark))\n              rule.mark = name;\n          });\n      }\n      for (let name in schema2.nodes) {\n        let rules = schema2.nodes[name].spec.parseDOM;\n        if (rules)\n          rules.forEach((rule) => {\n            insert(rule = copy(rule));\n            if (!(rule.node || rule.ignore || rule.mark))\n              rule.node = name;\n          });\n      }\n      return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).\n    */\n    static fromSchema(schema2) {\n      return schema2.cached.domParser || (schema2.cached.domParser = new _DOMParser(schema2, _DOMParser.schemaRules(schema2)));\n    }\n  };\n  var blockTags = {\n    address: true,\n    article: true,\n    aside: true,\n    blockquote: true,\n    canvas: true,\n    dd: true,\n    div: true,\n    dl: true,\n    fieldset: true,\n    figcaption: true,\n    figure: true,\n    footer: true,\n    form: true,\n    h1: true,\n    h2: true,\n    h3: true,\n    h4: true,\n    h5: true,\n    h6: true,\n    header: true,\n    hgroup: true,\n    hr: true,\n    li: true,\n    noscript: true,\n    ol: true,\n    output: true,\n    p: true,\n    pre: true,\n    section: true,\n    table: true,\n    tfoot: true,\n    ul: true\n  };\n  var ignoreTags = {\n    head: true,\n    noscript: true,\n    object: true,\n    script: true,\n    style: true,\n    title: true\n  };\n  var listTags = { ol: true, ul: true };\n  var OPT_PRESERVE_WS = 1;\n  var OPT_PRESERVE_WS_FULL = 2;\n  var OPT_OPEN_LEFT = 4;\n  function wsOptionsFor(type, preserveWhitespace, base2) {\n    if (preserveWhitespace != null)\n      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;\n  }\n  var NodeContext = class {\n    constructor(type, attrs, marks2, solid, match, options) {\n      this.type = type;\n      this.attrs = attrs;\n      this.marks = marks2;\n      this.solid = solid;\n      this.options = options;\n      this.content = [];\n      this.activeMarks = Mark.none;\n      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n      if (!this.match) {\n        if (!this.type)\n          return [];\n        let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n        if (fill) {\n          this.match = this.type.contentMatch.matchFragment(fill);\n        } else {\n          let start = this.type.contentMatch, wrap2;\n          if (wrap2 = start.findWrapping(node.type)) {\n            this.match = start;\n            return wrap2;\n          } else {\n            return null;\n          }\n        }\n      }\n      return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n      if (!(this.options & OPT_PRESERVE_WS)) {\n        let last = this.content[this.content.length - 1], m;\n        if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n          let text = last;\n          if (last.text.length == m[0].length)\n            this.content.pop();\n          else\n            this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n        }\n      }\n      let content = Fragment.from(this.content);\n      if (!openEnd && this.match)\n        content = content.append(this.match.fillBefore(Fragment.empty, true));\n      return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    inlineContext(node) {\n      if (this.type)\n        return this.type.inlineContent;\n      if (this.content.length)\n        return this.content[0].isInline;\n      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n  };\n  var ParseContext = class {\n    constructor(parser, options, isOpen) {\n      this.parser = parser;\n      this.options = options;\n      this.isOpen = isOpen;\n      this.open = 0;\n      this.localPreserveWS = false;\n      let topNode = options.topNode, topContext;\n      let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n      if (topNode)\n        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n      else if (isOpen)\n        topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);\n      else\n        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n      this.nodes = [topContext];\n      this.find = options.findPositions;\n      this.needsBlock = false;\n    }\n    get top() {\n      return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom, marks2) {\n      if (dom.nodeType == 3)\n        this.addTextNode(dom, marks2);\n      else if (dom.nodeType == 1)\n        this.addElement(dom, marks2);\n    }\n    addTextNode(dom, marks2) {\n      let value = dom.nodeValue;\n      let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n      if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n        if (!preserveWS) {\n          value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n          if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n            let nodeBefore = top.content[top.content.length - 1];\n            let domNodeBefore = dom.previousSibling;\n            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == \"BR\" || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text))\n              value = value.slice(1);\n          }\n        } else if (preserveWS !== \"full\") {\n          value = value.replace(/\\r?\\n|\\r/g, \" \");\n        } else {\n          value = value.replace(/\\r\\n?/g, \"\\n\");\n        }\n        if (value)\n          this.insertNode(this.parser.schema.text(value), marks2, !/\\S/.test(value));\n        this.findInText(dom);\n      } else {\n        this.findInside(dom);\n      }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n    addElement(dom, marks2, matchAfter) {\n      let outerWS = this.localPreserveWS, top = this.top;\n      if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace))\n        this.localPreserveWS = true;\n      let name = dom.nodeName.toLowerCase(), ruleID;\n      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)\n        normalizeList(dom);\n      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n        this.findInside(dom);\n        this.ignoreFallback(dom, marks2);\n      } else if (!rule || rule.skip || rule.closeParent) {\n        if (rule && rule.closeParent)\n          this.open = Math.max(0, this.open - 1);\n        else if (rule && rule.skip.nodeType)\n          dom = rule.skip;\n        let sync, oldNeedsBlock = this.needsBlock;\n        if (blockTags.hasOwnProperty(name)) {\n          if (top.content.length && top.content[0].isInline && this.open) {\n            this.open--;\n            top = this.top;\n          }\n          sync = true;\n          if (!top.type)\n            this.needsBlock = true;\n        } else if (!dom.firstChild) {\n          this.leafFallback(dom, marks2);\n          break out;\n        }\n        let innerMarks = rule && rule.skip ? marks2 : this.readStyles(dom, marks2);\n        if (innerMarks)\n          this.addAll(dom, innerMarks);\n        if (sync)\n          this.sync(top);\n        this.needsBlock = oldNeedsBlock;\n      } else {\n        let innerMarks = this.readStyles(dom, marks2);\n        if (innerMarks)\n          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);\n      }\n      this.localPreserveWS = outerWS;\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom, marks2) {\n      if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n        this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks2);\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom, marks2) {\n      if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n        this.findPlace(this.parser.schema.text(\"-\"), marks2, true);\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an updated array of marks, or null to indicate some of the\n    // styles had a rule with `ignore` set.\n    readStyles(dom, marks2) {\n      let styles = dom.style;\n      if (styles && styles.length)\n        for (let i = 0; i < this.parser.matchedStyles.length; i++) {\n          let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);\n          if (value)\n            for (let after = void 0; ; ) {\n              let rule = this.parser.matchStyle(name, value, this, after);\n              if (!rule)\n                break;\n              if (rule.ignore)\n                return null;\n              if (rule.clearMark)\n                marks2 = marks2.filter((m) => !rule.clearMark(m));\n              else\n                marks2 = marks2.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));\n              if (rule.consuming === false)\n                after = rule;\n              else\n                break;\n            }\n        }\n      return marks2;\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n    addElementByRule(dom, rule, marks2, continueAfter) {\n      let sync, nodeType;\n      if (rule.node) {\n        nodeType = this.parser.schema.nodes[rule.node];\n        if (!nodeType.isLeaf) {\n          let inner = this.enter(nodeType, rule.attrs || null, marks2, rule.preserveWhitespace);\n          if (inner) {\n            sync = true;\n            marks2 = inner;\n          }\n        } else if (!this.insertNode(nodeType.create(rule.attrs), marks2, dom.nodeName == \"BR\")) {\n          this.leafFallback(dom, marks2);\n        }\n      } else {\n        let markType = this.parser.schema.marks[rule.mark];\n        marks2 = marks2.concat(markType.create(rule.attrs));\n      }\n      let startIn = this.top;\n      if (nodeType && nodeType.isLeaf) {\n        this.findInside(dom);\n      } else if (continueAfter) {\n        this.addElement(dom, marks2, continueAfter);\n      } else if (rule.getContent) {\n        this.findInside(dom);\n        rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks2, false));\n      } else {\n        let contentDOM = dom;\n        if (typeof rule.contentElement == \"string\")\n          contentDOM = dom.querySelector(rule.contentElement);\n        else if (typeof rule.contentElement == \"function\")\n          contentDOM = rule.contentElement(dom);\n        else if (rule.contentElement)\n          contentDOM = rule.contentElement;\n        this.findAround(dom, contentDOM, true);\n        this.addAll(contentDOM, marks2);\n        this.findAround(dom, contentDOM, false);\n      }\n      if (sync && this.sync(startIn))\n        this.open--;\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, marks2, startIndex, endIndex) {\n      let index = startIndex || 0;\n      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n        this.findAtPoint(parent, index);\n        this.addDOM(dom, marks2);\n      }\n      this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n    findPlace(node, marks2, cautious) {\n      let route, sync;\n      for (let depth = this.open, penalty = 0; depth >= 0; depth--) {\n        let cx = this.nodes[depth];\n        let found2 = cx.findWrapping(node);\n        if (found2 && (!route || route.length > found2.length + penalty)) {\n          route = found2;\n          sync = cx;\n          if (!found2.length)\n            break;\n        }\n        if (cx.solid) {\n          if (cautious)\n            break;\n          penalty += 2;\n        }\n      }\n      if (!route)\n        return null;\n      this.sync(sync);\n      for (let i = 0; i < route.length; i++)\n        marks2 = this.enterInner(route[i], null, marks2, false);\n      return marks2;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node, marks2, cautious) {\n      if (node.isInline && this.needsBlock && !this.top.type) {\n        let block = this.textblockFromContext();\n        if (block)\n          marks2 = this.enterInner(block, null, marks2);\n      }\n      let innerMarks = this.findPlace(node, marks2, cautious);\n      if (innerMarks) {\n        this.closeExtra();\n        let top = this.top;\n        if (top.match)\n          top.match = top.match.matchType(node.type);\n        let nodeMarks = Mark.none;\n        for (let m of innerMarks.concat(node.marks))\n          if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))\n            nodeMarks = m.addToSet(nodeMarks);\n        top.content.push(node.mark(nodeMarks));\n        return true;\n      }\n      return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, marks2, preserveWS) {\n      let innerMarks = this.findPlace(type.create(attrs), marks2, false);\n      if (innerMarks)\n        innerMarks = this.enterInner(type, attrs, marks2, true, preserveWS);\n      return innerMarks;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs, marks2, solid = false, preserveWS) {\n      this.closeExtra();\n      let top = this.top;\n      top.match = top.match && top.match.matchType(type);\n      let options = wsOptionsFor(type, preserveWS, top.options);\n      if (top.options & OPT_OPEN_LEFT && top.content.length == 0)\n        options |= OPT_OPEN_LEFT;\n      let applyMarks = Mark.none;\n      marks2 = marks2.filter((m) => {\n        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n          applyMarks = m.addToSet(applyMarks);\n          return false;\n        }\n        return true;\n      });\n      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n      this.open++;\n      return marks2;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n      let i = this.nodes.length - 1;\n      if (i > this.open) {\n        for (; i > this.open; i--)\n          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n        this.nodes.length = this.open + 1;\n      }\n    }\n    finish() {\n      this.open = 0;\n      this.closeExtra(this.isOpen);\n      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n    sync(to) {\n      for (let i = this.open; i >= 0; i--) {\n        if (this.nodes[i] == to) {\n          this.open = i;\n          return true;\n        } else if (this.localPreserveWS) {\n          this.nodes[i].options |= OPT_PRESERVE_WS;\n        }\n      }\n      return false;\n    }\n    get currentPos() {\n      this.closeExtra();\n      let pos = 0;\n      for (let i = this.open; i >= 0; i--) {\n        let content = this.nodes[i].content;\n        for (let j = content.length - 1; j >= 0; j--)\n          pos += content[j].nodeSize;\n        if (i)\n          pos++;\n      }\n      return pos;\n    }\n    findAtPoint(parent, offset) {\n      if (this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].node == parent && this.find[i].offset == offset)\n            this.find[i].pos = this.currentPos;\n        }\n    }\n    findInside(parent) {\n      if (this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n            this.find[i].pos = this.currentPos;\n        }\n    }\n    findAround(parent, content, before) {\n      if (parent != content && this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n            let pos = content.compareDocumentPosition(this.find[i].node);\n            if (pos & (before ? 2 : 4))\n              this.find[i].pos = this.currentPos;\n          }\n        }\n    }\n    findInText(textNode) {\n      if (this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].node == textNode)\n            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n        }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n      if (context.indexOf(\"|\") > -1)\n        return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n      let parts = context.split(\"/\");\n      let option = this.options.context;\n      let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n      let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n      let match = (i, depth) => {\n        for (; i >= 0; i--) {\n          let part = parts[i];\n          if (part == \"\") {\n            if (i == parts.length - 1 || i == 0)\n              continue;\n            for (; depth >= minDepth; depth--)\n              if (match(i - 1, depth))\n                return true;\n            return false;\n          } else {\n            let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n            if (!next || next.name != part && !next.isInGroup(part))\n              return false;\n            depth--;\n          }\n        }\n        return true;\n      };\n      return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n      let $context = this.options.context;\n      if ($context)\n        for (let d = $context.depth; d >= 0; d--) {\n          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n          if (deflt && deflt.isTextblock && deflt.defaultAttrs)\n            return deflt;\n        }\n      for (let name in this.parser.schema.nodes) {\n        let type = this.parser.schema.nodes[name];\n        if (type.isTextblock && type.defaultAttrs)\n          return type;\n      }\n    }\n  };\n  function normalizeList(dom) {\n    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n      if (name && listTags.hasOwnProperty(name) && prevItem) {\n        prevItem.appendChild(child);\n        child = prevItem;\n      } else if (name == \"li\") {\n        prevItem = child;\n      } else if (name) {\n        prevItem = null;\n      }\n    }\n  }\n  function matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n  }\n  function copy(obj) {\n    let copy2 = {};\n    for (let prop in obj)\n      copy2[prop] = obj[prop];\n    return copy2;\n  }\n  function markMayApply(markType, nodeType) {\n    let nodes2 = nodeType.schema.nodes;\n    for (let name in nodes2) {\n      let parent = nodes2[name];\n      if (!parent.allowsMarkType(markType))\n        continue;\n      let seen = [], scan = (match) => {\n        seen.push(match);\n        for (let i = 0; i < match.edgeCount; i++) {\n          let { type, next } = match.edge(i);\n          if (type == nodeType)\n            return true;\n          if (seen.indexOf(next) < 0 && scan(next))\n            return true;\n        }\n      };\n      if (scan(parent.contentMatch))\n        return true;\n    }\n  }\n  var DOMSerializer = class _DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark's content is block or\n    inline content (for typical use, it'll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */\n    constructor(nodes2, marks2) {\n      this.nodes = nodes2;\n      this.marks = marks2;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */\n    serializeFragment(fragment, options = {}, target) {\n      if (!target)\n        target = doc(options).createDocumentFragment();\n      let top = target, active = [];\n      fragment.forEach((node) => {\n        if (active.length || node.marks.length) {\n          let keep = 0, rendered = 0;\n          while (keep < active.length && rendered < node.marks.length) {\n            let next = node.marks[rendered];\n            if (!this.marks[next.type.name]) {\n              rendered++;\n              continue;\n            }\n            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)\n              break;\n            keep++;\n            rendered++;\n          }\n          while (keep < active.length)\n            top = active.pop()[1];\n          while (rendered < node.marks.length) {\n            let add2 = node.marks[rendered++];\n            let markDOM = this.serializeMark(add2, node.isInline, options);\n            if (markDOM) {\n              active.push([add2, top]);\n              top.appendChild(markDOM.dom);\n              top = markDOM.contentDOM || markDOM.dom;\n            }\n          }\n        }\n        top.appendChild(this.serializeNodeInner(node, options));\n      });\n      return target;\n    }\n    /**\n    @internal\n    */\n    serializeNodeInner(node, options) {\n      let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);\n      if (contentDOM) {\n        if (node.isLeaf)\n          throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n        this.serializeFragment(node.content, options, contentDOM);\n      }\n      return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */\n    serializeNode(node, options = {}) {\n      let dom = this.serializeNodeInner(node, options);\n      for (let i = node.marks.length - 1; i >= 0; i--) {\n        let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);\n        if (wrap2) {\n          (wrap2.contentDOM || wrap2.dom).appendChild(dom);\n          dom = wrap2.dom;\n        }\n      }\n      return dom;\n    }\n    /**\n    @internal\n    */\n    serializeMark(mark, inline, options = {}) {\n      let toDOM = this.marks[mark.type.name];\n      return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n    static renderSpec(doc3, structure, xmlNS = null, blockArraysIn) {\n      return renderSpec(doc3, structure, xmlNS, blockArraysIn);\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */\n    static fromSchema(schema2) {\n      return schema2.cached.domSerializer || (schema2.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */\n    static nodesFromSchema(schema2) {\n      let result = gatherToDOM(schema2.nodes);\n      if (!result.text)\n        result.text = (node) => node.text;\n      return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */\n    static marksFromSchema(schema2) {\n      return gatherToDOM(schema2.marks);\n    }\n  };\n  function gatherToDOM(obj) {\n    let result = {};\n    for (let name in obj) {\n      let toDOM = obj[name].spec.toDOM;\n      if (toDOM)\n        result[name] = toDOM;\n    }\n    return result;\n  }\n  function doc(options) {\n    return options.document || window.document;\n  }\n  var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();\n  function suspiciousAttributes(attrs) {\n    let value = suspiciousAttributeCache.get(attrs);\n    if (value === void 0)\n      suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n    return value;\n  }\n  function suspiciousAttributesInner(attrs) {\n    let result = null;\n    function scan(value) {\n      if (value && typeof value == \"object\") {\n        if (Array.isArray(value)) {\n          if (typeof value[0] == \"string\") {\n            if (!result)\n              result = [];\n            result.push(value);\n          } else {\n            for (let i = 0; i < value.length; i++)\n              scan(value[i]);\n          }\n        } else {\n          for (let prop in value)\n            scan(value[prop]);\n        }\n      }\n    }\n    scan(attrs);\n    return result;\n  }\n  function renderSpec(doc3, structure, xmlNS, blockArraysIn) {\n    if (typeof structure == \"string\")\n      return { dom: doc3.createTextNode(structure) };\n    if (structure.nodeType != null)\n      return { dom: structure };\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure;\n    let tagName = structure[0], suspicious;\n    if (typeof tagName != \"string\")\n      throw new RangeError(\"Invalid array passed to renderSpec\");\n    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)\n      throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n    let space = tagName.indexOf(\" \");\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space);\n      tagName = tagName.slice(space + 1);\n    }\n    let contentDOM;\n    let dom = xmlNS ? doc3.createElementNS(xmlNS, tagName) : doc3.createElement(tagName);\n    let attrs = structure[1], start = 1;\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2;\n      for (let name in attrs)\n        if (attrs[name] != null) {\n          let space2 = name.indexOf(\" \");\n          if (space2 > 0)\n            dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);\n          else if (name == \"style\" && dom.style)\n            dom.style.cssText = attrs[name];\n          else\n            dom.setAttribute(name, attrs[name]);\n        }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i];\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\");\n        return { dom, contentDOM: dom };\n      } else {\n        let { dom: inner, contentDOM: innerContent } = renderSpec(doc3, child, xmlNS, blockArraysIn);\n        dom.appendChild(inner);\n        if (innerContent) {\n          if (contentDOM)\n            throw new RangeError(\"Multiple content holes\");\n          contentDOM = innerContent;\n        }\n      }\n    }\n    return { dom, contentDOM };\n  }\n\n  // node_modules/prosemirror-transform/dist/index.js\n  var lower16 = 65535;\n  var factor16 = Math.pow(2, 16);\n  function makeRecover(index, offset) {\n    return index + offset * factor16;\n  }\n  function recoverIndex(value) {\n    return value & lower16;\n  }\n  function recoverOffset(value) {\n    return (value - (value & lower16)) / factor16;\n  }\n  var DEL_BEFORE = 1;\n  var DEL_AFTER = 2;\n  var DEL_ACROSS = 4;\n  var DEL_SIDE = 8;\n  var MapResult = class {\n    /**\n    @internal\n    */\n    constructor(pos, delInfo, recover) {\n      this.pos = pos;\n      this.delInfo = delInfo;\n      this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() {\n      return (this.delInfo & DEL_SIDE) > 0;\n    }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() {\n      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n    }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() {\n      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n    }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() {\n      return (this.delInfo & DEL_ACROSS) > 0;\n    }\n  };\n  var StepMap = class _StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(ranges, inverted = false) {\n      this.ranges = ranges;\n      this.inverted = inverted;\n      if (!ranges.length && _StepMap.empty)\n        return _StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n      let diff = 0, index = recoverIndex(value);\n      if (!this.inverted)\n        for (let i = 0; i < index; i++)\n          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n      return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) {\n      return this._map(pos, assoc, false);\n    }\n    map(pos, assoc = 1) {\n      return this._map(pos, assoc, true);\n    }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n      for (let i = 0; i < this.ranges.length; i += 3) {\n        let start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos)\n          break;\n        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n        if (pos <= end) {\n          let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n          let result = start + diff + (side < 0 ? 0 : newSize);\n          if (simple)\n            return result;\n          let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n          let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n          if (assoc < 0 ? pos != start : pos != end)\n            del2 |= DEL_SIDE;\n          return new MapResult(result, del2, recover);\n        }\n        diff += newSize - oldSize;\n      }\n      return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n      let diff = 0, index = recoverIndex(recover);\n      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n      for (let i = 0; i < this.ranges.length; i += 3) {\n        let start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos)\n          break;\n        let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n        if (pos <= end && i == index * 3)\n          return true;\n        diff += this.ranges[i + newIndex] - oldSize;\n      }\n      return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n      for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n        let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n        diff += newSize - oldSize;\n      }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n      return new _StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n      return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n      return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n  };\n  StepMap.empty = new StepMap([]);\n  var Mapping = class _Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {\n      this.mirror = mirror;\n      this.from = from2;\n      this.to = to;\n      this._maps = maps || [];\n      this.ownData = !(maps || mirror);\n    }\n    /**\n    The step maps in this mapping.\n    */\n    get maps() {\n      return this._maps;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from2 = 0, to = this.maps.length) {\n      return new _Mapping(this._maps, this.mirror, from2, to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map2, mirrors) {\n      if (!this.ownData) {\n        this._maps = this._maps.slice();\n        this.mirror = this.mirror && this.mirror.slice();\n        this.ownData = true;\n      }\n      this.to = this._maps.push(map2);\n      if (mirrors != null)\n        this.setMirror(this._maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n      for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {\n        let mirr = mapping.getMirror(i);\n        this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);\n      }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n      if (this.mirror) {\n        for (let i = 0; i < this.mirror.length; i++)\n          if (this.mirror[i] == n)\n            return this.mirror[i + (i % 2 ? -1 : 1)];\n      }\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n      if (!this.mirror)\n        this.mirror = [];\n      this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n      for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {\n        let mirr = mapping.getMirror(i);\n        this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);\n      }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n      let inverse = new _Mapping();\n      inverse.appendMappingInverted(this);\n      return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n      if (this.mirror)\n        return this._map(pos, assoc, true);\n      for (let i = this.from; i < this.to; i++)\n        pos = this._maps[i].map(pos, assoc);\n      return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) {\n      return this._map(pos, assoc, false);\n    }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n      let delInfo = 0;\n      for (let i = this.from; i < this.to; i++) {\n        let map2 = this._maps[i], result = map2.mapResult(pos, assoc);\n        if (result.recover != null) {\n          let corr = this.getMirror(i);\n          if (corr != null && corr > i && corr < this.to) {\n            i = corr;\n            pos = this._maps[corr].recover(result.recover);\n            continue;\n          }\n        }\n        delInfo |= result.delInfo;\n        pos = result.pos;\n      }\n      return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n  };\n  var stepsByID = /* @__PURE__ */ Object.create(null);\n  var Step = class {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() {\n      return StepMap.empty;\n    }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n    merge(other) {\n      return null;\n    }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n    static fromJSON(schema2, json) {\n      if (!json || !json.stepType)\n        throw new RangeError(\"Invalid input for Step.fromJSON\");\n      let type = stepsByID[json.stepType];\n      if (!type)\n        throw new RangeError(`No step type ${json.stepType} defined`);\n      return type.fromJSON(schema2, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n    static jsonID(id, stepClass) {\n      if (id in stepsByID)\n        throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n      stepsByID[id] = stepClass;\n      stepClass.prototype.jsonID = id;\n      return stepClass;\n    }\n  };\n  var StepResult = class _StepResult {\n    /**\n    @internal\n    */\n    constructor(doc3, failed) {\n      this.doc = doc3;\n      this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc3) {\n      return new _StepResult(doc3, null);\n    }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) {\n      return new _StepResult(null, message);\n    }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc3, from2, to, slice2) {\n      try {\n        return _StepResult.ok(doc3.replace(from2, to, slice2));\n      } catch (e) {\n        if (e instanceof ReplaceError)\n          return _StepResult.fail(e.message);\n        throw e;\n      }\n    }\n  };\n  function mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n      let child = fragment.child(i);\n      if (child.content.size)\n        child = child.copy(mapFragment(child.content, f, child));\n      if (child.isInline)\n        child = f(child, parent, i);\n      mapped.push(child);\n    }\n    return Fragment.fromArray(mapped);\n  }\n  var AddMarkStep = class _AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(from2, to, mark) {\n      super();\n      this.from = from2;\n      this.to = to;\n      this.mark = mark;\n    }\n    apply(doc3) {\n      let oldSlice = doc3.slice(this.from, this.to), $from = doc3.resolve(this.from);\n      let parent = $from.node($from.sharedDepth(this.to));\n      let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {\n        if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))\n          return node;\n        return node.mark(this.mark.addToSet(node.marks));\n      }, parent), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc3, this.from, this.to, slice2);\n    }\n    invert() {\n      return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      if (from2.deleted && to.deleted || from2.pos >= to.pos)\n        return null;\n      return new _AddMarkStep(from2.pos, to.pos, this.mark);\n    }\n    merge(other) {\n      if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n        return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n    toJSON() {\n      return {\n        stepType: \"addMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\")\n        throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n      return new _AddMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"addMark\", AddMarkStep);\n  var RemoveMarkStep = class _RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(from2, to, mark) {\n      super();\n      this.from = from2;\n      this.to = to;\n      this.mark = mark;\n    }\n    apply(doc3) {\n      let oldSlice = doc3.slice(this.from, this.to);\n      let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {\n        return node.mark(this.mark.removeFromSet(node.marks));\n      }, doc3), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc3, this.from, this.to, slice2);\n    }\n    invert() {\n      return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      if (from2.deleted && to.deleted || from2.pos >= to.pos)\n        return null;\n      return new _RemoveMarkStep(from2.pos, to.pos, this.mark);\n    }\n    merge(other) {\n      if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n        return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n    toJSON() {\n      return {\n        stepType: \"removeMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\")\n        throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n      return new _RemoveMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"removeMark\", RemoveMarkStep);\n  var AddNodeMarkStep = class _AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(pos, mark) {\n      super();\n      this.pos = pos;\n      this.mark = mark;\n    }\n    apply(doc3) {\n      let node = doc3.nodeAt(this.pos);\n      if (!node)\n        return StepResult.fail(\"No node at mark step's position\");\n      let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc3) {\n      let node = doc3.nodeAt(this.pos);\n      if (node) {\n        let newSet = this.mark.addToSet(node.marks);\n        if (newSet.length == node.marks.length) {\n          for (let i = 0; i < node.marks.length; i++)\n            if (!node.marks[i].isInSet(newSet))\n              return new _AddNodeMarkStep(this.pos, node.marks[i]);\n          return new _AddNodeMarkStep(this.pos, this.mark);\n        }\n      }\n      return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n      let pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n      return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.pos != \"number\")\n        throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n      return new _AddNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"addNodeMark\", AddNodeMarkStep);\n  var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(pos, mark) {\n      super();\n      this.pos = pos;\n      this.mark = mark;\n    }\n    apply(doc3) {\n      let node = doc3.nodeAt(this.pos);\n      if (!node)\n        return StepResult.fail(\"No node at mark step's position\");\n      let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc3) {\n      let node = doc3.nodeAt(this.pos);\n      if (!node || !this.mark.isInSet(node.marks))\n        return this;\n      return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n      let pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n      return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.pos != \"number\")\n        throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n      return new _RemoveNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n  var ReplaceStep = class _ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */\n    constructor(from2, to, slice2, structure = false) {\n      super();\n      this.from = from2;\n      this.to = to;\n      this.slice = slice2;\n      this.structure = structure;\n    }\n    apply(doc3) {\n      if (this.structure && contentBetween(doc3, this.from, this.to))\n        return StepResult.fail(\"Structure replace would overwrite content\");\n      return StepResult.fromReplace(doc3, this.from, this.to, this.slice);\n    }\n    getMap() {\n      return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc3) {\n      return new _ReplaceStep(this.from, this.from + this.slice.size, doc3.slice(this.from, this.to));\n    }\n    map(mapping) {\n      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      if (from2.deletedAcross && to.deletedAcross)\n        return null;\n      return new _ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);\n    }\n    merge(other) {\n      if (!(other instanceof _ReplaceStep) || other.structure || this.structure)\n        return null;\n      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n        return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);\n      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n        return new _ReplaceStep(other.from, this.to, slice2, this.structure);\n      } else {\n        return null;\n      }\n    }\n    toJSON() {\n      let json = { stepType: \"replace\", from: this.from, to: this.to };\n      if (this.slice.size)\n        json.slice = this.slice.toJSON();\n      if (this.structure)\n        json.structure = true;\n      return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\")\n        throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n      return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema2, json.slice), !!json.structure);\n    }\n  };\n  Step.jsonID(\"replace\", ReplaceStep);\n  var ReplaceAroundStep = class _ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {\n      super();\n      this.from = from2;\n      this.to = to;\n      this.gapFrom = gapFrom;\n      this.gapTo = gapTo;\n      this.slice = slice2;\n      this.insert = insert;\n      this.structure = structure;\n    }\n    apply(doc3) {\n      if (this.structure && (contentBetween(doc3, this.from, this.gapFrom) || contentBetween(doc3, this.gapTo, this.to)))\n        return StepResult.fail(\"Structure gap-replace would overwrite content\");\n      let gap = doc3.slice(this.gapFrom, this.gapTo);\n      if (gap.openStart || gap.openEnd)\n        return StepResult.fail(\"Gap is not a flat range\");\n      let inserted = this.slice.insertAt(this.insert, gap.content);\n      if (!inserted)\n        return StepResult.fail(\"Content does not fit in gap\");\n      return StepResult.fromReplace(doc3, this.from, this.to, inserted);\n    }\n    getMap() {\n      return new StepMap([\n        this.from,\n        this.gapFrom - this.from,\n        this.insert,\n        this.gapTo,\n        this.to - this.gapTo,\n        this.slice.size - this.insert\n      ]);\n    }\n    invert(doc3) {\n      let gap = this.gapTo - this.gapFrom;\n      return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc3.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n      let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);\n      let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n      if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)\n        return null;\n      return new _ReplaceAroundStep(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n      let json = {\n        stepType: \"replaceAround\",\n        from: this.from,\n        to: this.to,\n        gapFrom: this.gapFrom,\n        gapTo: this.gapTo,\n        insert: this.insert\n      };\n      if (this.slice.size)\n        json.slice = this.slice.toJSON();\n      if (this.structure)\n        json.structure = true;\n      return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n        throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n      return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema2, json.slice), json.insert, !!json.structure);\n    }\n  };\n  Step.jsonID(\"replaceAround\", ReplaceAroundStep);\n  function contentBetween(doc3, from2, to) {\n    let $from = doc3.resolve(from2), dist = to - from2, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n      depth--;\n      dist--;\n    }\n    if (dist > 0) {\n      let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n      while (dist > 0) {\n        if (!next || next.isLeaf)\n          return true;\n        next = next.firstChild;\n        dist--;\n      }\n    }\n    return false;\n  }\n  function addMark(tr, from2, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from2, to, (node, pos, parent) => {\n      if (!node.isInline)\n        return;\n      let marks2 = node.marks;\n      if (!mark.isInSet(marks2) && parent.type.allowsMarkType(mark.type)) {\n        let start = Math.max(pos, from2), end = Math.min(pos + node.nodeSize, to);\n        let newSet = mark.addToSet(marks2);\n        for (let i = 0; i < marks2.length; i++) {\n          if (!marks2[i].isInSet(newSet)) {\n            if (removing && removing.to == start && removing.mark.eq(marks2[i]))\n              removing.to = end;\n            else\n              removed.push(removing = new RemoveMarkStep(start, end, marks2[i]));\n          }\n        }\n        if (adding && adding.to == start)\n          adding.to = end;\n        else\n          added.push(adding = new AddMarkStep(start, end, mark));\n      }\n    });\n    removed.forEach((s) => tr.step(s));\n    added.forEach((s) => tr.step(s));\n  }\n  function removeMark(tr, from2, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from2, to, (node, pos) => {\n      if (!node.isInline)\n        return;\n      step++;\n      let toRemove = null;\n      if (mark instanceof MarkType) {\n        let set = node.marks, found2;\n        while (found2 = mark.isInSet(set)) {\n          (toRemove || (toRemove = [])).push(found2);\n          set = found2.removeFromSet(set);\n        }\n      } else if (mark) {\n        if (mark.isInSet(node.marks))\n          toRemove = [mark];\n      } else {\n        toRemove = node.marks;\n      }\n      if (toRemove && toRemove.length) {\n        let end = Math.min(pos + node.nodeSize, to);\n        for (let i = 0; i < toRemove.length; i++) {\n          let style = toRemove[i], found2;\n          for (let j = 0; j < matched.length; j++) {\n            let m = matched[j];\n            if (m.step == step - 1 && style.eq(matched[j].style))\n              found2 = m;\n          }\n          if (found2) {\n            found2.to = end;\n            found2.step = step;\n          } else {\n            matched.push({ style, from: Math.max(pos, from2), to: end, step });\n          }\n        }\n      }\n    });\n    matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n  }\n  function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n      let child = node.child(i), end = cur + child.nodeSize;\n      let allowed = match.matchType(child.type);\n      if (!allowed) {\n        replSteps.push(new ReplaceStep(cur, end, Slice.empty));\n      } else {\n        match = allowed;\n        for (let j = 0; j < child.marks.length; j++)\n          if (!parentType.allowsMarkType(child.marks[j].type))\n            tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n        if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n          let m, newline = /\\r?\\n|\\r/g, slice2;\n          while (m = newline.exec(child.text)) {\n            if (!slice2)\n              slice2 = new Slice(Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));\n          }\n        }\n      }\n      cur = end;\n    }\n    if (!match.validEnd) {\n      let fill = match.fillBefore(Fragment.empty, true);\n      tr.replace(cur, cur, new Slice(fill, 0, 0));\n    }\n    for (let i = replSteps.length - 1; i >= 0; i--)\n      tr.step(replSteps[i]);\n  }\n  function canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n  }\n  function liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for (let depth = range.depth; ; --depth) {\n      let node = range.$from.node(depth);\n      let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n      if (depth < range.depth && node.canReplace(index, endIndex, content))\n        return depth;\n      if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n        break;\n    }\n    return null;\n  }\n  function lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n      if (splitting || $from.index(d) > 0) {\n        splitting = true;\n        before = Fragment.from($from.node(d).copy(before));\n        openStart++;\n      } else {\n        start--;\n      }\n    let after = Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n      if (splitting || $to.after(d + 1) < $to.end(d)) {\n        splitting = true;\n        after = Fragment.from($to.node(d).copy(after));\n        openEnd++;\n      } else {\n        end++;\n      }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n  }\n  function wrap(tr, range, wrappers) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n      if (content.size) {\n        let match = wrappers[i].type.contentMatch.matchFragment(content);\n        if (!match || !match.validEnd)\n          throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n      }\n      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));\n  }\n  function setBlockType(tr, from2, to, type, attrs) {\n    if (!type.isTextblock)\n      throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from2, to, (node, pos) => {\n      let attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n      if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n        let convertNewlines = null;\n        if (type.schema.linebreakReplacement) {\n          let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n          if (pre && !supportLinebreak)\n            convertNewlines = false;\n          else if (!pre && supportLinebreak)\n            convertNewlines = true;\n        }\n        if (convertNewlines === false)\n          replaceLinebreaks(tr, node, pos, mapFrom);\n        clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);\n        let mapping = tr.mapping.slice(mapFrom);\n        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n        if (convertNewlines === true)\n          replaceNewlines(tr, node, pos, mapFrom);\n        return false;\n      }\n    });\n  }\n  function replaceNewlines(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n      if (child.isText) {\n        let m, newline = /\\r?\\n|\\r/g;\n        while (m = newline.exec(child.text)) {\n          let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n          tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n        }\n      }\n    });\n  }\n  function replaceLinebreaks(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n      if (child.type == child.type.schema.linebreakReplacement) {\n        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n        tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n      }\n    });\n  }\n  function canChangeType(doc3, pos, type) {\n    let $pos = doc3.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n  }\n  function setNodeMarkup(tr, pos, type, attrs, marks2) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n      throw new RangeError(\"No node at given position\");\n    if (!type)\n      type = node.type;\n    let newNode = type.create(attrs, null, marks2 || node.marks);\n    if (node.isLeaf)\n      return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n      throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));\n  }\n  function canSplit(doc3, pos, depth = 1, typesAfter) {\n    let $pos = doc3.resolve(pos), base2 = $pos.depth - depth;\n    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n      return false;\n    for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {\n      let node = $pos.node(d), index2 = $pos.index(d);\n      if (node.type.spec.isolating)\n        return false;\n      let rest = node.content.cutByIndex(index2, node.childCount);\n      let overrideChild = typesAfter && typesAfter[i + 1];\n      if (overrideChild)\n        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n      let after = typesAfter && typesAfter[i] || node;\n      if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))\n        return false;\n    }\n    let index = $pos.indexAfter(base2);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);\n  }\n  function split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n      before = Fragment.from($pos.node(d).copy(before));\n      let typeAfter = typesAfter && typesAfter[i];\n      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));\n  }\n  function canJoin(doc3, pos) {\n    let $pos = doc3.resolve(pos), index = $pos.index();\n    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n  }\n  function canAppendWithSubstitutedLinebreaks(a, b) {\n    if (!b.content.size)\n      a.type.compatibleContent(b.type);\n    let match = a.contentMatchAt(a.childCount);\n    let { linebreakReplacement } = a.type.schema;\n    for (let i = 0; i < b.childCount; i++) {\n      let child = b.child(i);\n      let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n      match = match.matchType(type);\n      if (!match)\n        return false;\n      if (!a.type.allowsMarks(child.marks))\n        return false;\n    }\n    return match.validEnd;\n  }\n  function joinable2(a, b) {\n    return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n  }\n  function join(tr, pos, depth) {\n    let convertNewlines = null;\n    let { linebreakReplacement } = tr.doc.type.schema;\n    let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;\n    if (linebreakReplacement && beforeType.inlineContent) {\n      let pre = beforeType.whitespace == \"pre\";\n      let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n      if (pre && !supportLinebreak)\n        convertNewlines = false;\n      else if (!pre && supportLinebreak)\n        convertNewlines = true;\n    }\n    let mapFrom = tr.steps.length;\n    if (convertNewlines === false) {\n      let $after = tr.doc.resolve(pos + depth);\n      replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n    }\n    if (beforeType.inlineContent)\n      clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n    let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);\n    tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));\n    if (convertNewlines === true) {\n      let $full = tr.doc.resolve(start);\n      replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n    }\n    return tr;\n  }\n  function insertPoint(doc3, pos, nodeType) {\n    let $pos = doc3.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n      return pos;\n    if ($pos.parentOffset == 0)\n      for (let d = $pos.depth - 1; d >= 0; d--) {\n        let index = $pos.index(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType))\n          return $pos.before(d + 1);\n        if (index > 0)\n          return null;\n      }\n    if ($pos.parentOffset == $pos.parent.content.size)\n      for (let d = $pos.depth - 1; d >= 0; d--) {\n        let index = $pos.indexAfter(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType))\n          return $pos.after(d + 1);\n        if (index < $pos.node(d).childCount)\n          return null;\n      }\n    return null;\n  }\n  function dropPoint(doc3, pos, slice2) {\n    let $pos = doc3.resolve(pos);\n    if (!slice2.content.size)\n      return pos;\n    let content = slice2.content;\n    for (let i = 0; i < slice2.openStart; i++)\n      content = content.firstChild.content;\n    for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {\n      for (let d = $pos.depth; d >= 0; d--) {\n        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n        let parent = $pos.node(d), fits = false;\n        if (pass == 1) {\n          fits = parent.canReplace(insertPos, insertPos, content);\n        } else {\n          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n        }\n        if (fits)\n          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n      }\n    }\n    return null;\n  }\n  function replaceStep(doc3, from2, to = from2, slice2 = Slice.empty) {\n    if (from2 == to && !slice2.size)\n      return null;\n    let $from = doc3.resolve(from2), $to = doc3.resolve(to);\n    if (fitsTrivially($from, $to, slice2))\n      return new ReplaceStep(from2, to, slice2);\n    return new Fitter($from, $to, slice2).fit();\n  }\n  function fitsTrivially($from, $to, slice2) {\n    return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);\n  }\n  var Fitter = class {\n    constructor($from, $to, unplaced) {\n      this.$from = $from;\n      this.$to = $to;\n      this.unplaced = unplaced;\n      this.frontier = [];\n      this.placed = Fragment.empty;\n      for (let i = 0; i <= $from.depth; i++) {\n        let node = $from.node(i);\n        this.frontier.push({\n          type: node.type,\n          match: node.contentMatchAt($from.indexAfter(i))\n        });\n      }\n      for (let i = $from.depth; i > 0; i--)\n        this.placed = Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() {\n      return this.frontier.length - 1;\n    }\n    fit() {\n      while (this.unplaced.size) {\n        let fit = this.findFittable();\n        if (fit)\n          this.placeNodes(fit);\n        else\n          this.openMore() || this.dropNode();\n      }\n      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n      if (!$to)\n        return null;\n      let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n      while (openStart && openEnd && content.childCount == 1) {\n        content = content.firstChild.content;\n        openStart--;\n        openEnd--;\n      }\n      let slice2 = new Slice(content, openStart, openEnd);\n      if (moveInline > -1)\n        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);\n      if (slice2.size || $from.pos != this.$to.pos)\n        return new ReplaceStep($from.pos, $to.pos, slice2);\n      return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n      let startDepth = this.unplaced.openStart;\n      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n        let node = cur.firstChild;\n        if (cur.childCount > 1)\n          openEnd = 0;\n        if (node.type.spec.isolating && openEnd <= d) {\n          startDepth = d;\n          break;\n        }\n        cur = node.content;\n      }\n      for (let pass = 1; pass <= 2; pass++) {\n        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n          let fragment, parent = null;\n          if (sliceDepth) {\n            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n            fragment = parent.content;\n          } else {\n            fragment = this.unplaced.content;\n          }\n          let first = fragment.firstChild;\n          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n            let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;\n            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))\n              return { sliceDepth, frontierDepth, parent, inject };\n            else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))\n              return { sliceDepth, frontierDepth, parent, wrap: wrap2 };\n            if (parent && match.matchType(parent.type))\n              break;\n          }\n        }\n      }\n    }\n    openMore() {\n      let { content, openStart, openEnd } = this.unplaced;\n      let inner = contentAt(content, openStart);\n      if (!inner.childCount || inner.firstChild.isLeaf)\n        return false;\n      this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n      return true;\n    }\n    dropNode() {\n      let { content, openStart, openEnd } = this.unplaced;\n      let inner = contentAt(content, openStart);\n      if (inner.childCount <= 1 && openStart > 0) {\n        let openAtEnd = content.size - openStart <= openStart + inner.size;\n        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n      } else {\n        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n      }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {\n      while (this.depth > frontierDepth)\n        this.closeFrontierNode();\n      if (wrap2)\n        for (let i = 0; i < wrap2.length; i++)\n          this.openFrontierNode(wrap2[i]);\n      let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;\n      let openStart = slice2.openStart - sliceDepth;\n      let taken = 0, add2 = [];\n      let { match, type } = this.frontier[frontierDepth];\n      if (inject) {\n        for (let i = 0; i < inject.childCount; i++)\n          add2.push(inject.child(i));\n        match = match.matchFragment(inject);\n      }\n      let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);\n      while (taken < fragment.childCount) {\n        let next = fragment.child(taken), matches2 = match.matchType(next.type);\n        if (!matches2)\n          break;\n        taken++;\n        if (taken > 1 || openStart == 0 || next.content.size) {\n          match = matches2;\n          add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n        }\n      }\n      let toEnd = taken == fragment.childCount;\n      if (!toEnd)\n        openEndCount = -1;\n      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));\n      this.frontier[frontierDepth].match = match;\n      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n        this.closeFrontierNode();\n      for (let i = 0, cur = fragment; i < openEndCount; i++) {\n        let node = cur.lastChild;\n        this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n        cur = node.content;\n      }\n      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n      if (!this.$to.parent.isTextblock)\n        return -1;\n      let top = this.frontier[this.depth], level;\n      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)\n        return -1;\n      let { depth } = this.$to, after = this.$to.after(depth);\n      while (depth > 1 && after == this.$to.end(--depth))\n        ++after;\n      return after;\n    }\n    findCloseLevel($to) {\n      scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n        let { match, type } = this.frontier[i];\n        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n        let fit = contentAfterFits($to, i, type, match, dropInner);\n        if (!fit)\n          continue;\n        for (let d = i - 1; d >= 0; d--) {\n          let { match: match2, type: type2 } = this.frontier[d];\n          let matches2 = contentAfterFits($to, d, type2, match2, true);\n          if (!matches2 || matches2.childCount)\n            continue scan;\n        }\n        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n      }\n    }\n    close($to) {\n      let close2 = this.findCloseLevel($to);\n      if (!close2)\n        return null;\n      while (this.depth > close2.depth)\n        this.closeFrontierNode();\n      if (close2.fit.childCount)\n        this.placed = addToFragment(this.placed, close2.depth, close2.fit);\n      $to = close2.move;\n      for (let d = close2.depth + 1; d <= $to.depth; d++) {\n        let node = $to.node(d), add2 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n        this.openFrontierNode(node.type, node.attrs, add2);\n      }\n      return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n      let top = this.frontier[this.depth];\n      top.match = top.match.matchType(type);\n      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n      this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n      let open = this.frontier.pop();\n      let add2 = open.match.fillBefore(Fragment.empty, true);\n      if (add2.childCount)\n        this.placed = addToFragment(this.placed, this.frontier.length, add2);\n    }\n  };\n  function dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n      return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n  }\n  function addToFragment(fragment, depth, content) {\n    if (depth == 0)\n      return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n  }\n  function contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n      fragment = fragment.firstChild.content;\n    return fragment;\n  }\n  function closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n      return node;\n    let frag = node.content;\n    if (openStart > 1)\n      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n      frag = node.type.contentMatch.fillBefore(frag).append(frag);\n      if (openEnd <= 0)\n        frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));\n    }\n    return node.copy(frag);\n  }\n  function contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n      return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n  }\n  function invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n      if (!type.allowsMarks(fragment.child(i).marks))\n        return true;\n    return false;\n  }\n  function definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n  }\n  function replaceRange(tr, from2, to, slice2) {\n    if (!slice2.size)\n      return tr.deleteRange(from2, to);\n    let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice2))\n      return tr.step(new ReplaceStep(from2, to, slice2));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    if (targetDepths[targetDepths.length - 1] == 0)\n      targetDepths.pop();\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n      let spec = $from.node(d).type.spec;\n      if (spec.defining || spec.definingAsContext || spec.isolating)\n        break;\n      if (targetDepths.indexOf(d) > -1)\n        preferredTarget = d;\n      else if ($from.before(d) == pos)\n        targetDepths.splice(1, 0, -d);\n    }\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice2.openStart;\n    for (let content = slice2.content, i = 0; ; i++) {\n      let node = content.firstChild;\n      leftNodes.push(node);\n      if (i == slice2.openStart)\n        break;\n      content = node.content;\n    }\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n      let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))\n        preferredDepth = d;\n      else if (def || !leftNode.type.isTextblock)\n        break;\n    }\n    for (let j = slice2.openStart; j >= 0; j--) {\n      let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);\n      let insert = leftNodes[openDepth];\n      if (!insert)\n        continue;\n      for (let i = 0; i < targetDepths.length; i++) {\n        let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n        if (targetDepth < 0) {\n          expand = false;\n          targetDepth = -targetDepth;\n        }\n        let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n        if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n          return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));\n      }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n      tr.replace(from2, to, slice2);\n      if (tr.steps.length > startSteps)\n        break;\n      let depth = targetDepths[i];\n      if (depth < 0)\n        continue;\n      from2 = $from.before(depth);\n      to = $to.after(depth);\n    }\n  }\n  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n      let first = fragment.firstChild;\n      fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n      let match = parent.contentMatchAt(0);\n      let start = match.fillBefore(fragment).append(fragment);\n      fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n    }\n    return fragment;\n  }\n  function replaceRangeWith(tr, from2, to, node) {\n    if (!node.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {\n      let point = insertPoint(tr.doc, from2, node.type);\n      if (point != null)\n        from2 = to = point;\n    }\n    tr.replaceRange(from2, to, new Slice(Fragment.from(node), 0, 0));\n  }\n  function deleteRange(tr, from2, to) {\n    let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n      let depth = covered[i], last = i == covered.length - 1;\n      if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)\n        return tr.delete($from.start(depth), $to.end(depth));\n      if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n        return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n      if (from2 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))\n        return tr.delete($from.before(d), to);\n    }\n    tr.delete(from2, to);\n  }\n  function coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n      let start = $from.start(d);\n      if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)\n        break;\n      if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)\n        result.push(d);\n    }\n    return result;\n  }\n  var AttrStep = class _AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(pos, attr, value) {\n      super();\n      this.pos = pos;\n      this.attr = attr;\n      this.value = value;\n    }\n    apply(doc3) {\n      let node = doc3.nodeAt(this.pos);\n      if (!node)\n        return StepResult.fail(\"No node at attribute step's position\");\n      let attrs = /* @__PURE__ */ Object.create(null);\n      for (let name in node.attrs)\n        attrs[name] = node.attrs[name];\n      attrs[this.attr] = this.value;\n      let updated = node.type.create(attrs, null, node.marks);\n      return StepResult.fromReplace(doc3, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n      return StepMap.empty;\n    }\n    invert(doc3) {\n      return new _AttrStep(this.pos, this.attr, doc3.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n      let pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n      return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema2, json) {\n      if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n        throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n      return new _AttrStep(json.pos, json.attr, json.value);\n    }\n  };\n  Step.jsonID(\"attr\", AttrStep);\n  var DocAttrStep = class _DocAttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(attr, value) {\n      super();\n      this.attr = attr;\n      this.value = value;\n    }\n    apply(doc3) {\n      let attrs = /* @__PURE__ */ Object.create(null);\n      for (let name in doc3.attrs)\n        attrs[name] = doc3.attrs[name];\n      attrs[this.attr] = this.value;\n      let updated = doc3.type.create(attrs, doc3.content, doc3.marks);\n      return StepResult.ok(updated);\n    }\n    getMap() {\n      return StepMap.empty;\n    }\n    invert(doc3) {\n      return new _DocAttrStep(this.attr, doc3.attrs[this.attr]);\n    }\n    map(mapping) {\n      return this;\n    }\n    toJSON() {\n      return { stepType: \"docAttr\", attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema2, json) {\n      if (typeof json.attr != \"string\")\n        throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n      return new _DocAttrStep(json.attr, json.value);\n    }\n  };\n  Step.jsonID(\"docAttr\", DocAttrStep);\n  var TransformError = class extends Error {\n  };\n  TransformError = function TransformError2(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError2.prototype;\n    return err;\n  };\n  TransformError.prototype = Object.create(Error.prototype);\n  TransformError.prototype.constructor = TransformError;\n  TransformError.prototype.name = \"TransformError\";\n  var Transform = class {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(doc3) {\n      this.doc = doc3;\n      this.steps = [];\n      this.docs = [];\n      this.mapping = new Mapping();\n    }\n    /**\n    The starting document.\n    */\n    get before() {\n      return this.docs.length ? this.docs[0] : this.doc;\n    }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n      let result = this.maybeStep(step);\n      if (result.failed)\n        throw new TransformError(result.failed);\n      return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n      let result = step.apply(this.doc);\n      if (!result.failed)\n        this.addStep(step, result.doc);\n      return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n      return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc3) {\n      this.docs.push(this.doc);\n      this.steps.push(step);\n      this.mapping.appendMap(step.getMap());\n      this.doc = doc3;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from2, to = from2, slice2 = Slice.empty) {\n      let step = replaceStep(this.doc, from2, to, slice2);\n      if (step)\n        this.step(step);\n      return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from2, to, content) {\n      return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from2, to) {\n      return this.replace(from2, to, Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n      return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from2, to, slice2) {\n      replaceRange(this, from2, to, slice2);\n      return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from2, to, node) {\n      replaceRangeWith(this, from2, to, node);\n      return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from2, to) {\n      deleteRange(this, from2, to);\n      return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n      lift(this, range, target);\n      return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n      join(this, pos, depth);\n      return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n      wrap(this, range, wrappers);\n      return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from2, to = from2, type, attrs = null) {\n      setBlockType(this, from2, to, type, attrs);\n      return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks2) {\n      setNodeMarkup(this, pos, type, attrs, marks2);\n      return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */\n    setNodeAttribute(pos, attr, value) {\n      this.step(new AttrStep(pos, attr, value));\n      return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */\n    setDocAttribute(attr, value) {\n      this.step(new DocAttrStep(attr, value));\n      return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n      this.step(new AddNodeMarkStep(pos, mark));\n      return this;\n    }\n    /**\n    Remove a mark (or all marks of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n      let node = this.doc.nodeAt(pos);\n      if (!node)\n        throw new RangeError(\"No node at position \" + pos);\n      if (mark instanceof Mark) {\n        if (mark.isInSet(node.marks))\n          this.step(new RemoveNodeMarkStep(pos, mark));\n      } else {\n        let set = node.marks, found2, steps = [];\n        while (found2 = mark.isInSet(set)) {\n          steps.push(new RemoveNodeMarkStep(pos, found2));\n          set = found2.removeFromSet(set);\n        }\n        for (let i = steps.length - 1; i >= 0; i--)\n          this.step(steps[i]);\n      }\n      return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split (with the outermost nodes coming first).\n    */\n    split(pos, depth = 1, typesAfter) {\n      split(this, pos, depth, typesAfter);\n      return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from2, to, mark) {\n      addMark(this, from2, to, mark);\n      return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from2, to, mark) {\n      removeMark(this, from2, to, mark);\n      return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n      clearIncompatible(this, pos, parentType, match);\n      return this;\n    }\n  };\n\n  // node_modules/prosemirror-state/dist/index.js\n  var classesById = /* @__PURE__ */ Object.create(null);\n  var Selection = class {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor($anchor, $head, ranges) {\n      this.$anchor = $anchor;\n      this.$head = $head;\n      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection's anchor, as an unresolved position.\n    */\n    get anchor() {\n      return this.$anchor.pos;\n    }\n    /**\n    The selection's head.\n    */\n    get head() {\n      return this.$head.pos;\n    }\n    /**\n    The lower bound of the selection's main range.\n    */\n    get from() {\n      return this.$from.pos;\n    }\n    /**\n    The upper bound of the selection's main range.\n    */\n    get to() {\n      return this.$to.pos;\n    }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n    get $from() {\n      return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n    get $to() {\n      return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n      let ranges = this.ranges;\n      for (let i = 0; i < ranges.length; i++)\n        if (ranges[i].$from.pos != ranges[i].$to.pos)\n          return false;\n      return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n      return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = Slice.empty) {\n      let lastNode = content.content.lastChild, lastParent = null;\n      for (let i = 0; i < content.openEnd; i++) {\n        lastParent = lastNode;\n        lastNode = lastNode.lastChild;\n      }\n      let mapFrom = tr.steps.length, ranges = this.ranges;\n      for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n        if (i == 0)\n          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n      }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n      let mapFrom = tr.steps.length, ranges = this.ranges;\n      for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n        let from2 = mapping.map($from.pos), to = mapping.map($to.pos);\n        if (i) {\n          tr.deleteRange(from2, to);\n        } else {\n          tr.replaceRangeWith(from2, to, node);\n          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n        }\n      }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n      if (inner)\n        return inner;\n      for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n        if (found2)\n          return found2;\n      }\n      return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc3) {\n      return findSelectionIn(doc3, doc3, 0, 0, 1) || new AllSelection(doc3);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc3) {\n      return findSelectionIn(doc3, doc3, doc3.content.size, doc3.childCount, -1) || new AllSelection(doc3);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc3, json) {\n      if (!json || !json.type)\n        throw new RangeError(\"Invalid input for Selection.fromJSON\");\n      let cls = classesById[json.type];\n      if (!cls)\n        throw new RangeError(`No selection type ${json.type} defined`);\n      return cls.fromJSON(doc3, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id, selectionClass) {\n      if (id in classesById)\n        throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n      classesById[id] = selectionClass;\n      selectionClass.prototype.jsonID = id;\n      return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n      return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n  };\n  Selection.prototype.visible = true;\n  var SelectionRange = class {\n    /**\n    Create a range.\n    */\n    constructor($from, $to) {\n      this.$from = $from;\n      this.$to = $to;\n    }\n  };\n  var warnedAboutTextSelection = false;\n  function checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n      warnedAboutTextSelection = true;\n      console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n    }\n  }\n  var TextSelection = class _TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n      checkTextSelection($anchor);\n      checkTextSelection($head);\n      super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() {\n      return this.$anchor.pos == this.$head.pos ? this.$head : null;\n    }\n    map(doc3, mapping) {\n      let $head = doc3.resolve(mapping.map(this.head));\n      if (!$head.parent.inlineContent)\n        return Selection.near($head);\n      let $anchor = doc3.resolve(mapping.map(this.anchor));\n      return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = Slice.empty) {\n      super.replace(tr, content);\n      if (content == Slice.empty) {\n        let marks2 = this.$from.marksAcross(this.$to);\n        if (marks2)\n          tr.ensureMarks(marks2);\n      }\n    }\n    eq(other) {\n      return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n      return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n      return { type: \"text\", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc3, json) {\n      if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n        throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n      return new _TextSelection(doc3.resolve(json.anchor), doc3.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc3, anchor, head = anchor) {\n      let $anchor = doc3.resolve(anchor);\n      return new this($anchor, head == anchor ? $anchor : doc3.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n      let dPos = $anchor.pos - $head.pos;\n      if (!bias || dPos)\n        bias = dPos >= 0 ? 1 : -1;\n      if (!$head.parent.inlineContent) {\n        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n        if (found2)\n          $head = found2.$head;\n        else\n          return Selection.near($head, bias);\n      }\n      if (!$anchor.parent.inlineContent) {\n        if (dPos == 0) {\n          $anchor = $head;\n        } else {\n          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n          if ($anchor.pos < $head.pos != dPos < 0)\n            $anchor = $head;\n        }\n      }\n      return new _TextSelection($anchor, $head);\n    }\n  };\n  Selection.jsonID(\"text\", TextSelection);\n  var TextBookmark = class _TextBookmark {\n    constructor(anchor, head) {\n      this.anchor = anchor;\n      this.head = head;\n    }\n    map(mapping) {\n      return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc3) {\n      return TextSelection.between(doc3.resolve(this.anchor), doc3.resolve(this.head));\n    }\n  };\n  var NodeSelection = class _NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n      let node = $pos.nodeAfter;\n      let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n      super($pos, $end);\n      this.node = node;\n    }\n    map(doc3, mapping) {\n      let { deleted, pos } = mapping.mapResult(this.anchor);\n      let $pos = doc3.resolve(pos);\n      if (deleted)\n        return Selection.near($pos);\n      return new _NodeSelection($pos);\n    }\n    content() {\n      return new Slice(Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n      return other instanceof _NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n      return { type: \"node\", anchor: this.anchor };\n    }\n    getBookmark() {\n      return new NodeBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc3, json) {\n      if (typeof json.anchor != \"number\")\n        throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n      return new _NodeSelection(doc3.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc3, from2) {\n      return new _NodeSelection(doc3.resolve(from2));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n      return !node.isText && node.type.spec.selectable !== false;\n    }\n  };\n  NodeSelection.prototype.visible = false;\n  Selection.jsonID(\"node\", NodeSelection);\n  var NodeBookmark = class _NodeBookmark {\n    constructor(anchor) {\n      this.anchor = anchor;\n    }\n    map(mapping) {\n      let { deleted, pos } = mapping.mapResult(this.anchor);\n      return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);\n    }\n    resolve(doc3) {\n      let $pos = doc3.resolve(this.anchor), node = $pos.nodeAfter;\n      if (node && NodeSelection.isSelectable(node))\n        return new NodeSelection($pos);\n      return Selection.near($pos);\n    }\n  };\n  var AllSelection = class _AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc3) {\n      super(doc3.resolve(0), doc3.resolve(doc3.content.size));\n    }\n    replace(tr, content = Slice.empty) {\n      if (content == Slice.empty) {\n        tr.delete(0, tr.doc.content.size);\n        let sel = Selection.atStart(tr.doc);\n        if (!sel.eq(tr.selection))\n          tr.setSelection(sel);\n      } else {\n        super.replace(tr, content);\n      }\n    }\n    toJSON() {\n      return { type: \"all\" };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc3) {\n      return new _AllSelection(doc3);\n    }\n    map(doc3) {\n      return new _AllSelection(doc3);\n    }\n    eq(other) {\n      return other instanceof _AllSelection;\n    }\n    getBookmark() {\n      return AllBookmark;\n    }\n  };\n  Selection.jsonID(\"all\", AllSelection);\n  var AllBookmark = {\n    map() {\n      return this;\n    },\n    resolve(doc3) {\n      return new AllSelection(doc3);\n    }\n  };\n  function findSelectionIn(doc3, node, pos, index, dir, text = false) {\n    if (node.inlineContent)\n      return TextSelection.create(doc3, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n      let child = node.child(i);\n      if (!child.isAtom) {\n        let inner = findSelectionIn(doc3, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n        if (inner)\n          return inner;\n      } else if (!text && NodeSelection.isSelectable(child)) {\n        return NodeSelection.create(doc3, pos - (dir < 0 ? child.nodeSize : 0));\n      }\n      pos += child.nodeSize * dir;\n    }\n    return null;\n  }\n  function selectionToInsertionEnd(tr, startLen, bias) {\n    let last = tr.steps.length - 1;\n    if (last < startLen)\n      return;\n    let step = tr.steps[last];\n    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))\n      return;\n    let map2 = tr.mapping.maps[last], end;\n    map2.forEach((_from, _to, _newFrom, newTo) => {\n      if (end == null)\n        end = newTo;\n    });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n  }\n  var UPDATED_SEL = 1;\n  var UPDATED_MARKS = 2;\n  var UPDATED_SCROLL = 4;\n  var Transaction = class extends Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n      super(state.doc);\n      this.curSelectionFor = 0;\n      this.updated = 0;\n      this.meta = /* @__PURE__ */ Object.create(null);\n      this.time = Date.now();\n      this.curSelection = state.selection;\n      this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction's current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n      if (this.curSelectionFor < this.steps.length) {\n        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n        this.curSelectionFor = this.steps.length;\n      }\n      return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n      if (selection.$from.doc != this.doc)\n        throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n      this.curSelection = selection;\n      this.curSelectionFor = this.steps.length;\n      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n      this.storedMarks = null;\n      return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n      return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks2) {\n      this.storedMarks = marks2;\n      this.updated |= UPDATED_MARKS;\n      return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks2) {\n      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks2))\n        this.setStoredMarks(marks2);\n      return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n      return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc3) {\n      super.addStep(step, doc3);\n      this.updated = this.updated & ~UPDATED_MARKS;\n      this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n      this.time = time;\n      return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice2) {\n      this.selection.replace(this, slice2);\n      return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n      let selection = this.selection;\n      if (inheritMarks)\n        node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));\n      selection.replaceWith(this, node);\n      return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n      this.selection.replace(this);\n      return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text, from2, to) {\n      let schema2 = this.doc.type.schema;\n      if (from2 == null) {\n        if (!text)\n          return this.deleteSelection();\n        return this.replaceSelectionWith(schema2.text(text), true);\n      } else {\n        if (to == null)\n          to = from2;\n        to = to == null ? from2 : to;\n        if (!text)\n          return this.deleteRange(from2, to);\n        let marks2 = this.storedMarks;\n        if (!marks2) {\n          let $from = this.doc.resolve(from2);\n          marks2 = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n        }\n        this.replaceRangeWith(from2, to, schema2.text(text, marks2));\n        if (!this.selection.empty)\n          this.setSelection(Selection.near(this.selection.$to));\n        return this;\n      }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n      this.meta[typeof key == \"string\" ? key : key.key] = value;\n      return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n      return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n      for (let _ in this.meta)\n        return false;\n      return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n      this.updated |= UPDATED_SCROLL;\n      return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n      return (this.updated & UPDATED_SCROLL) > 0;\n    }\n  };\n  function bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n  }\n  var FieldDesc = class {\n    constructor(name, desc, self) {\n      this.name = name;\n      this.init = bind(desc.init, self);\n      this.apply = bind(desc.apply, self);\n    }\n  };\n  var baseFields = [\n    new FieldDesc(\"doc\", {\n      init(config) {\n        return config.doc || config.schema.topNodeType.createAndFill();\n      },\n      apply(tr) {\n        return tr.doc;\n      }\n    }),\n    new FieldDesc(\"selection\", {\n      init(config, instance) {\n        return config.selection || Selection.atStart(instance.doc);\n      },\n      apply(tr) {\n        return tr.selection;\n      }\n    }),\n    new FieldDesc(\"storedMarks\", {\n      init(config) {\n        return config.storedMarks || null;\n      },\n      apply(tr, _marks, _old, state) {\n        return state.selection.$cursor ? tr.storedMarks : null;\n      }\n    }),\n    new FieldDesc(\"scrollToSelection\", {\n      init() {\n        return 0;\n      },\n      apply(tr, prev) {\n        return tr.scrolledIntoView ? prev + 1 : prev;\n      }\n    })\n  ];\n  var Configuration = class {\n    constructor(schema2, plugins) {\n      this.schema = schema2;\n      this.plugins = [];\n      this.pluginsByKey = /* @__PURE__ */ Object.create(null);\n      this.fields = baseFields.slice();\n      if (plugins)\n        plugins.forEach((plugin) => {\n          if (this.pluginsByKey[plugin.key])\n            throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n          this.plugins.push(plugin);\n          this.pluginsByKey[plugin.key] = plugin;\n          if (plugin.spec.state)\n            this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n        });\n    }\n  };\n  var EditorState = class _EditorState {\n    /**\n    @internal\n    */\n    constructor(config) {\n      this.config = config;\n    }\n    /**\n    The schema of the state's document.\n    */\n    get schema() {\n      return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n      return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n      return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n    filterTransaction(tr, ignore = -1) {\n      for (let i = 0; i < this.config.plugins.length; i++)\n        if (i != ignore) {\n          let plugin = this.config.plugins[i];\n          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n            return false;\n        }\n      return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n      if (!this.filterTransaction(rootTr))\n        return { state: this, transactions: [] };\n      let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n      for (; ; ) {\n        let haveNew = false;\n        for (let i = 0; i < this.config.plugins.length; i++) {\n          let plugin = this.config.plugins[i];\n          if (plugin.spec.appendTransaction) {\n            let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n            let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n            if (tr && newState.filterTransaction(tr, i)) {\n              tr.setMeta(\"appendedTransaction\", rootTr);\n              if (!seen) {\n                seen = [];\n                for (let j = 0; j < this.config.plugins.length; j++)\n                  seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n              }\n              trs.push(tr);\n              newState = newState.applyInner(tr);\n              haveNew = true;\n            }\n            if (seen)\n              seen[i] = { state: newState, n: trs.length };\n          }\n        }\n        if (!haveNew)\n          return { state: newState, transactions: trs };\n      }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n      if (!tr.before.eq(this.doc))\n        throw new RangeError(\"Applying a mismatched transaction\");\n      let newInstance = new _EditorState(this.config), fields = this.config.fields;\n      for (let i = 0; i < fields.length; i++) {\n        let field = fields[i];\n        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n      }\n      return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() {\n      return new Transaction(this);\n    }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n      let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n      let instance = new _EditorState($config);\n      for (let i = 0; i < $config.fields.length; i++)\n        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n      return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n      let $config = new Configuration(this.schema, config.plugins);\n      let fields = $config.fields, instance = new _EditorState($config);\n      for (let i = 0; i < fields.length; i++) {\n        let name = fields[i].name;\n        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n      }\n      return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n      let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n      if (this.storedMarks)\n        result.storedMarks = this.storedMarks.map((m) => m.toJSON());\n      if (pluginFields && typeof pluginFields == \"object\")\n        for (let prop in pluginFields) {\n          if (prop == \"doc\" || prop == \"selection\")\n            throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n          let plugin = pluginFields[prop], state = plugin.spec.state;\n          if (state && state.toJSON)\n            result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n        }\n      return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n      if (!json)\n        throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n      if (!config.schema)\n        throw new RangeError(\"Required config field 'schema' missing\");\n      let $config = new Configuration(config.schema, config.plugins);\n      let instance = new _EditorState($config);\n      $config.fields.forEach((field) => {\n        if (field.name == \"doc\") {\n          instance.doc = Node.fromJSON(config.schema, json.doc);\n        } else if (field.name == \"selection\") {\n          instance.selection = Selection.fromJSON(instance.doc, json.selection);\n        } else if (field.name == \"storedMarks\") {\n          if (json.storedMarks)\n            instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n        } else {\n          if (pluginFields)\n            for (let prop in pluginFields) {\n              let plugin = pluginFields[prop], state = plugin.spec.state;\n              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n                instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                return;\n              }\n            }\n          instance[field.name] = field.init(config, instance);\n        }\n      });\n      return instance;\n    }\n  };\n  function bindProps(obj, self, target) {\n    for (let prop in obj) {\n      let val = obj[prop];\n      if (val instanceof Function)\n        val = val.bind(self);\n      else if (prop == \"handleDOMEvents\")\n        val = bindProps(val, self, {});\n      target[prop] = val;\n    }\n    return target;\n  }\n  var Plugin = class {\n    /**\n    Create a plugin.\n    */\n    constructor(spec) {\n      this.spec = spec;\n      this.props = {};\n      if (spec.props)\n        bindProps(spec.props, this, this.props);\n      this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n    }\n    /**\n    Extract the plugin's state field from an editor state.\n    */\n    getState(state) {\n      return state[this.key];\n    }\n  };\n  var keys = /* @__PURE__ */ Object.create(null);\n  function createKey(name) {\n    if (name in keys)\n      return name + \"$\" + ++keys[name];\n    keys[name] = 0;\n    return name + \"$\";\n  }\n  var PluginKey = class {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = \"key\") {\n      this.key = createKey(name);\n    }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) {\n      return state.config.pluginsByKey[this.key];\n    }\n    /**\n    Get the plugin's state from an editor state.\n    */\n    getState(state) {\n      return state[this.key];\n    }\n  };\n\n  // node_modules/prosemirror-view/dist/index.js\n  var domIndex = function(node) {\n    for (var index = 0; ; index++) {\n      node = node.previousSibling;\n      if (!node)\n        return index;\n    }\n  };\n  var parentNode = function(node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n  };\n  var reusedRange = null;\n  var textRange = function(node, from2, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from2 || 0);\n    return range;\n  };\n  var clearReusedRange = function() {\n    reusedRange = null;\n  };\n  var isEquivalentPosition = function(node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n  };\n  var atomElements = /^(img|br|input|textarea|hr)$/i;\n  function scanFor(node, off, targetNode, targetOff, dir) {\n    var _a;\n    for (; ; ) {\n      if (node == targetNode && off == targetOff)\n        return true;\n      if (off == (dir < 0 ? 0 : nodeSize(node))) {\n        let parent = node.parentNode;\n        if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n          return false;\n        off = domIndex(node) + (dir < 0 ? 0 : 1);\n        node = parent;\n      } else if (node.nodeType == 1) {\n        let child = node.childNodes[off + (dir < 0 ? -1 : 0)];\n        if (child.nodeType == 1 && child.contentEditable == \"false\") {\n          if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)\n            off += dir;\n          else\n            return false;\n        } else {\n          node = child;\n          off = dir < 0 ? nodeSize(node) : 0;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  function nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n  }\n  function textNodeBefore$1(node, offset) {\n    for (; ; ) {\n      if (node.nodeType == 3 && offset)\n        return node;\n      if (node.nodeType == 1 && offset > 0) {\n        if (node.contentEditable == \"false\")\n          return null;\n        node = node.childNodes[offset - 1];\n        offset = nodeSize(node);\n      } else if (node.parentNode && !hasBlockDesc(node)) {\n        offset = domIndex(node);\n        node = node.parentNode;\n      } else {\n        return null;\n      }\n    }\n  }\n  function textNodeAfter$1(node, offset) {\n    for (; ; ) {\n      if (node.nodeType == 3 && offset < node.nodeValue.length)\n        return node;\n      if (node.nodeType == 1 && offset < node.childNodes.length) {\n        if (node.contentEditable == \"false\")\n          return null;\n        node = node.childNodes[offset];\n        offset = 0;\n      } else if (node.parentNode && !hasBlockDesc(node)) {\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n      } else {\n        return null;\n      }\n    }\n  }\n  function isOnEdge(node, offset, parent) {\n    for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {\n      if (node == parent)\n        return true;\n      let index = domIndex(node);\n      node = node.parentNode;\n      if (!node)\n        return false;\n      atStart = atStart && index == 0;\n      atEnd = atEnd && index == nodeSize(node);\n    }\n  }\n  function hasBlockDesc(dom) {\n    let desc;\n    for (let cur = dom; cur; cur = cur.parentNode)\n      if (desc = cur.pmViewDesc)\n        break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n  }\n  var selectionCollapsed = function(domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n  };\n  function keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n  }\n  function deepActiveElement(doc3) {\n    let elt = doc3.activeElement;\n    while (elt && elt.shadowRoot)\n      elt = elt.shadowRoot.activeElement;\n    return elt;\n  }\n  function caretFromPoint(doc3, x, y) {\n    if (doc3.caretPositionFromPoint) {\n      try {\n        let pos = doc3.caretPositionFromPoint(x, y);\n        if (pos)\n          return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };\n      } catch (_) {\n      }\n    }\n    if (doc3.caretRangeFromPoint) {\n      let range = doc3.caretRangeFromPoint(x, y);\n      if (range)\n        return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };\n    }\n  }\n  var nav = typeof navigator != \"undefined\" ? navigator : null;\n  var doc2 = typeof document != \"undefined\" ? document : null;\n  var agent = nav && nav.userAgent || \"\";\n  var ie_edge = /Edge\\/(\\d+)/.exec(agent);\n  var ie_upto10 = /MSIE \\d/.exec(agent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\n  var ie = !!(ie_upto10 || ie_11up || ie_edge);\n  var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\n  var gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\n  gecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\n  var _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\n  var chrome = !!_chrome;\n  var chrome_version = _chrome ? +_chrome[1] : 0;\n  var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n  var ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\n  var mac = ios || (nav ? /Mac/.test(nav.platform) : false);\n  var windows = nav ? /Win/.test(nav.platform) : false;\n  var android = /Android \\d/.test(agent);\n  var webkit = !!doc2 && \"webkitFontSmoothing\" in doc2.documentElement.style;\n  var webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\n  function windowRect(doc3) {\n    let vp = doc3.defaultView && doc3.defaultView.visualViewport;\n    if (vp)\n      return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n      };\n    return {\n      left: 0,\n      right: doc3.documentElement.clientWidth,\n      top: 0,\n      bottom: doc3.documentElement.clientHeight\n    };\n  }\n  function getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n  }\n  function clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    let scaleX = rect.width / node.offsetWidth || 1;\n    let scaleY = rect.height / node.offsetHeight || 1;\n    return {\n      left: rect.left,\n      right: rect.left + node.clientWidth * scaleX,\n      top: rect.top,\n      bottom: rect.top + node.clientHeight * scaleY\n    };\n  }\n  function scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc3 = view.dom.ownerDocument;\n    for (let parent = startDOM || view.dom; ; ) {\n      if (!parent)\n        break;\n      if (parent.nodeType != 1) {\n        parent = parentNode(parent);\n        continue;\n      }\n      let elt = parent;\n      let atTop = elt == doc3.body;\n      let bounding = atTop ? windowRect(doc3) : clientRect(elt);\n      let moveX = 0, moveY = 0;\n      if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n        moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n      if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n        moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n      else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n        moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n      if (moveX || moveY) {\n        if (atTop) {\n          doc3.defaultView.scrollBy(moveX, moveY);\n        } else {\n          let startX = elt.scrollLeft, startY = elt.scrollTop;\n          if (moveY)\n            elt.scrollTop += moveY;\n          if (moveX)\n            elt.scrollLeft += moveX;\n          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n        }\n      }\n      let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n      if (/^(fixed|sticky)$/.test(pos))\n        break;\n      parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n    }\n  }\n  function storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n      let dom = view.root.elementFromPoint(x, y);\n      if (!dom || dom == view.dom || !view.dom.contains(dom))\n        continue;\n      let localRect = dom.getBoundingClientRect();\n      if (localRect.top >= startY - 20) {\n        refDOM = dom;\n        refTop = localRect.top;\n        break;\n      }\n    }\n    return { refDOM, refTop, stack: scrollStack(view.dom) };\n  }\n  function scrollStack(dom) {\n    let stack = [], doc3 = dom.ownerDocument;\n    for (let cur = dom; cur; cur = parentNode(cur)) {\n      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n      if (dom == doc3)\n        break;\n    }\n    return stack;\n  }\n  function resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n  }\n  function restoreScrollStack(stack, dTop) {\n    for (let i = 0; i < stack.length; i++) {\n      let { dom, top, left } = stack[i];\n      if (dom.scrollTop != top + dTop)\n        dom.scrollTop = top + dTop;\n      if (dom.scrollLeft != left)\n        dom.scrollLeft = left;\n    }\n  }\n  var preventScrollSupported = null;\n  function focusPreventScroll(dom) {\n    if (dom.setActive)\n      return dom.setActive();\n    if (preventScrollSupported)\n      return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n      get preventScroll() {\n        preventScrollSupported = { preventScroll: true };\n        return true;\n      }\n    } : void 0);\n    if (!preventScrollSupported) {\n      preventScrollSupported = false;\n      restoreScrollStack(stored, 0);\n    }\n  }\n  function findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n      let rects;\n      if (child.nodeType == 1)\n        rects = child.getClientRects();\n      else if (child.nodeType == 3)\n        rects = textRange(child).getClientRects();\n      else\n        continue;\n      for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.top <= rowBot && rect.bottom >= rowTop) {\n          rowBot = Math.max(rect.bottom, rowBot);\n          rowTop = Math.min(rect.top, rowTop);\n          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n          if (dx < dxClosest) {\n            closest = child;\n            dxClosest = dx;\n            coordsClosest = dx && closest.nodeType == 3 ? {\n              left: rect.right < coords.left ? rect.right : rect.left,\n              top: coords.top\n            } : coords;\n            if (child.nodeType == 1 && dx)\n              offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n            continue;\n          }\n        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n          firstBelow = child;\n          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };\n        }\n        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))\n          offset = childIndex + 1;\n      }\n    }\n    if (!closest && firstBelow) {\n      closest = firstBelow;\n      coordsClosest = coordsBelow;\n      dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3)\n      return findOffsetInText(closest, coordsClosest);\n    if (!closest || dxClosest && closest.nodeType == 1)\n      return { node, offset };\n    return findOffsetInNode(closest, coordsClosest);\n  }\n  function findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for (let i = 0; i < len; i++) {\n      range.setEnd(node, i + 1);\n      range.setStart(node, i);\n      let rect = singleRect(range, 1);\n      if (rect.top == rect.bottom)\n        continue;\n      if (inRect(coords, rect))\n        return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n    }\n    return { node, offset: 0 };\n  }\n  function inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n  }\n  function targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n      return parent;\n    return dom;\n  }\n  function posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n      let rect = node.getBoundingClientRect();\n      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n  }\n  function posFromCaret(view, node, offset, coords) {\n    let outsideBlock = -1;\n    for (let cur = node, sawBlock = false; ; ) {\n      if (cur == view.dom)\n        break;\n      let desc = view.docView.nearestDesc(cur, true), rect;\n      if (!desc)\n        return null;\n      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles\n      ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n        if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {\n          if (!sawBlock && rect.left > coords.left || rect.top > coords.top)\n            outsideBlock = desc.posBefore;\n          else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)\n            outsideBlock = desc.posAfter;\n          sawBlock = true;\n        }\n        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n          return before ? desc.posBefore : desc.posAfter;\n        }\n      }\n      cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n  }\n  function elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {\n        let child = element.childNodes[i];\n        if (child.nodeType == 1) {\n          let rects = child.getClientRects();\n          for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (inRect(coords, rect))\n              return elementFromPoint(child, coords, rect);\n          }\n        }\n        if ((i = (i + 1) % len) == startI)\n          break;\n      }\n    }\n    return element;\n  }\n  function posAtCoords(view, coords) {\n    let doc3 = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc3, coords.left, coords.top);\n    if (caret)\n      ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc3).elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n      let box = view.dom.getBoundingClientRect();\n      if (!inRect(coords, box))\n        return null;\n      elt = elementFromPoint(view.dom, coords, box);\n      if (!elt)\n        return null;\n    }\n    if (safari) {\n      for (let p = elt; node && p; p = parentNode(p))\n        if (p.draggable)\n          node = void 0;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n      if (gecko && node.nodeType == 1) {\n        offset = Math.min(offset, node.childNodes.length);\n        if (offset < node.childNodes.length) {\n          let next = node.childNodes[offset], box;\n          if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)\n            offset++;\n        }\n      }\n      let prev;\n      if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top)\n        offset--;\n      if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)\n        pos = view.state.doc.content.size;\n      else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n        pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null)\n      pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n  }\n  function nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n  }\n  function singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n      let first = rects[bias < 0 ? 0 : rects.length - 1];\n      if (nonZero(first))\n        return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n  }\n  var BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  function coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n      if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n        let rect = singleRect(textRange(node, offset, offset), side);\n        if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n          let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n          if (rectBefore.top == rect.top) {\n            let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n            if (rectAfter.top != rect.top)\n              return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n          }\n        }\n        return rect;\n      } else {\n        let from2 = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n        if (side < 0 && !offset) {\n          to++;\n          takeSide = -1;\n        } else if (side >= 0 && offset == node.nodeValue.length) {\n          from2--;\n          takeSide = 1;\n        } else if (side < 0) {\n          from2--;\n        } else {\n          to++;\n        }\n        return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);\n      }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    if (!$dom.parent.inlineContent) {\n      if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        if (before.nodeType == 1)\n          return flattenH(before.getBoundingClientRect(), false);\n      }\n      if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        if (after.nodeType == 1)\n          return flattenH(after.getBoundingClientRect(), true);\n      }\n      return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n      let before = node.childNodes[offset - 1];\n      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n      if (target)\n        return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n      let after = node.childNodes[offset];\n      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n        after = after.nextSibling;\n      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n      if (target)\n        return flattenV(singleRect(target, -1), true);\n    }\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n  }\n  function flattenV(rect, left) {\n    if (rect.width == 0)\n      return rect;\n    let x = left ? rect.left : rect.right;\n    return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n  }\n  function flattenH(rect, top) {\n    if (rect.height == 0)\n      return rect;\n    let y = top ? rect.top : rect.bottom;\n    return { top: y, bottom: y, left: rect.left, right: rect.right };\n  }\n  function withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state)\n      view.updateState(state);\n    if (active != view.dom)\n      view.focus();\n    try {\n      return f();\n    } finally {\n      if (viewState != state)\n        view.updateState(viewState);\n      if (active != view.dom && active)\n        active.focus();\n    }\n  }\n  function endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, () => {\n      let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n      for (; ; ) {\n        let nearest = view.docView.nearestDesc(dom, true);\n        if (!nearest)\n          break;\n        if (nearest.node.isBlock) {\n          dom = nearest.contentDOM || nearest.dom;\n          break;\n        }\n        dom = nearest.dom.parentNode;\n      }\n      let coords = coordsAtPos(view, $pos.pos, 1);\n      for (let child = dom.firstChild; child; child = child.nextSibling) {\n        let boxes;\n        if (child.nodeType == 1)\n          boxes = child.getClientRects();\n        else if (child.nodeType == 3)\n          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n        else\n          continue;\n        for (let i = 0; i < boxes.length; i++) {\n          let box = boxes[i];\n          if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n            return false;\n        }\n      }\n      return true;\n    });\n  }\n  var maybeRTL = /[\\u0590-\\u08ac]/;\n  function endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock)\n      return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    if (!sel)\n      return $head.pos == $head.start() || $head.pos == $head.end();\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n      return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, () => {\n      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n      let oldBidiLevel = sel.caretBidiLevel;\n      sel.modify(\"move\", dir, \"character\");\n      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n      let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n      let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n      try {\n        sel.collapse(anchorNode, anchorOffset);\n        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n          sel.extend(oldNode, oldOff);\n      } catch (_) {\n      }\n      if (oldBidiLevel != null)\n        sel.caretBidiLevel = oldBidiLevel;\n      return result;\n    });\n  }\n  var cachedState = null;\n  var cachedDir = null;\n  var cachedResult = false;\n  function endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir)\n      return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n  }\n  var NOT_DIRTY = 0;\n  var CHILD_DIRTY = 1;\n  var CONTENT_DIRTY = 2;\n  var NODE_DIRTY = 3;\n  var ViewDesc = class {\n    constructor(parent, children, dom, contentDOM) {\n      this.parent = parent;\n      this.children = children;\n      this.dom = dom;\n      this.contentDOM = contentDOM;\n      this.dirty = NOT_DIRTY;\n      dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) {\n      return false;\n    }\n    matchesMark(mark) {\n      return false;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n      return false;\n    }\n    matchesHack(nodeName) {\n      return false;\n    }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() {\n      return null;\n    }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) {\n      return false;\n    }\n    // The size of the content represented by this desc.\n    get size() {\n      let size = 0;\n      for (let i = 0; i < this.children.length; i++)\n        size += this.children[i].size;\n      return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() {\n      return 0;\n    }\n    destroy() {\n      this.parent = void 0;\n      if (this.dom.pmViewDesc == this)\n        this.dom.pmViewDesc = void 0;\n      for (let i = 0; i < this.children.length; i++)\n        this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n      for (let i = 0, pos = this.posAtStart; ; i++) {\n        let cur = this.children[i];\n        if (cur == child)\n          return pos;\n        pos += cur.size;\n      }\n    }\n    get posBefore() {\n      return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n      return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n      return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n        if (bias < 0) {\n          let domBefore, desc;\n          if (dom == this.contentDOM) {\n            domBefore = dom.childNodes[offset - 1];\n          } else {\n            while (dom.parentNode != this.contentDOM)\n              dom = dom.parentNode;\n            domBefore = dom.previousSibling;\n          }\n          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n            domBefore = domBefore.previousSibling;\n          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n        } else {\n          let domAfter, desc;\n          if (dom == this.contentDOM) {\n            domAfter = dom.childNodes[offset];\n          } else {\n            while (dom.parentNode != this.contentDOM)\n              dom = dom.parentNode;\n            domAfter = dom.nextSibling;\n          }\n          while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n            domAfter = domAfter.nextSibling;\n          return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n        }\n      }\n      let atEnd;\n      if (dom == this.dom && this.contentDOM) {\n        atEnd = offset > domIndex(this.contentDOM);\n      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n      } else if (this.dom.firstChild) {\n        if (offset == 0)\n          for (let search = dom; ; search = search.parentNode) {\n            if (search == this.dom) {\n              atEnd = false;\n              break;\n            }\n            if (search.previousSibling)\n              break;\n          }\n        if (atEnd == null && offset == dom.childNodes.length)\n          for (let search = dom; ; search = search.parentNode) {\n            if (search == this.dom) {\n              atEnd = true;\n              break;\n            }\n            if (search.nextSibling)\n              break;\n          }\n      }\n      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n      for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n        let desc = this.getDesc(cur), nodeDOM;\n        if (desc && (!onlyNodes || desc.node)) {\n          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n            first = false;\n          else\n            return desc;\n        }\n      }\n    }\n    getDesc(dom) {\n      let desc = dom.pmViewDesc;\n      for (let cur = desc; cur; cur = cur.parent)\n        if (cur == this)\n          return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n      for (let scan = dom; scan; scan = scan.parentNode) {\n        let desc = this.getDesc(scan);\n        if (desc)\n          return desc.localPosFromDOM(dom, offset, bias);\n      }\n      return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n      for (let i = 0, offset = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (offset == pos && end != offset) {\n          while (!child.border && child.children.length) {\n            for (let i2 = 0; i2 < child.children.length; i2++) {\n              let inner = child.children[i2];\n              if (inner.size) {\n                child = inner;\n                break;\n              }\n            }\n          }\n          return child;\n        }\n        if (pos < end)\n          return child.descAt(pos - offset - child.border);\n        offset = end;\n      }\n    }\n    domFromPos(pos, side) {\n      if (!this.contentDOM)\n        return { node: this.dom, offset: 0, atom: pos + 1 };\n      let i = 0, offset = 0;\n      for (let curPos = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = curPos + child.size;\n        if (end > pos || child instanceof TrailingHackViewDesc) {\n          offset = pos - curPos;\n          break;\n        }\n        curPos = end;\n      }\n      if (offset)\n        return this.children[i].domFromPos(offset - this.children[i].border, side);\n      for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {\n      }\n      if (side <= 0) {\n        let prev, enter = true;\n        for (; ; i--, enter = false) {\n          prev = i ? this.children[i - 1] : null;\n          if (!prev || prev.dom.parentNode == this.contentDOM)\n            break;\n        }\n        if (prev && side && enter && !prev.border && !prev.domAtom)\n          return prev.domFromPos(prev.size, side);\n        return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n      } else {\n        let next, enter = true;\n        for (; ; i++, enter = false) {\n          next = i < this.children.length ? this.children[i] : null;\n          if (!next || next.dom.parentNode == this.contentDOM)\n            break;\n        }\n        if (next && enter && !next.border && !next.domAtom)\n          return next.domFromPos(0, side);\n        return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n      }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from2, to, base2 = 0) {\n      if (this.children.length == 0)\n        return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n      let fromOffset = -1, toOffset = -1;\n      for (let offset = base2, i = 0; ; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (fromOffset == -1 && from2 <= end) {\n          let childBase = offset + child.border;\n          if (from2 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))\n            return child.parseRange(from2, to, childBase);\n          from2 = offset;\n          for (let j = i; j > 0; j--) {\n            let prev = this.children[j - 1];\n            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n              fromOffset = domIndex(prev.dom) + 1;\n              break;\n            }\n            from2 -= prev.size;\n          }\n          if (fromOffset == -1)\n            fromOffset = 0;\n        }\n        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n          to = end;\n          for (let j = i + 1; j < this.children.length; j++) {\n            let next = this.children[j];\n            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n              toOffset = domIndex(next.dom);\n              break;\n            }\n            to += next.size;\n          }\n          if (toOffset == -1)\n            toOffset = this.contentDOM.childNodes.length;\n          break;\n        }\n        offset = end;\n      }\n      return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };\n    }\n    emptyChildAt(side) {\n      if (this.border || !this.contentDOM || !this.children.length)\n        return false;\n      let child = this.children[side < 0 ? 0 : this.children.length - 1];\n      return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n      let { node, offset } = this.domFromPos(pos, 0);\n      if (node.nodeType != 1 || offset == node.childNodes.length)\n        throw new RangeError(\"No node after pos \" + pos);\n      return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, view, force = false) {\n      let from2 = Math.min(anchor, head), to = Math.max(anchor, head);\n      for (let i = 0, offset = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (from2 > offset && to < end)\n          return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n        offset = end;\n      }\n      let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n      let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n      let domSel = view.root.getSelection();\n      let selRange = view.domSelectionRange();\n      let brKludge = false;\n      if ((gecko || safari) && anchor == head) {\n        let { node, offset } = anchorDOM;\n        if (node.nodeType == 3) {\n          brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n          if (brKludge && offset == node.nodeValue.length) {\n            for (let scan = node, after; scan; scan = scan.parentNode) {\n              if (after = scan.nextSibling) {\n                if (after.nodeName == \"BR\")\n                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n                break;\n              }\n              let desc = scan.pmViewDesc;\n              if (desc && desc.node && desc.node.isBlock)\n                break;\n            }\n          }\n        } else {\n          let prev = node.childNodes[offset - 1];\n          brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n        }\n      }\n      if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n        let after = selRange.focusNode.childNodes[selRange.focusOffset];\n        if (after && after.contentEditable == \"false\")\n          force = true;\n      }\n      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))\n        return;\n      let domSelExtended = false;\n      if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {\n        domSel.collapse(anchorDOM.node, anchorDOM.offset);\n        try {\n          if (anchor != head)\n            domSel.extend(headDOM.node, headDOM.offset);\n          domSelExtended = true;\n        } catch (_) {\n        }\n      }\n      if (!domSelExtended) {\n        if (anchor > head) {\n          let tmp = anchorDOM;\n          anchorDOM = headDOM;\n          headDOM = tmp;\n        }\n        let range = document.createRange();\n        range.setEnd(headDOM.node, headDOM.offset);\n        range.setStart(anchorDOM.node, anchorDOM.offset);\n        domSel.removeAllRanges();\n        domSel.addRange(range);\n      }\n    }\n    ignoreMutation(mutation) {\n      return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from2, to) {\n      for (let offset = 0, i = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (offset == end ? from2 <= end && to >= offset : from2 < end && to > offset) {\n          let startInside = offset + child.border, endInside = end - child.border;\n          if (from2 >= startInside && to <= endInside) {\n            this.dirty = from2 == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))\n              child.dirty = NODE_DIRTY;\n            else\n              child.markDirty(from2 - startInside, to - startInside);\n            return;\n          } else {\n            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n          }\n        }\n        offset = end;\n      }\n      this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n      let level = 1;\n      for (let node = this.parent; node; node = node.parent, level++) {\n        let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n        if (node.dirty < dirty)\n          node.dirty = dirty;\n      }\n    }\n    get domAtom() {\n      return false;\n    }\n    get ignoreForCoords() {\n      return false;\n    }\n    get ignoreForSelection() {\n      return false;\n    }\n    isText(text) {\n      return false;\n    }\n  };\n  var WidgetViewDesc = class extends ViewDesc {\n    constructor(parent, widget, view, pos) {\n      let self, dom = widget.type.toDOM;\n      if (typeof dom == \"function\")\n        dom = dom(view, () => {\n          if (!self)\n            return pos;\n          if (self.parent)\n            return self.parent.posBeforeChild(self);\n        });\n      if (!widget.type.spec.raw) {\n        if (dom.nodeType != 1) {\n          let wrap2 = document.createElement(\"span\");\n          wrap2.appendChild(dom);\n          dom = wrap2;\n        }\n        dom.contentEditable = \"false\";\n        dom.classList.add(\"ProseMirror-widget\");\n      }\n      super(parent, [], dom, null);\n      this.widget = widget;\n      this.widget = widget;\n      self = this;\n    }\n    matchesWidget(widget) {\n      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() {\n      return { ignore: true };\n    }\n    stopEvent(event) {\n      let stop = this.widget.spec.stopEvent;\n      return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n      return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n      this.widget.type.destroy(this.dom);\n      super.destroy();\n    }\n    get domAtom() {\n      return true;\n    }\n    get ignoreForSelection() {\n      return !!this.widget.type.spec.relaxedSide;\n    }\n    get side() {\n      return this.widget.type.side;\n    }\n  };\n  var CompositionViewDesc = class extends ViewDesc {\n    constructor(parent, dom, textDOM, text) {\n      super(parent, [], dom, null);\n      this.textDOM = textDOM;\n      this.text = text;\n    }\n    get size() {\n      return this.text.length;\n    }\n    localPosFromDOM(dom, offset) {\n      if (dom != this.textDOM)\n        return this.posAtStart + (offset ? this.size : 0);\n      return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n      return { node: this.textDOM, offset: pos };\n    }\n    ignoreMutation(mut) {\n      return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n    }\n  };\n  var MarkViewDesc = class _MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM, spec) {\n      super(parent, [], dom, contentDOM);\n      this.mark = mark;\n      this.spec = spec;\n    }\n    static create(parent, mark, inline, view) {\n      let custom = view.nodeViews[mark.type.name];\n      let spec = custom && custom(mark, view, inline);\n      if (!spec || !spec.dom)\n        spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n      return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n    }\n    parseRule() {\n      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)\n        return null;\n      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };\n    }\n    matchesMark(mark) {\n      return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n    markDirty(from2, to) {\n      super.markDirty(from2, to);\n      if (this.dirty != NOT_DIRTY) {\n        let parent = this.parent;\n        while (!parent.node)\n          parent = parent.parent;\n        if (parent.dirty < this.dirty)\n          parent.dirty = this.dirty;\n        this.dirty = NOT_DIRTY;\n      }\n    }\n    slice(from2, to, view) {\n      let copy2 = _MarkViewDesc.create(this.parent, this.mark, true, view);\n      let nodes2 = this.children, size = this.size;\n      if (to < size)\n        nodes2 = replaceNodes(nodes2, to, size, view);\n      if (from2 > 0)\n        nodes2 = replaceNodes(nodes2, 0, from2, view);\n      for (let i = 0; i < nodes2.length; i++)\n        nodes2[i].parent = copy2;\n      copy2.children = nodes2;\n      return copy2;\n    }\n    ignoreMutation(mutation) {\n      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n    destroy() {\n      if (this.spec.destroy)\n        this.spec.destroy();\n      super.destroy();\n    }\n  };\n  var NodeViewDesc = class _NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n      super(parent, [], dom, contentDOM);\n      this.node = node;\n      this.outerDeco = outerDeco;\n      this.innerDeco = innerDeco;\n      this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n      let custom = view.nodeViews[node.type.name], descObj;\n      let spec = custom && custom(node, view, () => {\n        if (!descObj)\n          return pos;\n        if (descObj.parent)\n          return descObj.parent.posBeforeChild(descObj);\n      }, outerDeco, innerDeco);\n      let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n      if (node.isText) {\n        if (!dom)\n          dom = document.createTextNode(node.text);\n        else if (dom.nodeType != 3)\n          throw new RangeError(\"Text must be rendered as a DOM text node\");\n      } else if (!dom) {\n        let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n        ({ dom, contentDOM } = spec2);\n      }\n      if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n        if (!dom.hasAttribute(\"contenteditable\"))\n          dom.contentEditable = \"false\";\n        if (node.type.spec.draggable)\n          dom.draggable = true;\n      }\n      let nodeDOM = dom;\n      dom = applyOuterDeco(dom, outerDeco, node);\n      if (spec)\n        return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n      else if (node.isText)\n        return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n      else\n        return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n      if (this.node.type.spec.reparseInView)\n        return null;\n      let rule = { node: this.node.type.name, attrs: this.node.attrs };\n      if (this.node.type.whitespace == \"pre\")\n        rule.preserveWhitespace = \"full\";\n      if (!this.contentDOM) {\n        rule.getContent = () => this.node.content;\n      } else if (!this.contentLost) {\n        rule.contentElement = this.contentDOM;\n      } else {\n        for (let i = this.children.length - 1; i >= 0; i--) {\n          let child = this.children[i];\n          if (this.dom.contains(child.dom.parentNode)) {\n            rule.contentElement = child.dom.parentNode;\n            break;\n          }\n        }\n        if (!rule.contentElement)\n          rule.getContent = () => Fragment.empty;\n      }\n      return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() {\n      return this.node.nodeSize;\n    }\n    get border() {\n      return this.node.isLeaf ? 0 : 1;\n    }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n      let inline = this.node.inlineContent, off = pos;\n      let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n      let localComposition = composition && composition.pos > -1 ? composition : null;\n      let compositionInChild = composition && composition.pos < 0;\n      let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n      iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n        if (widget.spec.marks)\n          updater.syncToMarks(widget.spec.marks, inline, view);\n        else if (widget.type.side >= 0 && !insideNode)\n          updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);\n        updater.placeWidget(widget, view, off);\n      }, (child, outerDeco, innerDeco, i) => {\n        updater.syncToMarks(child.marks, inline, view);\n        let compIndex;\n        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n        else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n        else {\n          updater.addNode(child, outerDeco, innerDeco, view, off);\n        }\n        off += child.nodeSize;\n      });\n      updater.syncToMarks([], inline, view);\n      if (this.node.isTextblock)\n        updater.addTextblockHacks();\n      updater.destroyRest();\n      if (updater.changed || this.dirty == CONTENT_DIRTY) {\n        if (localComposition)\n          this.protectLocalComposition(view, localComposition);\n        renderDescs(this.contentDOM, this.children, view);\n        if (ios)\n          iosHacks(this.dom);\n      }\n    }\n    localCompositionInfo(view, pos) {\n      let { from: from2, to } = view.state.selection;\n      if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)\n        return null;\n      let textNode = view.input.compositionNode;\n      if (!textNode || !this.dom.contains(textNode.parentNode))\n        return null;\n      if (this.node.inlineContent) {\n        let text = textNode.nodeValue;\n        let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);\n        return textPos < 0 ? null : { node: textNode, pos: textPos, text };\n      } else {\n        return { node: textNode, pos: -1, text: \"\" };\n      }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n      if (this.getDesc(node))\n        return;\n      let topNode = node;\n      for (; ; topNode = topNode.parentNode) {\n        if (topNode.parentNode == this.contentDOM)\n          break;\n        while (topNode.previousSibling)\n          topNode.parentNode.removeChild(topNode.previousSibling);\n        while (topNode.nextSibling)\n          topNode.parentNode.removeChild(topNode.nextSibling);\n        if (topNode.pmViewDesc)\n          topNode.pmViewDesc = void 0;\n      }\n      let desc = new CompositionViewDesc(this, topNode, node, text);\n      view.input.compositionNodes.push(desc);\n      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))\n        return false;\n      this.updateInner(node, outerDeco, innerDeco, view);\n      return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n      this.updateOuterDeco(outerDeco);\n      this.node = node;\n      this.innerDeco = innerDeco;\n      if (this.contentDOM)\n        this.updateChildren(view, this.posAtStart);\n      this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n      if (sameOuterDeco(outerDeco, this.outerDeco))\n        return;\n      let needsWrap = this.nodeDOM.nodeType != 1;\n      let oldDOM = this.dom;\n      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n      if (this.dom != oldDOM) {\n        oldDOM.pmViewDesc = void 0;\n        this.dom.pmViewDesc = this;\n      }\n      this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n      if (this.nodeDOM.nodeType == 1) {\n        this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n          this.nodeDOM.draggable = true;\n      }\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n      if (this.nodeDOM.nodeType == 1) {\n        this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n          this.nodeDOM.removeAttribute(\"draggable\");\n      }\n    }\n    get domAtom() {\n      return this.node.isAtom;\n    }\n  };\n  function docViewDesc(doc3, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc3);\n    let docView = new NodeViewDesc(void 0, doc3, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM)\n      docView.updateChildren(view, 0);\n    return docView;\n  }\n  var TextViewDesc = class _TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n      super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n      let skip = this.nodeDOM.parentNode;\n      while (skip && skip != this.dom && !skip.pmIsDeco)\n        skip = skip.parentNode;\n      return { skip: skip || true };\n    }\n    update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))\n        return false;\n      this.updateOuterDeco(outerDeco);\n      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n        this.nodeDOM.nodeValue = node.text;\n        if (view.trackWrites == this.nodeDOM)\n          view.trackWrites = null;\n      }\n      this.node = node;\n      this.dirty = NOT_DIRTY;\n      return true;\n    }\n    inParent() {\n      let parentDOM = this.parent.contentDOM;\n      for (let n = this.nodeDOM; n; n = n.parentNode)\n        if (n == parentDOM)\n          return true;\n      return false;\n    }\n    domFromPos(pos) {\n      return { node: this.nodeDOM, offset: pos };\n    }\n    localPosFromDOM(dom, offset, bias) {\n      if (dom == this.nodeDOM)\n        return this.posAtStart + Math.min(offset, this.node.text.length);\n      return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n      return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from2, to, view) {\n      let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);\n      return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from2, to) {\n      super.markDirty(from2, to);\n      if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))\n        this.dirty = NODE_DIRTY;\n    }\n    get domAtom() {\n      return false;\n    }\n    isText(text) {\n      return this.node.text == text;\n    }\n  };\n  var TrailingHackViewDesc = class extends ViewDesc {\n    parseRule() {\n      return { ignore: true };\n    }\n    matchesHack(nodeName) {\n      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n    get domAtom() {\n      return true;\n    }\n    get ignoreForCoords() {\n      return this.dom.nodeName == \"IMG\";\n    }\n  };\n  var CustomNodeViewDesc = class extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n      super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n      this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY)\n        return false;\n      if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n        let result = this.spec.update(node, outerDeco, innerDeco);\n        if (result)\n          this.updateInner(node, outerDeco, innerDeco, view);\n        return result;\n      } else if (!this.contentDOM && !node.isLeaf) {\n        return false;\n      } else {\n        return super.update(node, outerDeco, innerDeco, view);\n      }\n    }\n    selectNode() {\n      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, view, force) {\n      this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);\n    }\n    destroy() {\n      if (this.spec.destroy)\n        this.spec.destroy();\n      super.destroy();\n    }\n    stopEvent(event) {\n      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n  };\n  function renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for (let i = 0; i < descs.length; i++) {\n      let desc = descs[i], childDOM = desc.dom;\n      if (childDOM.parentNode == parentDOM) {\n        while (childDOM != dom) {\n          dom = rm(dom);\n          written = true;\n        }\n        dom = dom.nextSibling;\n      } else {\n        written = true;\n        parentDOM.insertBefore(childDOM, dom);\n      }\n      if (desc instanceof MarkViewDesc) {\n        let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n        renderDescs(desc.contentDOM, desc.children, view);\n        dom = pos ? pos.nextSibling : parentDOM.firstChild;\n      }\n    }\n    while (dom) {\n      dom = rm(dom);\n      written = true;\n    }\n    if (written && view.trackWrites == parentDOM)\n      view.trackWrites = null;\n  }\n  var OuterDecoLevel = function(nodeName) {\n    if (nodeName)\n      this.nodeName = nodeName;\n  };\n  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);\n  var noDeco = [new OuterDecoLevel()];\n  function computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0)\n      return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];\n    for (let i = 0; i < outerDeco.length; i++) {\n      let attrs = outerDeco[i].type.attrs;\n      if (!attrs)\n        continue;\n      if (attrs.nodeName)\n        result.push(top = new OuterDecoLevel(attrs.nodeName));\n      for (let name in attrs) {\n        let val = attrs[name];\n        if (val == null)\n          continue;\n        if (needsWrap && result.length == 1)\n          result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n        if (name == \"class\")\n          top.class = (top.class ? top.class + \" \" : \"\") + val;\n        else if (name == \"style\")\n          top.style = (top.style ? top.style + \";\" : \"\") + val;\n        else if (name != \"nodeName\")\n          top[name] = val;\n      }\n    }\n    return result;\n  }\n  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    if (prevComputed == noDeco && curComputed == noDeco)\n      return nodeDOM;\n    let curDOM = nodeDOM;\n    for (let i = 0; i < curComputed.length; i++) {\n      let deco = curComputed[i], prev = prevComputed[i];\n      if (i) {\n        let parent;\n        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n          curDOM = parent;\n        } else {\n          parent = document.createElement(deco.nodeName);\n          parent.pmIsDeco = true;\n          parent.appendChild(curDOM);\n          prev = noDeco[0];\n          curDOM = parent;\n        }\n      }\n      patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n  }\n  function patchAttributes(dom, prev, cur) {\n    for (let name in prev)\n      if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n        dom.removeAttribute(name);\n    for (let name in cur)\n      if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n        dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n      let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n      let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n      for (let i = 0; i < prevList.length; i++)\n        if (curList.indexOf(prevList[i]) == -1)\n          dom.classList.remove(prevList[i]);\n      for (let i = 0; i < curList.length; i++)\n        if (prevList.indexOf(curList[i]) == -1)\n          dom.classList.add(curList[i]);\n      if (dom.classList.length == 0)\n        dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n      if (prev.style) {\n        let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n        while (m = prop.exec(prev.style))\n          dom.style.removeProperty(m[1]);\n      }\n      if (cur.style)\n        dom.style.cssText += cur.style;\n    }\n  }\n  function applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n  }\n  function sameOuterDeco(a, b) {\n    if (a.length != b.length)\n      return false;\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].type.eq(b[i].type))\n        return false;\n    return true;\n  }\n  function rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n  }\n  var ViewTreeUpdater = class {\n    constructor(top, lock, view) {\n      this.lock = lock;\n      this.view = view;\n      this.index = 0;\n      this.stack = [];\n      this.changed = false;\n      this.top = top;\n      this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n      if (start == end)\n        return;\n      for (let i = start; i < end; i++)\n        this.top.children[i].destroy();\n      this.top.children.splice(start, end - start);\n      this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n      this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks2, inline, view) {\n      let keep = 0, depth = this.stack.length >> 1;\n      let maxKeep = Math.min(depth, marks2.length);\n      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks2[keep]) && marks2[keep].type.spec.spanning !== false)\n        keep++;\n      while (keep < depth) {\n        this.destroyRest();\n        this.top.dirty = NOT_DIRTY;\n        this.index = this.stack.pop();\n        this.top = this.stack.pop();\n        depth--;\n      }\n      while (depth < marks2.length) {\n        this.stack.push(this.top, this.index + 1);\n        let found2 = -1;\n        for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n          let next = this.top.children[i];\n          if (next.matchesMark(marks2[depth]) && !this.isLocked(next.dom)) {\n            found2 = i;\n            break;\n          }\n        }\n        if (found2 > -1) {\n          if (found2 > this.index) {\n            this.changed = true;\n            this.destroyBetween(this.index, found2);\n          }\n          this.top = this.top.children[this.index];\n        } else {\n          let markDesc = MarkViewDesc.create(this.top, marks2[depth], inline, view);\n          this.top.children.splice(this.index, 0, markDesc);\n          this.top = markDesc;\n          this.changed = true;\n        }\n        this.index = 0;\n        depth++;\n      }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n      let found2 = -1, targetDesc;\n      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n        found2 = this.top.children.indexOf(targetDesc, this.index);\n      } else {\n        for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n          let child = this.top.children[i];\n          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n            found2 = i;\n            break;\n          }\n        }\n      }\n      if (found2 < 0)\n        return false;\n      this.destroyBetween(this.index, found2);\n      this.index++;\n      return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n      let child = this.top.children[index];\n      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n        child.dirty = CONTENT_DIRTY;\n      if (!child.update(node, outerDeco, innerDeco, view))\n        return false;\n      this.destroyBetween(this.index, index);\n      this.index++;\n      return true;\n    }\n    findIndexWithChild(domNode) {\n      for (; ; ) {\n        let parent = domNode.parentNode;\n        if (!parent)\n          return -1;\n        if (parent == this.top.contentDOM) {\n          let desc = domNode.pmViewDesc;\n          if (desc)\n            for (let i = this.index; i < this.top.children.length; i++) {\n              if (this.top.children[i] == desc)\n                return i;\n            }\n          return -1;\n        }\n        domNode = parent;\n      }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n      for (let i = this.index; i < this.top.children.length; i++) {\n        let next = this.top.children[i];\n        if (next instanceof NodeViewDesc) {\n          let preMatch2 = this.preMatch.matched.get(next);\n          if (preMatch2 != null && preMatch2 != index)\n            return false;\n          let nextDOM = next.dom, updated;\n          let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n          if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n            this.destroyBetween(this.index, i);\n            if (next.dom != nextDOM)\n              this.changed = true;\n            this.index++;\n            return true;\n          } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n            this.destroyBetween(this.index, i);\n            this.top.children[this.index] = updated;\n            if (updated.contentDOM) {\n              updated.dirty = CONTENT_DIRTY;\n              updated.updateChildren(view, pos + 1);\n              updated.dirty = NOT_DIRTY;\n            }\n            this.changed = true;\n            this.index++;\n            return true;\n          }\n          break;\n        }\n      }\n      return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))\n        return null;\n      let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n      if (wrapper.contentDOM) {\n        wrapper.children = next.children;\n        next.children = [];\n        for (let ch of wrapper.children)\n          ch.parent = wrapper;\n      }\n      next.destroy();\n      return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n      let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n      if (desc.contentDOM)\n        desc.updateChildren(view, pos + 1);\n      this.top.children.splice(this.index++, 0, desc);\n      this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n      let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n        this.index++;\n      } else {\n        let desc = new WidgetViewDesc(this.top, widget, view, pos);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n      }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n      let lastChild = this.top.children[this.index - 1], parent = this.top;\n      while (lastChild instanceof MarkViewDesc) {\n        parent = lastChild;\n        lastChild = parent.children[parent.children.length - 1];\n      }\n      if (!lastChild || // Empty textblock\n      !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n          this.addHackNode(\"IMG\", parent);\n        this.addHackNode(\"BR\", this.top);\n      }\n    }\n    addHackNode(nodeName, parent) {\n      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n        this.index++;\n      } else {\n        let dom = document.createElement(nodeName);\n        if (nodeName == \"IMG\") {\n          dom.className = \"ProseMirror-separator\";\n          dom.alt = \"\";\n        }\n        if (nodeName == \"BR\")\n          dom.className = \"ProseMirror-trailingBreak\";\n        let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n        if (parent != this.top)\n          parent.children.push(hack);\n        else\n          parent.children.splice(this.index++, 0, hack);\n        this.changed = true;\n      }\n    }\n    isLocked(node) {\n      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n  };\n  function preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];\n    outer: while (fI > 0) {\n      let desc;\n      for (; ; ) {\n        if (descI) {\n          let next = curDesc.children[descI - 1];\n          if (next instanceof MarkViewDesc) {\n            curDesc = next;\n            descI = next.children.length;\n          } else {\n            desc = next;\n            descI--;\n            break;\n          }\n        } else if (curDesc == parentDesc) {\n          break outer;\n        } else {\n          descI = curDesc.parent.children.indexOf(curDesc);\n          curDesc = curDesc.parent;\n        }\n      }\n      let node = desc.node;\n      if (!node)\n        continue;\n      if (node != frag.child(fI - 1))\n        break;\n      --fI;\n      matched.set(desc, fI);\n      matches2.push(desc);\n    }\n    return { index: fI, matched, matches: matches2.reverse() };\n  }\n  function compareSide(a, b) {\n    return a.type.side - b.type.side;\n  }\n  function iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    if (locals.length == 0) {\n      for (let i = 0; i < parent.childCount; i++) {\n        let child = parent.child(i);\n        onNode(child, locals, deco.forChild(offset, child), i);\n        offset += child.nodeSize;\n      }\n      return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for (let parentIndex = 0; ; ) {\n      let widget, widgets;\n      while (decoIndex < locals.length && locals[decoIndex].to == offset) {\n        let next = locals[decoIndex++];\n        if (next.widget) {\n          if (!widget)\n            widget = next;\n          else\n            (widgets || (widgets = [widget])).push(next);\n        }\n      }\n      if (widget) {\n        if (widgets) {\n          widgets.sort(compareSide);\n          for (let i = 0; i < widgets.length; i++)\n            onWidget(widgets[i], parentIndex, !!restNode);\n        } else {\n          onWidget(widget, parentIndex, !!restNode);\n        }\n      }\n      let child, index;\n      if (restNode) {\n        index = -1;\n        child = restNode;\n        restNode = null;\n      } else if (parentIndex < parent.childCount) {\n        index = parentIndex;\n        child = parent.child(parentIndex++);\n      } else {\n        break;\n      }\n      for (let i = 0; i < active.length; i++)\n        if (active[i].to <= offset)\n          active.splice(i--, 1);\n      while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n        active.push(locals[decoIndex++]);\n      let end = offset + child.nodeSize;\n      if (child.isText) {\n        let cutAt = end;\n        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n          cutAt = locals[decoIndex].from;\n        for (let i = 0; i < active.length; i++)\n          if (active[i].to < cutAt)\n            cutAt = active[i].to;\n        if (cutAt < end) {\n          restNode = child.cut(cutAt - offset);\n          child = child.cut(0, cutAt - offset);\n          end = cutAt;\n          index = -1;\n        }\n      } else {\n        while (decoIndex < locals.length && locals[decoIndex].to < end)\n          decoIndex++;\n      }\n      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();\n      onNode(child, outerDeco, deco.forChild(offset, child), index);\n      offset = end;\n    }\n  }\n  function iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n      let oldCSS = dom.style.cssText;\n      dom.style.cssText = oldCSS + \"; list-style: square !important\";\n      window.getComputedStyle(dom).listStyle;\n      dom.style.cssText = oldCSS;\n    }\n  }\n  function findTextInFragment(frag, text, from2, to) {\n    for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {\n      let child = frag.child(i++), childStart = pos;\n      pos += child.nodeSize;\n      if (!child.isText)\n        continue;\n      let str = child.text;\n      while (i < frag.childCount) {\n        let next = frag.child(i++);\n        pos += next.nodeSize;\n        if (!next.isText)\n          break;\n        str += next.text;\n      }\n      if (pos >= from2) {\n        if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)\n          return to - text.length;\n        let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n        if (found2 >= 0 && found2 + text.length + childStart >= from2)\n          return childStart + found2;\n        if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)\n          return to;\n      }\n    }\n    return -1;\n  }\n  function replaceNodes(nodes2, from2, to, view, replacement) {\n    let result = [];\n    for (let i = 0, off = 0; i < nodes2.length; i++) {\n      let child = nodes2[i], start = off, end = off += child.size;\n      if (start >= to || end <= from2) {\n        result.push(child);\n      } else {\n        if (start < from2)\n          result.push(child.slice(0, from2 - start, view));\n        if (replacement) {\n          result.push(replacement);\n          replacement = void 0;\n        }\n        if (end > to)\n          result.push(child.slice(to - start, child.size, view));\n      }\n    }\n    return result;\n  }\n  function selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc3 = view.state.doc;\n    if (!domSel.focusNode)\n      return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0)\n      return null;\n    let $head = doc3.resolve(head), anchor, selection;\n    if (selectionCollapsed(domSel)) {\n      anchor = head;\n      while (nearestDesc && !nearestDesc.node)\n        nearestDesc = nearestDesc.parent;\n      let nearestDescNode = nearestDesc.node;\n      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n        let pos = nearestDesc.posBefore;\n        selection = new NodeSelection(head == pos ? $head : doc3.resolve(pos));\n      }\n    } else {\n      if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n        let min = head, max = head;\n        for (let i = 0; i < domSel.rangeCount; i++) {\n          let range = domSel.getRangeAt(i);\n          min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n          max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n        }\n        if (min < 0)\n          return null;\n        [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];\n        $head = doc3.resolve(head);\n      } else {\n        anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n      }\n      if (anchor < 0)\n        return null;\n    }\n    let $anchor = doc3.resolve(anchor);\n    if (!selection) {\n      let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n      selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n  }\n  function editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n  }\n  function selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view))\n      return;\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n        view.input.mouseDown.delayedSelectionSync = true;\n        view.domObserver.setCurSelection();\n        return;\n      }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n      selectCursorWrapper(view);\n    } else {\n      let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n        if (!sel.$from.parent.inlineContent)\n          resetEditableFrom = temporarilyEditableNear(view, sel.from);\n        if (!sel.empty && !sel.$from.parent.inlineContent)\n          resetEditableTo = temporarilyEditableNear(view, sel.to);\n      }\n      view.docView.setSelection(anchor, head, view, force);\n      if (brokenSelectBetweenUneditable) {\n        if (resetEditableFrom)\n          resetEditable(resetEditableFrom);\n        if (resetEditableTo)\n          resetEditable(resetEditableTo);\n      }\n      if (sel.visible) {\n        view.dom.classList.remove(\"ProseMirror-hideselection\");\n      } else {\n        view.dom.classList.add(\"ProseMirror-hideselection\");\n        if (\"onselectionchange\" in document)\n          removeClassOnSelectionChange(view);\n      }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n  }\n  var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\n  function temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\")\n      return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n      if (after)\n        return setEditable(after);\n      else if (before)\n        return setEditable(before);\n    }\n  }\n  function setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n      element.draggable = false;\n      element.wasDraggable = true;\n    }\n    return element;\n  }\n  function resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n      element.draggable = true;\n      element.wasDraggable = null;\n    }\n  }\n  function removeClassOnSelectionChange(view) {\n    let doc3 = view.dom.ownerDocument;\n    doc3.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc3.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = () => {\n      if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n        doc3.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n        setTimeout(() => {\n          if (!editorOwnsSelection(view) || view.state.selection.visible)\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        }, 20);\n      }\n    });\n  }\n  function selectCursorWrapper(view) {\n    let domSel = view.domSelection();\n    if (!domSel)\n      return;\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img)\n      domSel.collapse(node.parentNode, domIndex(node) + 1);\n    else\n      domSel.collapse(node, 0);\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n      node.disabled = true;\n      node.disabled = false;\n    }\n  }\n  function syncNodeSelection(view, sel) {\n    if (sel instanceof NodeSelection) {\n      let desc = view.docView.descAt(sel.from);\n      if (desc != view.lastSelectedViewDesc) {\n        clearNodeSelection(view);\n        if (desc)\n          desc.selectNode();\n        view.lastSelectedViewDesc = desc;\n      }\n    } else {\n      clearNodeSelection(view);\n    }\n  }\n  function clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n      if (view.lastSelectedViewDesc.parent)\n        view.lastSelectedViewDesc.deselectNode();\n      view.lastSelectedViewDesc = void 0;\n    }\n  }\n  function selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);\n  }\n  function hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus())\n      return false;\n    return hasSelection(view);\n  }\n  function hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode)\n      return false;\n    try {\n      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    } catch (_) {\n      return false;\n    }\n  }\n  function anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n  }\n  function moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && Selection.findFrom($start, dir);\n  }\n  function apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n  }\n  function selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof TextSelection) {\n      if (mods.indexOf(\"s\") > -1) {\n        let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n        if (!node || node.isText || !node.isLeaf)\n          return false;\n        let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n        return apply(view, new TextSelection(sel.$anchor, $newHead));\n      } else if (!sel.empty) {\n        return false;\n      } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && next instanceof NodeSelection)\n          return apply(view, next);\n        return false;\n      } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n        let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n        if (!node || node.isText)\n          return false;\n        let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n        if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n          return false;\n        if (NodeSelection.isSelectable(node)) {\n          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n        } else if (webkit) {\n          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n        } else {\n          return false;\n        }\n      }\n    } else if (sel instanceof NodeSelection && sel.node.isInline) {\n      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));\n    } else {\n      let next = moveSelectionBlock(view.state, dir);\n      if (next)\n        return apply(view, next);\n      return false;\n    }\n  }\n  function nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n  }\n  function isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n  }\n  function skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n  }\n  function skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n      return;\n    let moveNode, moveOffset, force = false;\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))\n      force = true;\n    for (; ; ) {\n      if (offset > 0) {\n        if (node.nodeType != 1) {\n          break;\n        } else {\n          let before = node.childNodes[offset - 1];\n          if (isIgnorable(before, -1)) {\n            moveNode = node;\n            moveOffset = --offset;\n          } else if (before.nodeType == 3) {\n            node = before;\n            offset = node.nodeValue.length;\n          } else\n            break;\n        }\n      } else if (isBlockNode(node)) {\n        break;\n      } else {\n        let prev = node.previousSibling;\n        while (prev && isIgnorable(prev, -1)) {\n          moveNode = node.parentNode;\n          moveOffset = domIndex(prev);\n          prev = prev.previousSibling;\n        }\n        if (!prev) {\n          node = node.parentNode;\n          if (node == view.dom)\n            break;\n          offset = 0;\n        } else {\n          node = prev;\n          offset = nodeLen(node);\n        }\n      }\n    }\n    if (force)\n      setSelFocus(view, node, offset);\n    else if (moveNode)\n      setSelFocus(view, moveNode, moveOffset);\n  }\n  function skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n      return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for (; ; ) {\n      if (offset < len) {\n        if (node.nodeType != 1)\n          break;\n        let after = node.childNodes[offset];\n        if (isIgnorable(after, 1)) {\n          moveNode = node;\n          moveOffset = ++offset;\n        } else\n          break;\n      } else if (isBlockNode(node)) {\n        break;\n      } else {\n        let next = node.nextSibling;\n        while (next && isIgnorable(next, 1)) {\n          moveNode = next.parentNode;\n          moveOffset = domIndex(next) + 1;\n          next = next.nextSibling;\n        }\n        if (!next) {\n          node = node.parentNode;\n          if (node == view.dom)\n            break;\n          offset = len = 0;\n        } else {\n          node = next;\n          offset = 0;\n          len = nodeLen(node);\n        }\n      }\n    }\n    if (moveNode)\n      setSelFocus(view, moveNode, moveOffset);\n  }\n  function isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n  }\n  function textNodeAfter(node, offset) {\n    while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {\n      offset = domIndex(node) + 1;\n      node = node.parentNode;\n    }\n    while (node && offset < node.childNodes.length) {\n      let next = node.childNodes[offset];\n      if (next.nodeType == 3)\n        return next;\n      if (next.nodeType == 1 && next.contentEditable == \"false\")\n        break;\n      node = next;\n      offset = 0;\n    }\n  }\n  function textNodeBefore(node, offset) {\n    while (node && !offset && !hasBlockDesc(node)) {\n      offset = domIndex(node);\n      node = node.parentNode;\n    }\n    while (node && offset) {\n      let next = node.childNodes[offset - 1];\n      if (next.nodeType == 3)\n        return next;\n      if (next.nodeType == 1 && next.contentEditable == \"false\")\n        break;\n      node = next;\n      offset = node.childNodes.length;\n    }\n  }\n  function setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n      let before, after;\n      if (after = textNodeAfter(node, offset)) {\n        node = after;\n        offset = 0;\n      } else if (before = textNodeBefore(node, offset)) {\n        node = before;\n        offset = before.nodeValue.length;\n      }\n    }\n    let sel = view.domSelection();\n    if (!sel)\n      return;\n    if (selectionCollapsed(sel)) {\n      let range = document.createRange();\n      range.setEnd(node, offset);\n      range.setStart(node, offset);\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (sel.extend) {\n      sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    setTimeout(() => {\n      if (view.state == state)\n        selectionToDOM(view);\n    }, 50);\n  }\n  function findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n      let coords = view.coordsAtPos(pos);\n      if (pos > $pos.start()) {\n        let before = view.coordsAtPos(pos - 1);\n        let mid = (before.top + before.bottom) / 2;\n        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)\n          return before.left < coords.left ? \"ltr\" : \"rtl\";\n      }\n      if (pos < $pos.end()) {\n        let after = view.coordsAtPos(pos + 1);\n        let mid = (after.top + after.bottom) / 2;\n        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)\n          return after.left > coords.left ? \"ltr\" : \"rtl\";\n      }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n  }\n  function selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1)\n      return false;\n    if (mac && mods.indexOf(\"m\") > -1)\n      return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n      let next = moveSelectionBlock(view.state, dir);\n      if (next && next instanceof NodeSelection)\n        return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n      let side = dir < 0 ? $from : $to;\n      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);\n      return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n  }\n  function stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof TextSelection))\n      return true;\n    let { $head, $anchor, empty: empty2 } = view.state.selection;\n    if (!$head.sameParent($anchor))\n      return true;\n    if (!empty2)\n      return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\"))\n      return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n      let tr = view.state.tr;\n      if (dir < 0)\n        tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n      else\n        tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n      view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n  function switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n  }\n  function safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0)\n      return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n      let child = focusNode.firstChild;\n      switchEditable(view, child, \"true\");\n      setTimeout(() => switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n  }\n  function getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey)\n      result += \"c\";\n    if (event.metaKey)\n      result += \"m\";\n    if (event.altKey)\n      result += \"a\";\n    if (event.shiftKey)\n      result += \"s\";\n    return result;\n  }\n  function captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || mac && code == 72 && mods == \"c\") {\n      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    } else if (code == 13 || code == 27) {\n      return true;\n    } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n      let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n      let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n      return true;\n    }\n    return false;\n  }\n  function serializeForClipboard(view, slice2) {\n    view.someProp(\"transformCopied\", (f) => {\n      slice2 = f(slice2, view);\n    });\n    let context = [], { content, openStart, openEnd } = slice2;\n    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n      openStart--;\n      openEnd--;\n      let node = content.firstChild;\n      context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n      content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema);\n    let doc3 = detachedDoc(), wrap2 = doc3.createElement(\"div\");\n    wrap2.appendChild(serializer.serializeFragment(content, { document: doc3 }));\n    let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;\n    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n      for (let i = needsWrap.length - 1; i >= 0; i--) {\n        let wrapper = doc3.createElement(needsWrap[i]);\n        while (wrap2.firstChild)\n          wrapper.appendChild(wrap2.firstChild);\n        wrap2.appendChild(wrapper);\n        wrappers++;\n      }\n      firstChild = wrap2.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1)\n      firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, \"\\n\\n\");\n    return { dom: wrap2, text, slice: slice2 };\n  }\n  function parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice2;\n    if (!html && !text)\n      return null;\n    let asText = !!text && (plainText || inCode || !html);\n    if (asText) {\n      view.someProp(\"transformPastedText\", (f) => {\n        text = f(text, inCode || plainText, view);\n      });\n      if (inCode) {\n        slice2 = new Slice(Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0);\n        view.someProp(\"transformPasted\", (f) => {\n          slice2 = f(slice2, view, true);\n        });\n        return slice2;\n      }\n      let parsed = view.someProp(\"clipboardTextParser\", (f) => f(text, $context, plainText, view));\n      if (parsed) {\n        slice2 = parsed;\n      } else {\n        let marks2 = $context.marks();\n        let { schema: schema2 } = view.state, serializer = DOMSerializer.fromSchema(schema2);\n        dom = document.createElement(\"div\");\n        text.split(/(?:\\r\\n?|\\n)+/).forEach((block) => {\n          let p = dom.appendChild(document.createElement(\"p\"));\n          if (block)\n            p.appendChild(serializer.serializeNode(schema2.text(block, marks2)));\n        });\n      }\n    } else {\n      view.someProp(\"transformPastedHTML\", (f) => {\n        html = f(html, view);\n      });\n      dom = readHTML(html);\n      if (webkit)\n        restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3])\n      for (let i = +sliceData[3]; i > 0; i--) {\n        let child = dom.firstChild;\n        while (child && child.nodeType != 1)\n          child = child.nextSibling;\n        if (!child)\n          break;\n        dom = child;\n      }\n    if (!slice2) {\n      let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n      slice2 = parser.parseSlice(dom, {\n        preserveWhitespace: !!(asText || sliceData),\n        context: $context,\n        ruleFromNode(dom2) {\n          if (dom2.nodeName == \"BR\" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))\n            return { ignore: true };\n          return null;\n        }\n      });\n    }\n    if (sliceData) {\n      slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);\n    } else {\n      slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);\n      if (slice2.openStart || slice2.openEnd) {\n        let openStart = 0, openEnd = 0;\n        for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {\n        }\n        for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {\n        }\n        slice2 = closeSlice(slice2, openStart, openEnd);\n      }\n    }\n    view.someProp(\"transformPasted\", (f) => {\n      slice2 = f(slice2, view, asText);\n    });\n    return slice2;\n  }\n  var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n  function normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2)\n      return fragment;\n    for (let d = $context.depth; d >= 0; d--) {\n      let parent = $context.node(d);\n      let match = parent.contentMatchAt($context.index(d));\n      let lastWrap, result = [];\n      fragment.forEach((node) => {\n        if (!result)\n          return;\n        let wrap2 = match.findWrapping(node.type), inLast;\n        if (!wrap2)\n          return result = null;\n        if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {\n          result[result.length - 1] = inLast;\n        } else {\n          if (result.length)\n            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n          let wrapped = withWrappers(node, wrap2);\n          result.push(wrapped);\n          match = match.matchType(wrapped.type);\n          lastWrap = wrap2;\n        }\n      });\n      if (result)\n        return Fragment.from(result);\n    }\n    return fragment;\n  }\n  function withWrappers(node, wrap2, from2 = 0) {\n    for (let i = wrap2.length - 1; i >= from2; i--)\n      node = wrap2[i].create(null, Fragment.from(node));\n    return node;\n  }\n  function addToSibling(wrap2, lastWrap, node, sibling, depth) {\n    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {\n      let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);\n      if (inner)\n        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n      let match = sibling.contentMatchAt(sibling.childCount);\n      if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))\n        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));\n    }\n  }\n  function closeRight(node, depth) {\n    if (depth == 0)\n      return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n  }\n  function closeRange(fragment, side, from2, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1)\n      openEnd = 0;\n    if (depth < to - 1)\n      inner = closeRange(inner, side, from2, to, depth + 1, openEnd);\n    if (depth >= from2)\n      inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n  }\n  function closeSlice(slice2, openStart, openEnd) {\n    if (openStart < slice2.openStart)\n      slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);\n    if (openEnd < slice2.openEnd)\n      slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);\n    return slice2;\n  }\n  var wrapMap = {\n    thead: [\"table\"],\n    tbody: [\"table\"],\n    tfoot: [\"table\"],\n    caption: [\"table\"],\n    colgroup: [\"table\"],\n    col: [\"table\", \"colgroup\"],\n    tr: [\"table\", \"tbody\"],\n    td: [\"table\", \"tbody\", \"tr\"],\n    th: [\"table\", \"tbody\", \"tr\"]\n  };\n  var _detachedDoc = null;\n  function detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n  }\n  var _policy = null;\n  function maybeWrapTrusted(html) {\n    let trustedTypes = window.trustedTypes;\n    if (!trustedTypes)\n      return html;\n    if (!_policy)\n      _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy(\"ProseMirrorClipboard\", { createHTML: (s) => s });\n    return _policy.createHTML(html);\n  }\n  function readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas)\n      html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap2;\n    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])\n      html = wrap2.map((n) => \"<\" + n + \">\").join(\"\") + html + wrap2.map((n) => \"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = maybeWrapTrusted(html);\n    if (wrap2)\n      for (let i = 0; i < wrap2.length; i++)\n        elt = elt.querySelector(wrap2[i]) || elt;\n    return elt;\n  }\n  function restoreReplacedSpaces(dom) {\n    let nodes2 = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for (let i = 0; i < nodes2.length; i++) {\n      let node = nodes2[i];\n      if (node.childNodes.length == 1 && node.textContent == \"\\xA0\" && node.parentNode)\n        node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n  }\n  function addContext(slice2, context) {\n    if (!slice2.size)\n      return slice2;\n    let schema2 = slice2.content.firstChild.type.schema, array;\n    try {\n      array = JSON.parse(context);\n    } catch (e) {\n      return slice2;\n    }\n    let { content, openStart, openEnd } = slice2;\n    for (let i = array.length - 2; i >= 0; i -= 2) {\n      let type = schema2.nodes[array[i]];\n      if (!type || type.hasRequiredAttrs())\n        break;\n      content = Fragment.from(type.create(array[i + 1], content));\n      openStart++;\n      openEnd++;\n    }\n    return new Slice(content, openStart, openEnd);\n  }\n  var handlers = {};\n  var editHandlers = {};\n  var passiveHandlers = { touchstart: true, touchmove: true };\n  var InputState = class {\n    constructor() {\n      this.shiftKey = false;\n      this.mouseDown = null;\n      this.lastKeyCode = null;\n      this.lastKeyCodeTime = 0;\n      this.lastClick = { time: 0, x: 0, y: 0, type: \"\", button: 0 };\n      this.lastSelectionOrigin = null;\n      this.lastSelectionTime = 0;\n      this.lastIOSEnter = 0;\n      this.lastIOSEnterFallbackTimeout = -1;\n      this.lastFocus = 0;\n      this.lastTouch = 0;\n      this.lastChromeDelete = 0;\n      this.composing = false;\n      this.compositionNode = null;\n      this.composingTimeout = -1;\n      this.compositionNodes = [];\n      this.compositionEndedAt = -2e8;\n      this.compositionID = 1;\n      this.compositionPendingChanges = 0;\n      this.domChangeCount = 0;\n      this.eventHandlers = /* @__PURE__ */ Object.create(null);\n      this.hideSelectionGuard = null;\n    }\n  };\n  function initInput(view) {\n    for (let event in handlers) {\n      let handler = handlers[event];\n      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {\n        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))\n          handler(view, event2);\n      }, passiveHandlers[event] ? { passive: true } : void 0);\n    }\n    if (safari)\n      view.dom.addEventListener(\"input\", () => null);\n    ensureListeners(view);\n  }\n  function setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n  }\n  function destroyInput(view) {\n    view.domObserver.stop();\n    for (let type in view.input.eventHandlers)\n      view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n  }\n  function ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", (currentHandlers) => {\n      for (let type in currentHandlers)\n        if (!view.input.eventHandlers[type])\n          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));\n    });\n  }\n  function runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", (handlers2) => {\n      let handler = handlers2[event.type];\n      return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n  }\n  function eventBelongsToView(view, event) {\n    if (!event.bubbles)\n      return true;\n    if (event.defaultPrevented)\n      return false;\n    for (let node = event.target; node != view.dom; node = node.parentNode)\n      if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))\n        return false;\n    return true;\n  }\n  function dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))\n      handlers[event.type](view, event);\n  }\n  editHandlers.keydown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event))\n      return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    if (android && chrome && event.keyCode == 13)\n      return;\n    if (event.keyCode != 229)\n      view.domObserver.forceFlush();\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n      let now = Date.now();\n      view.input.lastIOSEnter = now;\n      view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n        if (view.input.lastIOSEnter == now) {\n          view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")));\n          view.input.lastIOSEnter = 0;\n        }\n      }, 200);\n    } else if (view.someProp(\"handleKeyDown\", (f) => f(view, event)) || captureKeyDown(view, event)) {\n      event.preventDefault();\n    } else {\n      setSelectionOrigin(view, \"key\");\n    }\n  };\n  editHandlers.keyup = (view, event) => {\n    if (event.keyCode == 16)\n      view.input.shiftKey = false;\n  };\n  editHandlers.keypress = (view, _event) => {\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)\n      return;\n    if (view.someProp(\"handleKeyPress\", (f) => f(view, event))) {\n      event.preventDefault();\n      return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n      let text = String.fromCharCode(event.charCode);\n      let deflt = () => view.state.tr.insertText(text).scrollIntoView();\n      if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))\n        view.dispatch(deflt());\n      event.preventDefault();\n    }\n  };\n  function eventCoords(event) {\n    return { left: event.clientX, top: event.clientY };\n  }\n  function isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n  }\n  function runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1)\n      return false;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n      if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n        return true;\n    }\n    return false;\n  }\n  function updateSelection(view, selection, origin) {\n    if (!view.focused)\n      view.focus();\n    if (view.state.selection.eq(selection))\n      return;\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\")\n      tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n  }\n  function selectClickedLeaf(view, inside) {\n    if (inside == -1)\n      return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n      updateSelection(view, new NodeSelection($pos), \"pointer\");\n      return true;\n    }\n    return false;\n  }\n  function selectClickedNode(view, inside) {\n    if (inside == -1)\n      return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof NodeSelection)\n      selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n      if (NodeSelection.isSelectable(node)) {\n        if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n          selectAt = $pos.before(sel.$from.depth);\n        else\n          selectAt = $pos.before(i);\n        break;\n      }\n    }\n    if (selectAt != null) {\n      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n      return true;\n    } else {\n      return false;\n    }\n  }\n  function handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n  }\n  function handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f) => f(view, pos, event));\n  }\n  function handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);\n  }\n  function defaultTripleClick(view, inside, event) {\n    if (event.button != 0)\n      return false;\n    let doc3 = view.state.doc;\n    if (inside == -1) {\n      if (doc3.inlineContent) {\n        updateSelection(view, TextSelection.create(doc3, 0, doc3.content.size), \"pointer\");\n        return true;\n      }\n      return false;\n    }\n    let $pos = doc3.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n      let nodePos = $pos.before(i);\n      if (node.inlineContent)\n        updateSelection(view, TextSelection.create(doc3, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n      else if (NodeSelection.isSelectable(node))\n        updateSelection(view, NodeSelection.create(doc3, nodePos), \"pointer\");\n      else\n        continue;\n      return true;\n    }\n  }\n  function forceDOMFlush(view) {\n    return endComposition(view);\n  }\n  var selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\n  handlers.mousedown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {\n      if (view.input.lastClick.type == \"singleClick\")\n        type = \"doubleClick\";\n      else if (view.input.lastClick.type == \"doubleClick\")\n        type = \"tripleClick\";\n    }\n    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos)\n      return;\n    if (type == \"singleClick\") {\n      if (view.input.mouseDown)\n        view.input.mouseDown.done();\n      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n      event.preventDefault();\n    } else {\n      setSelectionOrigin(view, \"pointer\");\n    }\n  };\n  var MouseDown = class {\n    constructor(view, pos, event, flushed) {\n      this.view = view;\n      this.pos = pos;\n      this.event = event;\n      this.flushed = flushed;\n      this.delayedSelectionSync = false;\n      this.mightDrag = null;\n      this.startDoc = view.state.doc;\n      this.selectNode = !!event[selectNodeModifier];\n      this.allowDefault = event.shiftKey;\n      let targetNode, targetPos;\n      if (pos.inside > -1) {\n        targetNode = view.state.doc.nodeAt(pos.inside);\n        targetPos = pos.inside;\n      } else {\n        let $pos = view.state.doc.resolve(pos.pos);\n        targetNode = $pos.parent;\n        targetPos = $pos.depth ? $pos.before() : 0;\n      }\n      const target = flushed ? null : event.target;\n      const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n      this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;\n      let { selection } = view.state;\n      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n        this.mightDrag = {\n          node: targetNode,\n          pos: targetPos,\n          addAttr: !!(this.target && !this.target.draggable),\n          setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n        };\n      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n        this.view.domObserver.stop();\n        if (this.mightDrag.addAttr)\n          this.target.draggable = true;\n        if (this.mightDrag.setUneditable)\n          setTimeout(() => {\n            if (this.view.input.mouseDown == this)\n              this.target.setAttribute(\"contentEditable\", \"false\");\n          }, 20);\n        this.view.domObserver.start();\n      }\n      view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n      view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n      setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n      this.view.root.removeEventListener(\"mouseup\", this.up);\n      this.view.root.removeEventListener(\"mousemove\", this.move);\n      if (this.mightDrag && this.target) {\n        this.view.domObserver.stop();\n        if (this.mightDrag.addAttr)\n          this.target.removeAttribute(\"draggable\");\n        if (this.mightDrag.setUneditable)\n          this.target.removeAttribute(\"contentEditable\");\n        this.view.domObserver.start();\n      }\n      if (this.delayedSelectionSync)\n        setTimeout(() => selectionToDOM(this.view));\n      this.view.input.mouseDown = null;\n    }\n    up(event) {\n      this.done();\n      if (!this.view.dom.contains(event.target))\n        return;\n      let pos = this.pos;\n      if (this.view.state.doc != this.startDoc)\n        pos = this.view.posAtCoords(eventCoords(event));\n      this.updateAllowDefault(event);\n      if (this.allowDefault || !pos) {\n        setSelectionOrigin(this.view, \"pointer\");\n      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n        event.preventDefault();\n      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements\n      safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a\n      // cursor, but still report that the node is selected\n      // when asked through getSelection. You'll then get a\n      // situation where clicking at the point where that\n      // (hidden) cursor is doesn't change the selection, and\n      // thus doesn't get a reaction from ProseMirror. This\n      // works around that.\n      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n        event.preventDefault();\n      } else {\n        setSelectionOrigin(this.view, \"pointer\");\n      }\n    }\n    move(event) {\n      this.updateAllowDefault(event);\n      setSelectionOrigin(this.view, \"pointer\");\n      if (event.buttons == 0)\n        this.done();\n    }\n    updateAllowDefault(event) {\n      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))\n        this.allowDefault = true;\n    }\n  };\n  handlers.touchstart = (view) => {\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n  };\n  handlers.touchmove = (view) => {\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n  };\n  handlers.contextmenu = (view) => forceDOMFlush(view);\n  function inOrNearComposition(view, event) {\n    if (view.composing)\n      return true;\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n      view.input.compositionEndedAt = -2e8;\n      return true;\n    }\n    return false;\n  }\n  var timeoutComposition = android ? 5e3 : -1;\n  editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {\n    if (!view.composing) {\n      view.domObserver.flush();\n      let { state } = view, $pos = state.selection.$to;\n      if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {\n        view.markCursor = view.state.storedMarks || $pos.marks();\n        endComposition(view, true);\n        view.markCursor = null;\n      } else {\n        endComposition(view, !state.selection.empty);\n        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n          let sel = view.domSelectionRange();\n          for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {\n            let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n            if (!before)\n              break;\n            if (before.nodeType == 3) {\n              let sel2 = view.domSelection();\n              if (sel2)\n                sel2.collapse(before, before.nodeValue.length);\n              break;\n            } else {\n              node = before;\n              offset = -1;\n            }\n          }\n        }\n      }\n      view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n  };\n  editHandlers.compositionend = (view, event) => {\n    if (view.composing) {\n      view.input.composing = false;\n      view.input.compositionEndedAt = event.timeStamp;\n      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n      view.input.compositionNode = null;\n      if (view.input.compositionPendingChanges)\n        Promise.resolve().then(() => view.domObserver.flush());\n      view.input.compositionID++;\n      scheduleComposeEnd(view, 20);\n    }\n  };\n  function scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1)\n      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n  }\n  function clearComposition(view) {\n    if (view.composing) {\n      view.input.composing = false;\n      view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while (view.input.compositionNodes.length > 0)\n      view.input.compositionNodes.pop().markParentsDirty();\n  }\n  function findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode)\n      return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n      let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n      if (textBefore == lastChanged || textAfter == lastChanged)\n        return lastChanged;\n      if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n        return textAfter;\n      } else if (view.input.compositionNode == textAfter) {\n        let descBefore = textBefore.pmViewDesc;\n        if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))\n          return textAfter;\n      }\n    }\n    return textBefore || textAfter;\n  }\n  function timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n  }\n  function endComposition(view, restarting = false) {\n    if (android && view.domObserver.flushingSoon >= 0)\n      return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (restarting || view.docView && view.docView.dirty) {\n      let sel = selectionFromDOM(view), cur = view.state.selection;\n      if (sel && !sel.eq(cur))\n        view.dispatch(view.state.tr.setSelection(sel));\n      else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)\n        view.dispatch(view.state.tr.deleteSelection());\n      else\n        view.updateState(view.state);\n      return true;\n    }\n    return false;\n  }\n  function captureCopy(view, dom) {\n    if (!view.dom.parentNode)\n      return;\n    let wrap2 = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap2.appendChild(dom);\n    wrap2.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(() => {\n      if (wrap2.parentNode)\n        wrap2.parentNode.removeChild(wrap2);\n      view.focus();\n    }, 50);\n  }\n  var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\n  handlers.copy = editHandlers.cut = (view, _event) => {\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty)\n      return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);\n    if (data) {\n      event.preventDefault();\n      data.clearData();\n      data.setData(\"text/html\", dom.innerHTML);\n      data.setData(\"text/plain\", text);\n    } else {\n      captureCopy(view, dom);\n    }\n    if (cut)\n      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n  };\n  function sliceSingleNode(slice2) {\n    return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;\n  }\n  function capturePaste(view, event) {\n    if (!view.dom.parentNode)\n      return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText)\n      target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(() => {\n      view.focus();\n      if (target.parentNode)\n        target.parentNode.removeChild(target);\n      if (plainText)\n        doPaste(view, target.value, null, plain, event);\n      else\n        doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n  }\n  function doPaste(view, text, html, preferPlain, event) {\n    let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", (f) => f(view, event, slice2 || Slice.empty)))\n      return true;\n    if (!slice2)\n      return false;\n    let singleNode = sliceSingleNode(slice2);\n    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n  }\n  function getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text)\n      return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n  }\n  editHandlers.paste = (view, _event) => {\n    let event = _event;\n    if (view.composing && !android)\n      return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event))\n      event.preventDefault();\n    else\n      capturePaste(view, event);\n  };\n  var Dragging = class {\n    constructor(slice2, move, node) {\n      this.slice = slice2;\n      this.move = move;\n      this.node = node;\n    }\n  };\n  var dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\n  function dragMoves(view, event) {\n    let moves = view.someProp(\"dragCopies\", (test) => !test(event));\n    return moves != null ? moves : !event[dragCopyModifier];\n  }\n  handlers.dragstart = (view, _event) => {\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown)\n      mouseDown.done();\n    if (!event.dataTransfer)\n      return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n      node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    } else if (event.target && event.target.nodeType == 1) {\n      let desc = view.docView.nearestDesc(event.target, true);\n      if (desc && desc.node.type.spec.draggable && desc != view.docView)\n        node = NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);\n    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)\n      event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI)\n      event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice2, dragMoves(view, event), node);\n  };\n  handlers.dragend = (view) => {\n    let dragging = view.dragging;\n    window.setTimeout(() => {\n      if (view.dragging == dragging)\n        view.dragging = null;\n    }, 50);\n  };\n  editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\n  editHandlers.drop = (view, _event) => {\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer)\n      return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos)\n      return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice2 = dragging && dragging.slice;\n    if (slice2) {\n      view.someProp(\"transformPasted\", (f) => {\n        slice2 = f(slice2, view, false);\n      });\n    } else {\n      slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && dragMoves(view, event));\n    if (view.someProp(\"handleDrop\", (f) => f(view, event, slice2 || Slice.empty, move))) {\n      event.preventDefault();\n      return;\n    }\n    if (!slice2)\n      return;\n    event.preventDefault();\n    let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;\n    if (insertPos == null)\n      insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n      let { node } = dragging;\n      if (node)\n        node.replace(tr);\n      else\n        tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode)\n      tr.replaceRangeWith(pos, pos, slice2.content.firstChild);\n    else\n      tr.replaceRange(pos, pos, slice2);\n    if (tr.doc.eq(beforeInsert))\n      return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {\n      tr.setSelection(new NodeSelection($pos));\n    } else {\n      let end = tr.mapping.map(insertPos);\n      tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n      tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n  };\n  handlers.focus = (view) => {\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n      view.domObserver.stop();\n      view.dom.classList.add(\"ProseMirror-focused\");\n      view.domObserver.start();\n      view.focused = true;\n      setTimeout(() => {\n        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n          selectionToDOM(view);\n      }, 20);\n    }\n  };\n  handlers.blur = (view, _event) => {\n    let event = _event;\n    if (view.focused) {\n      view.domObserver.stop();\n      view.dom.classList.remove(\"ProseMirror-focused\");\n      view.domObserver.start();\n      if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n        view.domObserver.currentSelection.clear();\n      view.focused = false;\n    }\n  };\n  handlers.beforeinput = (view, _event) => {\n    let event = _event;\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n      view.domObserver.flushSoon();\n      let { domChangeCount } = view.input;\n      setTimeout(() => {\n        if (view.input.domChangeCount != domChangeCount)\n          return;\n        view.dom.blur();\n        view.focus();\n        if (view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\"))))\n          return;\n        let { $cursor } = view.state.selection;\n        if ($cursor && $cursor.pos > 0)\n          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n      }, 50);\n    }\n  };\n  for (let prop in editHandlers)\n    handlers[prop] = editHandlers[prop];\n  function compareObjs(a, b) {\n    if (a == b)\n      return true;\n    for (let p in a)\n      if (a[p] !== b[p])\n        return false;\n    for (let p in b)\n      if (!(p in a))\n        return false;\n    return true;\n  }\n  var WidgetType = class _WidgetType {\n    constructor(toDOM, spec) {\n      this.toDOM = toDOM;\n      this.spec = spec || noSpec;\n      this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n      let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n      return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() {\n      return true;\n    }\n    eq(other) {\n      return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n    destroy(node) {\n      if (this.spec.destroy)\n        this.spec.destroy(node);\n    }\n  };\n  var InlineType = class _InlineType {\n    constructor(attrs, spec) {\n      this.attrs = attrs;\n      this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n      let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n      let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n      return from2 >= to ? null : new Decoration(from2, to, this);\n    }\n    valid(_, span) {\n      return span.from < span.to;\n    }\n    eq(other) {\n      return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    static is(span) {\n      return span.type instanceof _InlineType;\n    }\n    destroy() {\n    }\n  };\n  var NodeType2 = class _NodeType {\n    constructor(attrs, spec) {\n      this.attrs = attrs;\n      this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n      let from2 = mapping.mapResult(span.from + oldOffset, 1);\n      if (from2.deleted)\n        return null;\n      let to = mapping.mapResult(span.to + oldOffset, -1);\n      if (to.deleted || to.pos <= from2.pos)\n        return null;\n      return new Decoration(from2.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n      let { index, offset } = node.content.findIndex(span.from), child;\n      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n      return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    destroy() {\n    }\n  };\n  var Decoration = class _Decoration {\n    /**\n    @internal\n    */\n    constructor(from2, to, type) {\n      this.from = from2;\n      this.to = to;\n      this.type = type;\n    }\n    /**\n    @internal\n    */\n    copy(from2, to) {\n      return new _Decoration(from2, to, this.type);\n    }\n    /**\n    @internal\n    */\n    eq(other, offset = 0) {\n      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */\n    map(mapping, offset, oldOffset) {\n      return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */\n    static widget(pos, toDOM, spec) {\n      return new _Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */\n    static inline(from2, to, attrs, spec) {\n      return new _Decoration(from2, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */\n    static node(from2, to, attrs, spec) {\n      return new _Decoration(from2, to, new NodeType2(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */\n    get spec() {\n      return this.type.spec;\n    }\n    /**\n    @internal\n    */\n    get inline() {\n      return this.type instanceof InlineType;\n    }\n    /**\n    @internal\n    */\n    get widget() {\n      return this.type instanceof WidgetType;\n    }\n  };\n  var none = [];\n  var noSpec = {};\n  var DecorationSet = class _DecorationSet {\n    /**\n    @internal\n    */\n    constructor(local, children) {\n      this.local = local.length ? local : none;\n      this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */\n    static create(doc3, decorations) {\n      return decorations.length ? buildTree(decorations, doc3, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */\n    find(start, end, predicate) {\n      let result = [];\n      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n      return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n      for (let i = 0; i < this.local.length; i++) {\n        let span = this.local[i];\n        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n          result.push(span.copy(span.from + offset, span.to + offset));\n      }\n      for (let i = 0; i < this.children.length; i += 3) {\n        if (this.children[i] < end && this.children[i + 1] > start) {\n          let childOff = this.children[i] + 1;\n          this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n        }\n      }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */\n    map(mapping, doc3, options) {\n      if (this == empty || mapping.maps.length == 0)\n        return this;\n      return this.mapInner(mapping, doc3, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */\n    mapInner(mapping, node, offset, oldOffset, options) {\n      let newLocal;\n      for (let i = 0; i < this.local.length; i++) {\n        let mapped = this.local[i].map(mapping, offset, oldOffset);\n        if (mapped && mapped.type.valid(node, mapped))\n          (newLocal || (newLocal = [])).push(mapped);\n        else if (options.onRemove)\n          options.onRemove(this.local[i].spec);\n      }\n      if (this.children.length)\n        return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n      else\n        return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */\n    add(doc3, decorations) {\n      if (!decorations.length)\n        return this;\n      if (this == empty)\n        return _DecorationSet.create(doc3, decorations);\n      return this.addInner(doc3, decorations, 0);\n    }\n    addInner(doc3, decorations, offset) {\n      let children, childIndex = 0;\n      doc3.forEach((childNode, childOffset) => {\n        let baseOffset = childOffset + offset, found2;\n        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))\n          return;\n        if (!children)\n          children = this.children.slice();\n        while (childIndex < children.length && children[childIndex] < childOffset)\n          childIndex += 3;\n        if (children[childIndex] == childOffset)\n          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);\n        else\n          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));\n        childIndex += 3;\n      });\n      let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n      for (let i = 0; i < local.length; i++)\n        if (!local[i].type.valid(doc3, local[i]))\n          local.splice(i--, 1);\n      return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */\n    remove(decorations) {\n      if (decorations.length == 0 || this == empty)\n        return this;\n      return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n      let children = this.children, local = this.local;\n      for (let i = 0; i < children.length; i += 3) {\n        let found2;\n        let from2 = children[i] + offset, to = children[i + 1] + offset;\n        for (let j = 0, span; j < decorations.length; j++)\n          if (span = decorations[j]) {\n            if (span.from > from2 && span.to < to) {\n              decorations[j] = null;\n              (found2 || (found2 = [])).push(span);\n            }\n          }\n        if (!found2)\n          continue;\n        if (children == this.children)\n          children = this.children.slice();\n        let removed = children[i + 2].removeInner(found2, from2 + 1);\n        if (removed != empty) {\n          children[i + 2] = removed;\n        } else {\n          children.splice(i, 3);\n          i -= 3;\n        }\n      }\n      if (local.length) {\n        for (let i = 0, span; i < decorations.length; i++)\n          if (span = decorations[i]) {\n            for (let j = 0; j < local.length; j++)\n              if (local[j].eq(span, offset)) {\n                if (local == this.local)\n                  local = this.local.slice();\n                local.splice(j--, 1);\n              }\n          }\n      }\n      if (children == this.children && local == this.local)\n        return this;\n      return local.length || children.length ? new _DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n      if (this == empty)\n        return this;\n      if (node.isLeaf)\n        return _DecorationSet.empty;\n      let child, local;\n      for (let i = 0; i < this.children.length; i += 3)\n        if (this.children[i] >= offset) {\n          if (this.children[i] == offset)\n            child = this.children[i + 2];\n          break;\n        }\n      let start = offset + 1, end = start + node.content.size;\n      for (let i = 0; i < this.local.length; i++) {\n        let dec = this.local[i];\n        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n          let from2 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n          if (from2 < to)\n            (local || (local = [])).push(dec.copy(from2, to));\n        }\n      }\n      if (local) {\n        let localSet = new _DecorationSet(local.sort(byPos), none);\n        return child ? new DecorationGroup([localSet, child]) : localSet;\n      }\n      return child || empty;\n    }\n    /**\n    @internal\n    */\n    eq(other) {\n      if (this == other)\n        return true;\n      if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)\n        return false;\n      for (let i = 0; i < this.local.length; i++)\n        if (!this.local[i].eq(other.local[i]))\n          return false;\n      for (let i = 0; i < this.children.length; i += 3)\n        if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))\n          return false;\n      return true;\n    }\n    /**\n    @internal\n    */\n    locals(node) {\n      return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */\n    localsInner(node) {\n      if (this == empty)\n        return none;\n      if (node.inlineContent || !this.local.some(InlineType.is))\n        return this.local;\n      let result = [];\n      for (let i = 0; i < this.local.length; i++) {\n        if (!(this.local[i].type instanceof InlineType))\n          result.push(this.local[i]);\n      }\n      return result;\n    }\n    forEachSet(f) {\n      f(this);\n    }\n  };\n  DecorationSet.empty = new DecorationSet([], []);\n  DecorationSet.removeOverlap = removeOverlap;\n  var empty = DecorationSet.empty;\n  var DecorationGroup = class _DecorationGroup {\n    constructor(members) {\n      this.members = members;\n    }\n    map(mapping, doc3) {\n      const mappedDecos = this.members.map((member) => member.map(mapping, doc3, noSpec));\n      return _DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n      if (child.isLeaf)\n        return DecorationSet.empty;\n      let found2 = [];\n      for (let i = 0; i < this.members.length; i++) {\n        let result = this.members[i].forChild(offset, child);\n        if (result == empty)\n          continue;\n        if (result instanceof _DecorationGroup)\n          found2 = found2.concat(result.members);\n        else\n          found2.push(result);\n      }\n      return _DecorationGroup.from(found2);\n    }\n    eq(other) {\n      if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)\n        return false;\n      for (let i = 0; i < this.members.length; i++)\n        if (!this.members[i].eq(other.members[i]))\n          return false;\n      return true;\n    }\n    locals(node) {\n      let result, sorted = true;\n      for (let i = 0; i < this.members.length; i++) {\n        let locals = this.members[i].localsInner(node);\n        if (!locals.length)\n          continue;\n        if (!result) {\n          result = locals;\n        } else {\n          if (sorted) {\n            result = result.slice();\n            sorted = false;\n          }\n          for (let j = 0; j < locals.length; j++)\n            result.push(locals[j]);\n        }\n      }\n      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n      switch (members.length) {\n        case 0:\n          return empty;\n        case 1:\n          return members[0];\n        default:\n          return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));\n      }\n    }\n    forEachSet(f) {\n      for (let i = 0; i < this.members.length; i++)\n        this.members[i].forEachSet(f);\n    }\n  };\n  function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n      let moved = 0;\n      mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n        let dSize = newEnd - newStart - (oldEnd - oldStart);\n        for (let i2 = 0; i2 < children.length; i2 += 3) {\n          let end = children[i2 + 1];\n          if (end < 0 || oldStart > end + baseOffset - moved)\n            continue;\n          let start = children[i2] + baseOffset - moved;\n          if (oldEnd >= start) {\n            children[i2 + 1] = oldStart <= start ? -2 : -1;\n          } else if (oldStart >= baseOffset && dSize) {\n            children[i2] += dSize;\n            children[i2 + 1] += dSize;\n          }\n        }\n        moved += dSize;\n      });\n      baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    let mustRebuild = false;\n    for (let i = 0; i < children.length; i += 3)\n      if (children[i + 1] < 0) {\n        if (children[i + 1] == -2) {\n          mustRebuild = true;\n          children[i + 1] = -1;\n          continue;\n        }\n        let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset;\n        if (fromLocal < 0 || fromLocal >= node.content.size) {\n          mustRebuild = true;\n          continue;\n        }\n        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n        let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n        let childNode = node.maybeChild(index);\n        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n          let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);\n          if (mapped != empty) {\n            children[i] = fromLocal;\n            children[i + 1] = toLocal;\n            children[i + 2] = mapped;\n          } else {\n            children[i + 1] = -2;\n            mustRebuild = true;\n          }\n        } else {\n          mustRebuild = true;\n        }\n      }\n    if (mustRebuild) {\n      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n      let built = buildTree(decorations, node, 0, options);\n      newLocal = built.local;\n      for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] < 0) {\n          children.splice(i, 3);\n          i -= 3;\n        }\n      for (let i = 0, j = 0; i < built.children.length; i += 3) {\n        let from2 = built.children[i];\n        while (j < children.length && children[j] < from2)\n          j += 3;\n        children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n      }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n  }\n  function moveSpans(spans, offset) {\n    if (!offset || !spans.length)\n      return spans;\n    let result = [];\n    for (let i = 0; i < spans.length; i++) {\n      let span = spans[i];\n      result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n  }\n  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    function gather(set, oldOffset2) {\n      for (let i = 0; i < set.local.length; i++) {\n        let mapped = set.local[i].map(mapping, offset, oldOffset2);\n        if (mapped)\n          decorations.push(mapped);\n        else if (options.onRemove)\n          options.onRemove(set.local[i].spec);\n      }\n      for (let i = 0; i < set.children.length; i += 3)\n        gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);\n    }\n    for (let i = 0; i < children.length; i += 3)\n      if (children[i + 1] == -1)\n        gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n  }\n  function takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf)\n      return null;\n    let end = offset + node.nodeSize, found2 = null;\n    for (let i = 0, span; i < spans.length; i++) {\n      if ((span = spans[i]) && span.from > offset && span.to < end) {\n        (found2 || (found2 = [])).push(span);\n        spans[i] = null;\n      }\n    }\n    return found2;\n  }\n  function withoutNulls(array) {\n    let result = [];\n    for (let i = 0; i < array.length; i++)\n      if (array[i] != null)\n        result.push(array[i]);\n    return result;\n  }\n  function buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart) => {\n      let found2 = takeSpansForNode(spans, childNode, localStart + offset);\n      if (found2) {\n        hasNulls = true;\n        let subtree = buildTree(found2, childNode, offset + localStart + 1, options);\n        if (subtree != empty)\n          children.push(localStart, localStart + childNode.nodeSize, subtree);\n      }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for (let i = 0; i < locals.length; i++)\n      if (!locals[i].type.valid(node, locals[i])) {\n        if (options.onRemove)\n          options.onRemove(locals[i].spec);\n        locals.splice(i--, 1);\n      }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n  }\n  function byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n  }\n  function removeOverlap(spans) {\n    let working = spans;\n    for (let i = 0; i < working.length - 1; i++) {\n      let span = working[i];\n      if (span.from != span.to)\n        for (let j = i + 1; j < working.length; j++) {\n          let next = working[j];\n          if (next.from == span.from) {\n            if (next.to != span.to) {\n              if (working == spans)\n                working = spans.slice();\n              working[j] = next.copy(next.from, span.to);\n              insertAhead(working, j + 1, next.copy(span.to, next.to));\n            }\n            continue;\n          } else {\n            if (next.from < span.to) {\n              if (working == spans)\n                working = spans.slice();\n              working[i] = span.copy(span.from, next.from);\n              insertAhead(working, j, span.copy(next.from, span.to));\n            }\n            break;\n          }\n        }\n    }\n    return working;\n  }\n  function insertAhead(array, i, deco) {\n    while (i < array.length && byPos(deco, array[i]) > 0)\n      i++;\n    array.splice(i, 0, deco);\n  }\n  function viewDecorations(view) {\n    let found2 = [];\n    view.someProp(\"decorations\", (f) => {\n      let result = f(view.state);\n      if (result && result != empty)\n        found2.push(result);\n    });\n    if (view.cursorWrapper)\n      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n    return DecorationGroup.from(found2);\n  }\n  var observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n  };\n  var useCharData = ie && ie_version <= 11;\n  var SelectionState = class {\n    constructor() {\n      this.anchorNode = null;\n      this.anchorOffset = 0;\n      this.focusNode = null;\n      this.focusOffset = 0;\n    }\n    set(sel) {\n      this.anchorNode = sel.anchorNode;\n      this.anchorOffset = sel.anchorOffset;\n      this.focusNode = sel.focusNode;\n      this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n      this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n  };\n  var DOMObserver = class {\n    constructor(view, handleDOMChange) {\n      this.view = view;\n      this.handleDOMChange = handleDOMChange;\n      this.queue = [];\n      this.flushingSoon = -1;\n      this.observer = null;\n      this.currentSelection = new SelectionState();\n      this.onCharData = null;\n      this.suppressingSelectionUpdates = false;\n      this.lastChangedTextNode = null;\n      this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {\n        for (let i = 0; i < mutations.length; i++)\n          this.queue.push(mutations[i]);\n        if (ie && ie_version <= 11 && mutations.some((m) => m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n          this.flushSoon();\n        else\n          this.flush();\n      });\n      if (useCharData) {\n        this.onCharData = (e) => {\n          this.queue.push({ target: e.target, type: \"characterData\", oldValue: e.prevValue });\n          this.flushSoon();\n        };\n      }\n      this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n      if (this.flushingSoon < 0)\n        this.flushingSoon = window.setTimeout(() => {\n          this.flushingSoon = -1;\n          this.flush();\n        }, 20);\n    }\n    forceFlush() {\n      if (this.flushingSoon > -1) {\n        window.clearTimeout(this.flushingSoon);\n        this.flushingSoon = -1;\n        this.flush();\n      }\n    }\n    start() {\n      if (this.observer) {\n        this.observer.takeRecords();\n        this.observer.observe(this.view.dom, observeOptions);\n      }\n      if (this.onCharData)\n        this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n      this.connectSelection();\n    }\n    stop() {\n      if (this.observer) {\n        let take = this.observer.takeRecords();\n        if (take.length) {\n          for (let i = 0; i < take.length; i++)\n            this.queue.push(take[i]);\n          window.setTimeout(() => this.flush(), 20);\n        }\n        this.observer.disconnect();\n      }\n      if (this.onCharData)\n        this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n      this.disconnectSelection();\n    }\n    connectSelection() {\n      this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n      this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n      this.suppressingSelectionUpdates = true;\n      setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n      if (!hasFocusAndSelection(this.view))\n        return;\n      if (this.suppressingSelectionUpdates)\n        return selectionToDOM(this.view);\n      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n        let sel = this.view.domSelectionRange();\n        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n          return this.flushSoon();\n      }\n      this.flush();\n    }\n    setCurSelection() {\n      this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n      if (!sel.focusNode)\n        return true;\n      let ancestors = /* @__PURE__ */ new Set(), container;\n      for (let scan = sel.focusNode; scan; scan = parentNode(scan))\n        ancestors.add(scan);\n      for (let scan = sel.anchorNode; scan; scan = parentNode(scan))\n        if (ancestors.has(scan)) {\n          container = scan;\n          break;\n        }\n      let desc = container && this.view.docView.nearestDesc(container);\n      if (desc && desc.ignoreMutation({\n        type: \"selection\",\n        target: container.nodeType == 3 ? container.parentNode : container\n      })) {\n        this.setCurSelection();\n        return true;\n      }\n    }\n    pendingRecords() {\n      if (this.observer)\n        for (let mut of this.observer.takeRecords())\n          this.queue.push(mut);\n      return this.queue;\n    }\n    flush() {\n      let { view } = this;\n      if (!view.docView || this.flushingSoon > -1)\n        return;\n      let mutations = this.pendingRecords();\n      if (mutations.length)\n        this.queue = [];\n      let sel = view.domSelectionRange();\n      let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n      let from2 = -1, to = -1, typeOver = false, added = [];\n      if (view.editable) {\n        for (let i = 0; i < mutations.length; i++) {\n          let result = this.registerMutation(mutations[i], added);\n          if (result) {\n            from2 = from2 < 0 ? result.from : Math.min(result.from, from2);\n            to = to < 0 ? result.to : Math.max(result.to, to);\n            if (result.typeOver)\n              typeOver = true;\n          }\n        }\n      }\n      if (gecko && added.length) {\n        let brs = added.filter((n) => n.nodeName == \"BR\");\n        if (brs.length == 2) {\n          let [a, b] = brs;\n          if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n            b.remove();\n          else\n            a.remove();\n        } else {\n          let { focusNode } = this.currentSelection;\n          for (let br of brs) {\n            let parent = br.parentNode;\n            if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent))\n              br.remove();\n          }\n        }\n      }\n      let readSel = null;\n      if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {\n        view.input.lastFocus = 0;\n        selectionToDOM(view);\n        this.currentSelection.set(sel);\n        view.scrollToSelection();\n      } else if (from2 > -1 || newSel) {\n        if (from2 > -1) {\n          view.docView.markDirty(from2, to);\n          checkCSS(view);\n        }\n        this.handleDOMChange(from2, to, typeOver, added);\n        if (view.docView && view.docView.dirty)\n          view.updateState(view.state);\n        else if (!this.currentSelection.eq(sel))\n          selectionToDOM(view);\n        this.currentSelection.set(sel);\n      }\n    }\n    registerMutation(mut, added) {\n      if (added.indexOf(mut.target) > -1)\n        return null;\n      let desc = this.view.docView.nearestDesc(mut.target);\n      if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || // Firefox sometimes fires spurious events for null/empty styles\n      mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\")))\n        return null;\n      if (!desc || desc.ignoreMutation(mut))\n        return null;\n      if (mut.type == \"childList\") {\n        for (let i = 0; i < mut.addedNodes.length; i++) {\n          let node = mut.addedNodes[i];\n          added.push(node);\n          if (node.nodeType == 3)\n            this.lastChangedTextNode = node;\n        }\n        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n          return { from: desc.posBefore, to: desc.posAfter };\n        let prev = mut.previousSibling, next = mut.nextSibling;\n        if (ie && ie_version <= 11 && mut.addedNodes.length) {\n          for (let i = 0; i < mut.addedNodes.length; i++) {\n            let { previousSibling, nextSibling } = mut.addedNodes[i];\n            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n              prev = previousSibling;\n            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n              next = nextSibling;\n          }\n        }\n        let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n        let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);\n        let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n        let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n        return { from: from2, to };\n      } else if (mut.type == \"attributes\") {\n        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n      } else {\n        this.lastChangedTextNode = mut.target;\n        return {\n          from: desc.posAtStart,\n          to: desc.posAtEnd,\n          // An event was generated for a text change that didn't change\n          // any text. Mark the dom change to fall back to assuming the\n          // selection was typed over with an identical value if it can't\n          // find another change.\n          typeOver: mut.target.nodeValue == mut.oldValue\n        };\n      }\n    }\n  };\n  var cssChecked = /* @__PURE__ */ new WeakMap();\n  var cssCheckWarned = false;\n  function checkCSS(view) {\n    if (cssChecked.has(view))\n      return;\n    cssChecked.set(view, null);\n    if ([\"normal\", \"nowrap\", \"pre-line\"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n      view.requiresGeckoHackNode = gecko;\n      if (cssCheckWarned)\n        return;\n      console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n      cssCheckWarned = true;\n    }\n  }\n  function rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n  }\n  function safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n      let range = selection.getComposedRanges(view.root)[0];\n      if (range)\n        return rangeToSelectionRange(view, range);\n    }\n    let found2;\n    function read(event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      found2 = event.getTargetRanges()[0];\n    }\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found2 ? rangeToSelectionRange(view, found2) : null;\n  }\n  function blockParent(view, node) {\n    for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {\n      let desc = view.docView.nearestDesc(p, true);\n      if (desc && desc.node.isBlock)\n        return p;\n    }\n    return null;\n  }\n  function parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n      find = [{ node: anchor, offset: domSel.anchorOffset }];\n      if (!selectionCollapsed(domSel))\n        find.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n    }\n    if (chrome && view.input.lastKeyCode === 8) {\n      for (let off = toOffset; off > fromOffset; off--) {\n        let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n        if (node.nodeName == \"BR\" && !desc) {\n          toOffset = off;\n          break;\n        }\n        if (!desc || desc.size)\n          break;\n      }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from2);\n    let sel = null, doc3 = parser.parse(parent, {\n      topNode: $from.parent,\n      topMatch: $from.parent.contentMatchAt($from.index()),\n      topOpen: true,\n      from: fromOffset,\n      to: toOffset,\n      preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n      findPositions: find,\n      ruleFromNode,\n      context: $from\n    });\n    if (find && find[0].pos != null) {\n      let anchor2 = find[0].pos, head = find[1] && find[1].pos;\n      if (head == null)\n        head = anchor2;\n      sel = { anchor: anchor2 + from2, head: head + from2 };\n    }\n    return { doc: doc3, sel, from: from2, to };\n  }\n  function ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n      return desc.parseRule();\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n        let skip = document.createElement(\"div\");\n        skip.appendChild(document.createElement(\"li\"));\n        return { skip };\n      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n        return { ignore: true };\n      }\n    } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n      return { ignore: true };\n    }\n    return null;\n  }\n  var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\n  function readDOMChange(view, from2, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from2 < 0) {\n      let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n      let newSel = selectionFromDOM(view, origin);\n      if (newSel && !view.state.selection.eq(newSel)) {\n        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\"))))\n          return;\n        let tr = view.state.tr.setSelection(newSel);\n        if (origin == \"pointer\")\n          tr.setMeta(\"pointer\", true);\n        else if (origin == \"key\")\n          tr.scrollIntoView();\n        if (compositionID)\n          tr.setMeta(\"composition\", compositionID);\n        view.dispatch(tr);\n      }\n      return;\n    }\n    let $before = view.state.doc.resolve(from2);\n    let shared = $before.sharedDepth(to);\n    from2 = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from2, to);\n    let doc3 = view.state.doc, compare = doc3.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n      preferredPos = view.state.selection.to;\n      preferredSide = \"end\";\n    } else {\n      preferredPos = view.state.selection.from;\n      preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if (change)\n      view.input.domChangeCount++;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n      view.input.lastIOSEnter = 0;\n      return;\n    }\n    if (!change) {\n      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n        change = { start: sel.from, endA: sel.to, endB: sel.to };\n      } else {\n        if (parse.sel) {\n          let sel2 = resolveSelection(view, view.state.doc, parse.sel);\n          if (sel2 && !sel2.eq(view.state.selection)) {\n            let tr = view.state.tr.setSelection(sel2);\n            if (compositionID)\n              tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n          }\n        }\n        return;\n      }\n    }\n    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {\n      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n        change.start = view.state.selection.from;\n      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n        change.endB += view.state.selection.to - change.endA;\n        change.endA = view.state.selection.to;\n      }\n    }\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xA0\") {\n      change.start--;\n      change.endA--;\n      change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc3.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\\S/.test(parse.doc.textBetween($from.pos, $to.pos, \"\", \"\"))) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n      view.input.lastIOSEnter = 0;\n      return;\n    }\n    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc3, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\")))) {\n      if (android && chrome)\n        view.domObserver.suppressSelectionUpdates();\n      return;\n    }\n    if (chrome && change.endB == change.start)\n      view.input.lastChromeDelete = Date.now();\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n      change.endB -= 2;\n      $to = parse.doc.resolveNoCache(change.endB - parse.from);\n      setTimeout(() => {\n        view.someProp(\"handleKeyDown\", function(f) {\n          return f(view, keyEvent(13, \"Enter\"));\n        });\n      }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let mkTr = (base2) => {\n      let tr = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n      if (parse.sel) {\n        let sel2 = resolveSelection(view, tr.doc, parse.sel);\n        if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))\n          tr.setSelection(sel2);\n      }\n      if (compositionID)\n        tr.setMeta(\"composition\", compositionID);\n      return tr.scrollIntoView();\n    };\n    let markChange;\n    if (inlineChange) {\n      if ($from.pos == $to.pos) {\n        if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n          view.domObserver.suppressSelectionUpdates();\n          setTimeout(() => selectionToDOM(view), 20);\n        }\n        let tr = mkTr(view.state.tr.delete(chFrom, chTo));\n        let marks2 = doc3.resolve(change.start).marksAcross(doc3.resolve(change.endA));\n        if (marks2)\n          tr.ensureMarks(marks2);\n        view.dispatch(tr);\n      } else if (\n        // Adding or removing a mark\n        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))\n      ) {\n        let tr = mkTr(view.state.tr);\n        if (markChange.type == \"add\")\n          tr.addMark(chFrom, chTo, markChange.mark);\n        else\n          tr.removeMark(chFrom, chTo, markChange.mark);\n        view.dispatch(tr);\n      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n        let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n        let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));\n        if (!view.someProp(\"handleTextInput\", (f) => f(view, chFrom, chTo, text, deflt)))\n          view.dispatch(deflt());\n      } else {\n        view.dispatch(mkTr());\n      }\n    } else {\n      view.dispatch(mkTr());\n    }\n  }\n  function resolveSelection(view, doc3, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc3.content.size)\n      return null;\n    return selectionBetween(view, doc3.resolve(parsedSel.anchor), doc3.resolve(parsedSel.head));\n  }\n  function isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for (let i = 0; i < prevMarks.length; i++)\n      added = prevMarks[i].removeFromSet(added);\n    for (let i = 0; i < curMarks.length; i++)\n      removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n      mark = added[0];\n      type = \"add\";\n      update = (node) => node.mark(mark.addToSet(node.marks));\n    } else if (added.length == 0 && removed.length == 1) {\n      mark = removed[0];\n      type = \"remove\";\n      update = (node) => node.mark(mark.removeFromSet(node.marks));\n    } else {\n      return null;\n    }\n    let updated = [];\n    for (let i = 0; i < prev.childCount; i++)\n      updated.push(update(prev.child(i)));\n    if (Fragment.from(updated).eq(cur))\n      return { mark, type };\n  }\n  function looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if (\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos\n    )\n      return false;\n    let $start = old.resolve(start);\n    if (!$newStart.parent.isTextblock) {\n      let after = $start.nodeAfter;\n      return after != null && end == start + after.nodeSize;\n    }\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n      return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)\n      return false;\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n  }\n  function skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n      depth--;\n      end++;\n      fromEnd = false;\n    }\n    if (mayOpen) {\n      let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n      while (next && !next.isLeaf) {\n        next = next.firstChild;\n        end++;\n      }\n    }\n    return end;\n  }\n  function findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null)\n      return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n      let adjust = Math.max(0, start - Math.min(endA, endB));\n      preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n      let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n      start -= move;\n      if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))\n        start += move ? 1 : -1;\n      endB = start + (endB - endA);\n      endA = start;\n    } else if (endB < start) {\n      let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n      start -= move;\n      if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))\n        start += move ? 1 : -1;\n      endA = start + (endA - endB);\n      endB = start;\n    }\n    return { start, endA, endB };\n  }\n  function isSurrogatePair(str) {\n    if (str.length != 2)\n      return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;\n  }\n  var EditorView = class {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */\n    constructor(place, props) {\n      this._root = null;\n      this.focused = false;\n      this.trackWrites = null;\n      this.mounted = false;\n      this.markCursor = null;\n      this.cursorWrapper = null;\n      this.lastSelectedViewDesc = void 0;\n      this.input = new InputState();\n      this.prevDirectPlugins = [];\n      this.pluginViews = [];\n      this.requiresGeckoHackNode = false;\n      this.dragging = null;\n      this._props = props;\n      this.state = props.state;\n      this.directPlugins = props.plugins || [];\n      this.directPlugins.forEach(checkStateComponent);\n      this.dispatch = this.dispatch.bind(this);\n      this.dom = place && place.mount || document.createElement(\"div\");\n      if (place) {\n        if (place.appendChild)\n          place.appendChild(this.dom);\n        else if (typeof place == \"function\")\n          place(this.dom);\n        else if (place.mount)\n          this.mounted = true;\n      }\n      this.editable = getEditable(this);\n      updateCursorWrapper(this);\n      this.nodeViews = buildNodeViews(this);\n      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n      this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));\n      this.domObserver.start();\n      initInput(this);\n      this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */\n    get composing() {\n      return this.input.composing;\n    }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */\n    get props() {\n      if (this._props.state != this.state) {\n        let prev = this._props;\n        this._props = {};\n        for (let name in prev)\n          this._props[name] = prev[name];\n        this._props.state = this.state;\n      }\n      return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */\n    update(props) {\n      if (props.handleDOMEvents != this._props.handleDOMEvents)\n        ensureListeners(this);\n      let prevProps = this._props;\n      this._props = props;\n      if (props.plugins) {\n        props.plugins.forEach(checkStateComponent);\n        this.directPlugins = props.plugins;\n      }\n      this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */\n    setProps(props) {\n      let updated = {};\n      for (let name in this._props)\n        updated[name] = this._props[name];\n      updated.state = this.state;\n      for (let name in props)\n        updated[name] = props[name];\n      this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */\n    updateState(state) {\n      this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n      var _a;\n      let prev = this.state, redraw = false, updateSel = false;\n      if (state.storedMarks && this.composing) {\n        clearComposition(this);\n        updateSel = true;\n      }\n      this.state = state;\n      let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n        let nodeViews = buildNodeViews(this);\n        if (changedNodeViews(nodeViews, this.nodeViews)) {\n          this.nodeViews = nodeViews;\n          redraw = true;\n        }\n      }\n      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n        ensureListeners(this);\n      }\n      this.editable = getEditable(this);\n      updateCursorWrapper(this);\n      let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n      let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n      let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n      if (updateDoc || !state.selection.eq(prev.selection))\n        updateSel = true;\n      let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n      if (updateSel) {\n        this.domObserver.stop();\n        let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n        if (updateDoc) {\n          let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n          if (this.composing)\n            this.input.compositionNode = findCompositionNode(this);\n          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n            this.docView.updateOuterDeco(outerDeco);\n            this.docView.destroy();\n            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n          }\n          if (chromeKludge && !this.trackWrites)\n            forceSelUpdate = true;\n        }\n        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n          selectionToDOM(this, forceSelUpdate);\n        } else {\n          syncNodeSelection(this, state.selection);\n          this.domObserver.setCurSelection();\n        }\n        this.domObserver.start();\n      }\n      this.updatePluginViews(prev);\n      if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))\n        this.updateDraggedNode(this.dragging, prev);\n      if (scroll == \"reset\") {\n        this.dom.scrollTop = 0;\n      } else if (scroll == \"to selection\") {\n        this.scrollToSelection();\n      } else if (oldScrollPos) {\n        resetScrollPos(oldScrollPos);\n      }\n    }\n    /**\n    @internal\n    */\n    scrollToSelection() {\n      let startDOM = this.domSelectionRange().focusNode;\n      if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;\n      else if (this.someProp(\"handleScrollToSelection\", (f) => f(this))) ;\n      else if (this.state.selection instanceof NodeSelection) {\n        let target = this.docView.domAfterPos(this.state.selection.from);\n        if (target.nodeType == 1)\n          scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n      } else {\n        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n      }\n    }\n    destroyPluginViews() {\n      let view;\n      while (view = this.pluginViews.pop())\n        if (view.destroy)\n          view.destroy();\n    }\n    updatePluginViews(prevState) {\n      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n        this.prevDirectPlugins = this.directPlugins;\n        this.destroyPluginViews();\n        for (let i = 0; i < this.directPlugins.length; i++) {\n          let plugin = this.directPlugins[i];\n          if (plugin.spec.view)\n            this.pluginViews.push(plugin.spec.view(this));\n        }\n        for (let i = 0; i < this.state.plugins.length; i++) {\n          let plugin = this.state.plugins[i];\n          if (plugin.spec.view)\n            this.pluginViews.push(plugin.spec.view(this));\n        }\n      } else {\n        for (let i = 0; i < this.pluginViews.length; i++) {\n          let pluginView = this.pluginViews[i];\n          if (pluginView.update)\n            pluginView.update(this, prevState);\n        }\n      }\n    }\n    updateDraggedNode(dragging, prev) {\n      let sel = dragging.node, found2 = -1;\n      if (this.state.doc.nodeAt(sel.from) == sel.node) {\n        found2 = sel.from;\n      } else {\n        let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n        let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n        if (moved == sel.node)\n          found2 = movedPos;\n      }\n      this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));\n    }\n    someProp(propName, f) {\n      let prop = this._props && this._props[propName], value;\n      if (prop != null && (value = f ? f(prop) : prop))\n        return value;\n      for (let i = 0; i < this.directPlugins.length; i++) {\n        let prop2 = this.directPlugins[i].props[propName];\n        if (prop2 != null && (value = f ? f(prop2) : prop2))\n          return value;\n      }\n      let plugins = this.state.plugins;\n      if (plugins)\n        for (let i = 0; i < plugins.length; i++) {\n          let prop2 = plugins[i].props[propName];\n          if (prop2 != null && (value = f ? f(prop2) : prop2))\n            return value;\n        }\n    }\n    /**\n    Query whether the view has focus.\n    */\n    hasFocus() {\n      if (ie) {\n        let node = this.root.activeElement;\n        if (node == this.dom)\n          return true;\n        if (!node || !this.dom.contains(node))\n          return false;\n        while (node && this.dom != node && this.dom.contains(node)) {\n          if (node.contentEditable == \"false\")\n            return false;\n          node = node.parentElement;\n        }\n        return true;\n      }\n      return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */\n    focus() {\n      this.domObserver.stop();\n      if (this.editable)\n        focusPreventScroll(this.dom);\n      selectionToDOM(this);\n      this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */\n    get root() {\n      let cached = this._root;\n      if (cached == null)\n        for (let search = this.dom.parentNode; search; search = search.parentNode) {\n          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n            if (!search.getSelection)\n              Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n            return this._root = search;\n          }\n        }\n      return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */\n    updateRoot() {\n      this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */\n    posAtCoords(coords) {\n      return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */\n    coordsAtPos(pos, side = 1) {\n      return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */\n    domAtPos(pos, side = 0) {\n      return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */\n    nodeDOM(pos) {\n      let desc = this.docView.descAt(pos);\n      return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimes—for example when interpreting an event\n    target—you don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */\n    posAtDOM(node, offset, bias = -1) {\n      let pos = this.docView.posFromDOM(node, offset, bias);\n      if (pos == null)\n        throw new RangeError(\"DOM position not inside the editor\");\n      return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */\n    endOfTextblock(dir, state) {\n      return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */\n    pasteHTML(html, event) {\n      return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */\n    pasteText(text, event) {\n      return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Serialize the given slice as it would be if it was copied from\n    this editor. Returns a DOM element that contains a\n    representation of the slice as its children, a textual\n    representation, and the transformed slice (which can be\n    different from the given input due to hooks like\n    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).\n    */\n    serializeForClipboard(slice2) {\n      return serializeForClipboard(this, slice2);\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */\n    destroy() {\n      if (!this.docView)\n        return;\n      destroyInput(this);\n      this.destroyPluginViews();\n      if (this.mounted) {\n        this.docView.update(this.state.doc, [], viewDecorations(this), this);\n        this.dom.textContent = \"\";\n      } else if (this.dom.parentNode) {\n        this.dom.parentNode.removeChild(this.dom);\n      }\n      this.docView.destroy();\n      this.docView = null;\n      clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */\n    get isDestroyed() {\n      return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */\n    dispatchEvent(event) {\n      return dispatchEvent(this, event);\n    }\n    /**\n    @internal\n    */\n    domSelectionRange() {\n      let sel = this.domSelection();\n      if (!sel)\n        return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };\n      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */\n    domSelection() {\n      return this.root.getSelection();\n    }\n  };\n  EditorView.prototype.dispatch = function(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction;\n    if (dispatchTransaction)\n      dispatchTransaction.call(this, tr);\n    else\n      this.updateState(this.state.apply(tr));\n  };\n  function computeDocDeco(view) {\n    let attrs = /* @__PURE__ */ Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", (value) => {\n      if (typeof value == \"function\")\n        value = value(view.state);\n      if (value)\n        for (let attr in value) {\n          if (attr == \"class\")\n            attrs.class += \" \" + value[attr];\n          else if (attr == \"style\")\n            attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n          else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n            attrs[attr] = String(value[attr]);\n        }\n    });\n    if (!attrs.translate)\n      attrs.translate = \"no\";\n    return [Decoration.node(0, view.state.doc.content.size, attrs)];\n  }\n  function updateCursorWrapper(view) {\n    if (view.markCursor) {\n      let dom = document.createElement(\"img\");\n      dom.className = \"ProseMirror-separator\";\n      dom.setAttribute(\"mark-placeholder\", \"true\");\n      dom.setAttribute(\"alt\", \"\");\n      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };\n    } else {\n      view.cursorWrapper = null;\n    }\n  }\n  function getEditable(view) {\n    return !view.someProp(\"editable\", (value) => value(view.state) === false);\n  }\n  function selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n  }\n  function buildNodeViews(view) {\n    let result = /* @__PURE__ */ Object.create(null);\n    function add2(obj) {\n      for (let prop in obj)\n        if (!Object.prototype.hasOwnProperty.call(result, prop))\n          result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add2);\n    view.someProp(\"markViews\", add2);\n    return result;\n  }\n  function changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for (let prop in a) {\n      if (a[prop] != b[prop])\n        return true;\n      nA++;\n    }\n    for (let _ in b)\n      nB++;\n    return nA != nB;\n  }\n  function checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n      throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n  }\n\n  // node_modules/prosemirror-schema-basic/dist/index.js\n  var pDOM = [\"p\", 0];\n  var blockquoteDOM = [\"blockquote\", 0];\n  var hrDOM = [\"hr\"];\n  var preDOM = [\"pre\", [\"code\", 0]];\n  var brDOM = [\"br\"];\n  var nodes = {\n    /**\n    NodeSpec The top level document node.\n    */\n    doc: {\n      content: \"block+\"\n    },\n    /**\n    A plain paragraph textblock. Represented in the DOM\n    as a `<p>` element.\n    */\n    paragraph: {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{ tag: \"p\" }],\n      toDOM() {\n        return pDOM;\n      }\n    },\n    /**\n    A blockquote (`<blockquote>`) wrapping one or more blocks.\n    */\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{ tag: \"blockquote\" }],\n      toDOM() {\n        return blockquoteDOM;\n      }\n    },\n    /**\n    A horizontal rule (`<hr>`).\n    */\n    horizontal_rule: {\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM() {\n        return hrDOM;\n      }\n    },\n    /**\n    A heading textblock, with a `level` attribute that\n    should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n    `<h6>` elements.\n    */\n    heading: {\n      attrs: { level: { default: 1, validate: \"number\" } },\n      content: \"inline*\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [\n        { tag: \"h1\", attrs: { level: 1 } },\n        { tag: \"h2\", attrs: { level: 2 } },\n        { tag: \"h3\", attrs: { level: 3 } },\n        { tag: \"h4\", attrs: { level: 4 } },\n        { tag: \"h5\", attrs: { level: 5 } },\n        { tag: \"h6\", attrs: { level: 6 } }\n      ],\n      toDOM(node) {\n        return [\"h\" + node.attrs.level, 0];\n      }\n    },\n    /**\n    A code listing. Disallows marks or non-text inline\n    nodes by default. Represented as a `<pre>` element with a\n    `<code>` element inside of it.\n    */\n    code_block: {\n      content: \"text*\",\n      marks: \"\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      parseDOM: [{ tag: \"pre\", preserveWhitespace: \"full\" }],\n      toDOM() {\n        return preDOM;\n      }\n    },\n    /**\n    The text node.\n    */\n    text: {\n      group: \"inline\"\n    },\n    /**\n    An inline image (`<img>`) node. Supports `src`,\n    `alt`, and `href` attributes. The latter two default to the empty\n    string.\n    */\n    image: {\n      inline: true,\n      attrs: {\n        src: { validate: \"string\" },\n        alt: { default: null, validate: \"string|null\" },\n        title: { default: null, validate: \"string|null\" }\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{ tag: \"img[src]\", getAttrs(dom) {\n        return {\n          src: dom.getAttribute(\"src\"),\n          title: dom.getAttribute(\"title\"),\n          alt: dom.getAttribute(\"alt\")\n        };\n      } }],\n      toDOM(node) {\n        let { src, alt, title } = node.attrs;\n        return [\"img\", { src, alt, title }];\n      }\n    },\n    /**\n    A hard line break, represented in the DOM as `<br>`.\n    */\n    hard_break: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{ tag: \"br\" }],\n      toDOM() {\n        return brDOM;\n      }\n    }\n  };\n  var emDOM = [\"em\", 0];\n  var strongDOM = [\"strong\", 0];\n  var codeDOM = [\"code\", 0];\n  var marks = {\n    /**\n    A link. Has `href` and `title` attributes. `title`\n    defaults to the empty string. Rendered and parsed as an `<a>`\n    element.\n    */\n    link: {\n      attrs: {\n        href: { validate: \"string\" },\n        title: { default: null, validate: \"string|null\" }\n      },\n      inclusive: false,\n      parseDOM: [{ tag: \"a[href]\", getAttrs(dom) {\n        return { href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\") };\n      } }],\n      toDOM(node) {\n        let { href, title } = node.attrs;\n        return [\"a\", { href, title }, 0];\n      }\n    },\n    /**\n    An emphasis mark. Rendered as an `<em>` element. Has parse rules\n    that also match `<i>` and `font-style: italic`.\n    */\n    em: {\n      parseDOM: [\n        { tag: \"i\" },\n        { tag: \"em\" },\n        { style: \"font-style=italic\" },\n        { style: \"font-style=normal\", clearMark: (m) => m.type.name == \"em\" }\n      ],\n      toDOM() {\n        return emDOM;\n      }\n    },\n    /**\n    A strong mark. Rendered as `<strong>`, parse rules also match\n    `<b>` and `font-weight: bold`.\n    */\n    strong: {\n      parseDOM: [\n        { tag: \"strong\" },\n        // This works around a Google Docs misbehavior where\n        // pasted content will be inexplicably wrapped in `<b>`\n        // tags with a font-weight normal.\n        { tag: \"b\", getAttrs: (node) => node.style.fontWeight != \"normal\" && null },\n        { style: \"font-weight=400\", clearMark: (m) => m.type.name == \"strong\" },\n        { style: \"font-weight\", getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null }\n      ],\n      toDOM() {\n        return strongDOM;\n      }\n    },\n    /**\n    Code font mark. Represented as a `<code>` element.\n    */\n    code: {\n      code: true,\n      parseDOM: [{ tag: \"code\" }],\n      toDOM() {\n        return codeDOM;\n      }\n    }\n  };\n  var schema = new Schema({ nodes, marks });\n\n  // node_modules/prosemirror-schema-list/dist/index.js\n  var olDOM = [\"ol\", 0];\n  var ulDOM = [\"ul\", 0];\n  var liDOM = [\"li\", 0];\n  var orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n      return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n    } }],\n    toDOM(node) {\n      return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n  };\n  var bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() {\n      return ulDOM;\n    }\n  };\n  var listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() {\n      return liDOM;\n    },\n    defining: true\n  };\n  function add(obj, props) {\n    let copy2 = {};\n    for (let prop in obj)\n      copy2[prop] = obj[prop];\n    for (let prop in props)\n      copy2[prop] = props[prop];\n    return copy2;\n  }\n  function addListNodes(nodes2, itemContent, listGroup) {\n    return nodes2.append({\n      ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n      bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n      list_item: add(listItem, { content: itemContent })\n    });\n  }\n\n  // node_modules/w3c-keyname/index.js\n  var base = {\n    8: \"Backspace\",\n    9: \"Tab\",\n    10: \"Enter\",\n    12: \"NumLock\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Control\",\n    18: \"Alt\",\n    20: \"CapsLock\",\n    27: \"Escape\",\n    32: \" \",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"ArrowLeft\",\n    38: \"ArrowUp\",\n    39: \"ArrowRight\",\n    40: \"ArrowDown\",\n    44: \"PrintScreen\",\n    45: \"Insert\",\n    46: \"Delete\",\n    59: \";\",\n    61: \"=\",\n    91: \"Meta\",\n    92: \"Meta\",\n    106: \"*\",\n    107: \"+\",\n    108: \",\",\n    109: \"-\",\n    110: \".\",\n    111: \"/\",\n    144: \"NumLock\",\n    145: \"ScrollLock\",\n    160: \"Shift\",\n    161: \"Shift\",\n    162: \"Control\",\n    163: \"Control\",\n    164: \"Alt\",\n    165: \"Alt\",\n    173: \"-\",\n    186: \";\",\n    187: \"=\",\n    188: \",\",\n    189: \"-\",\n    190: \".\",\n    191: \"/\",\n    192: \"`\",\n    219: \"[\",\n    220: \"\\\\\",\n    221: \"]\",\n    222: \"'\"\n  };\n  var shift = {\n    48: \")\",\n    49: \"!\",\n    50: \"@\",\n    51: \"#\",\n    52: \"$\",\n    53: \"%\",\n    54: \"^\",\n    55: \"&\",\n    56: \"*\",\n    57: \"(\",\n    59: \":\",\n    61: \"+\",\n    173: \"_\",\n    186: \":\",\n    187: \"+\",\n    188: \"<\",\n    189: \"_\",\n    190: \">\",\n    191: \"?\",\n    192: \"~\",\n    219: \"{\",\n    220: \"|\",\n    221: \"}\",\n    222: '\"'\n  };\n  var mac2 = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\n  var ie2 = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n  for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n  var i;\n  for (i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n  var i;\n  for (i = 65; i <= 90; i++) {\n    base[i] = String.fromCharCode(i + 32);\n    shift[i] = String.fromCharCode(i);\n  }\n  var i;\n  for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\n  var code;\n  function keyName(event) {\n    var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == \"Unidentified\";\n    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || \"Unidentified\";\n    if (name == \"Esc\") name = \"Escape\";\n    if (name == \"Del\") name = \"Delete\";\n    if (name == \"Left\") name = \"ArrowLeft\";\n    if (name == \"Up\") name = \"ArrowUp\";\n    if (name == \"Right\") name = \"ArrowRight\";\n    if (name == \"Down\") name = \"ArrowDown\";\n    return name;\n  }\n\n  // node_modules/prosemirror-keymap/dist/index.js\n  var mac3 = typeof navigator != \"undefined\" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);\n  var windows2 = typeof navigator != \"undefined\" && /Win/.test(navigator.platform);\n  function normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n      result = \" \";\n    let alt, ctrl, shift2, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n      let mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod))\n        meta = true;\n      else if (/^a(lt)?$/i.test(mod))\n        alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod))\n        ctrl = true;\n      else if (/^s(hift)?$/i.test(mod))\n        shift2 = true;\n      else if (/^mod$/i.test(mod)) {\n        if (mac3)\n          meta = true;\n        else\n          ctrl = true;\n      } else\n        throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n      result = \"Alt-\" + result;\n    if (ctrl)\n      result = \"Ctrl-\" + result;\n    if (meta)\n      result = \"Meta-\" + result;\n    if (shift2)\n      result = \"Shift-\" + result;\n    return result;\n  }\n  function normalize(map2) {\n    let copy2 = /* @__PURE__ */ Object.create(null);\n    for (let prop in map2)\n      copy2[normalizeKeyName(prop)] = map2[prop];\n    return copy2;\n  }\n  function modifiers(name, event, shift2 = true) {\n    if (event.altKey)\n      name = \"Alt-\" + name;\n    if (event.ctrlKey)\n      name = \"Ctrl-\" + name;\n    if (event.metaKey)\n      name = \"Meta-\" + name;\n    if (shift2 && event.shiftKey)\n      name = \"Shift-\" + name;\n    return name;\n  }\n  function keymap(bindings) {\n    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n  }\n  function keydownHandler(bindings) {\n    let map2 = normalize(bindings);\n    return function(view, event) {\n      let name = keyName(event), baseName, direct = map2[modifiers(name, event)];\n      if (direct && direct(view.state, view.dispatch, view))\n        return true;\n      if (name.length == 1 && name != \" \") {\n        if (event.shiftKey) {\n          let noShift = map2[modifiers(name, event, false)];\n          if (noShift && noShift(view.state, view.dispatch, view))\n            return true;\n        }\n        if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {\n          let fromCode = map2[modifiers(baseName, event)];\n          if (fromCode && fromCode(view.state, view.dispatch, view))\n            return true;\n        }\n      }\n      return false;\n    };\n  }\n\n  // node_modules/rope-sequence/dist/index.js\n  var GOOD_LEAF_SIZE = 200;\n  var RopeSequence = function RopeSequence2() {\n  };\n  RopeSequence.prototype.append = function append(other) {\n    if (!other.length) {\n      return this;\n    }\n    other = RopeSequence.from(other);\n    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);\n  };\n  RopeSequence.prototype.prepend = function prepend(other) {\n    if (!other.length) {\n      return this;\n    }\n    return RopeSequence.from(other).append(this);\n  };\n  RopeSequence.prototype.appendInner = function appendInner(other) {\n    return new Append(this, other);\n  };\n  RopeSequence.prototype.slice = function slice(from2, to) {\n    if (from2 === void 0) from2 = 0;\n    if (to === void 0) to = this.length;\n    if (from2 >= to) {\n      return RopeSequence.empty;\n    }\n    return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));\n  };\n  RopeSequence.prototype.get = function get(i) {\n    if (i < 0 || i >= this.length) {\n      return void 0;\n    }\n    return this.getInner(i);\n  };\n  RopeSequence.prototype.forEach = function forEach(f, from2, to) {\n    if (from2 === void 0) from2 = 0;\n    if (to === void 0) to = this.length;\n    if (from2 <= to) {\n      this.forEachInner(f, from2, to, 0);\n    } else {\n      this.forEachInvertedInner(f, from2, to, 0);\n    }\n  };\n  RopeSequence.prototype.map = function map(f, from2, to) {\n    if (from2 === void 0) from2 = 0;\n    if (to === void 0) to = this.length;\n    var result = [];\n    this.forEach(function(elt, i) {\n      return result.push(f(elt, i));\n    }, from2, to);\n    return result;\n  };\n  RopeSequence.from = function from(values) {\n    if (values instanceof RopeSequence) {\n      return values;\n    }\n    return values && values.length ? new Leaf(values) : RopeSequence.empty;\n  };\n  var Leaf = /* @__PURE__ */ (function(RopeSequence3) {\n    function Leaf2(values) {\n      RopeSequence3.call(this);\n      this.values = values;\n    }\n    if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;\n    Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n    Leaf2.prototype.constructor = Leaf2;\n    var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };\n    Leaf2.prototype.flatten = function flatten() {\n      return this.values;\n    };\n    Leaf2.prototype.sliceInner = function sliceInner(from2, to) {\n      if (from2 == 0 && to == this.length) {\n        return this;\n      }\n      return new Leaf2(this.values.slice(from2, to));\n    };\n    Leaf2.prototype.getInner = function getInner(i) {\n      return this.values[i];\n    };\n    Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start) {\n      for (var i = from2; i < to; i++) {\n        if (f(this.values[i], start + i) === false) {\n          return false;\n        }\n      }\n    };\n    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {\n      for (var i = from2 - 1; i >= to; i--) {\n        if (f(this.values[i], start + i) === false) {\n          return false;\n        }\n      }\n    };\n    Leaf2.prototype.leafAppend = function leafAppend(other) {\n      if (this.length + other.length <= GOOD_LEAF_SIZE) {\n        return new Leaf2(this.values.concat(other.flatten()));\n      }\n    };\n    Leaf2.prototype.leafPrepend = function leafPrepend(other) {\n      if (this.length + other.length <= GOOD_LEAF_SIZE) {\n        return new Leaf2(other.flatten().concat(this.values));\n      }\n    };\n    prototypeAccessors.length.get = function() {\n      return this.values.length;\n    };\n    prototypeAccessors.depth.get = function() {\n      return 0;\n    };\n    Object.defineProperties(Leaf2.prototype, prototypeAccessors);\n    return Leaf2;\n  })(RopeSequence);\n  RopeSequence.empty = new Leaf([]);\n  var Append = /* @__PURE__ */ (function(RopeSequence3) {\n    function Append2(left, right) {\n      RopeSequence3.call(this);\n      this.left = left;\n      this.right = right;\n      this.length = left.length + right.length;\n      this.depth = Math.max(left.depth, right.depth) + 1;\n    }\n    if (RopeSequence3) Append2.__proto__ = RopeSequence3;\n    Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n    Append2.prototype.constructor = Append2;\n    Append2.prototype.flatten = function flatten() {\n      return this.left.flatten().concat(this.right.flatten());\n    };\n    Append2.prototype.getInner = function getInner(i) {\n      return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);\n    };\n    Append2.prototype.forEachInner = function forEachInner(f, from2, to, start) {\n      var leftLen = this.left.length;\n      if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start) === false) {\n        return false;\n      }\n      if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {\n        return false;\n      }\n    };\n    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start) {\n      var leftLen = this.left.length;\n      if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {\n        return false;\n      }\n      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start) === false) {\n        return false;\n      }\n    };\n    Append2.prototype.sliceInner = function sliceInner(from2, to) {\n      if (from2 == 0 && to == this.length) {\n        return this;\n      }\n      var leftLen = this.left.length;\n      if (to <= leftLen) {\n        return this.left.slice(from2, to);\n      }\n      if (from2 >= leftLen) {\n        return this.right.slice(from2 - leftLen, to - leftLen);\n      }\n      return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));\n    };\n    Append2.prototype.leafAppend = function leafAppend(other) {\n      var inner = this.right.leafAppend(other);\n      if (inner) {\n        return new Append2(this.left, inner);\n      }\n    };\n    Append2.prototype.leafPrepend = function leafPrepend(other) {\n      var inner = this.left.leafPrepend(other);\n      if (inner) {\n        return new Append2(inner, this.right);\n      }\n    };\n    Append2.prototype.appendInner = function appendInner2(other) {\n      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {\n        return new Append2(this.left, new Append2(this.right, other));\n      }\n      return new Append2(this, other);\n    };\n    return Append2;\n  })(RopeSequence);\n  var dist_default2 = RopeSequence;\n\n  // node_modules/prosemirror-history/dist/index.js\n  var max_empty_items = 500;\n  var Branch = class _Branch {\n    constructor(items, eventCount) {\n      this.items = items;\n      this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n      if (this.eventCount == 0)\n        return null;\n      let end = this.items.length;\n      for (; ; end--) {\n        let next = this.items.get(end - 1);\n        if (next.selection) {\n          --end;\n          break;\n        }\n      }\n      let remap, mapFrom;\n      if (preserveItems) {\n        remap = this.remapping(end, this.items.length);\n        mapFrom = remap.maps.length;\n      }\n      let transform = state.tr;\n      let selection, remaining;\n      let addAfter = [], addBefore = [];\n      this.items.forEach((item, i) => {\n        if (!item.step) {\n          if (!remap) {\n            remap = this.remapping(end, i + 1);\n            mapFrom = remap.maps.length;\n          }\n          mapFrom--;\n          addBefore.push(item);\n          return;\n        }\n        if (remap) {\n          addBefore.push(new Item(item.map));\n          let step = item.step.map(remap.slice(mapFrom)), map2;\n          if (step && transform.maybeStep(step).doc) {\n            map2 = transform.mapping.maps[transform.mapping.maps.length - 1];\n            addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));\n          }\n          mapFrom--;\n          if (map2)\n            remap.appendMap(map2, mapFrom);\n        } else {\n          transform.maybeStep(item.step);\n        }\n        if (item.selection) {\n          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n          remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n          return false;\n        }\n      }, this.items.length, 0);\n      return { remaining, transform, selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n      let newItems = [], eventCount = this.eventCount;\n      let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n      for (let i = 0; i < transform.steps.length; i++) {\n        let step = transform.steps[i].invert(transform.docs[i]);\n        let item = new Item(transform.mapping.maps[i], step, selection), merged;\n        if (merged = lastItem && lastItem.merge(item)) {\n          item = merged;\n          if (i)\n            newItems.pop();\n          else\n            oldItems = oldItems.slice(0, oldItems.length - 1);\n        }\n        newItems.push(item);\n        if (selection) {\n          eventCount++;\n          selection = void 0;\n        }\n        if (!preserveItems)\n          lastItem = item;\n      }\n      let overflow = eventCount - histOptions.depth;\n      if (overflow > DEPTH_OVERFLOW) {\n        oldItems = cutOffEvents(oldItems, overflow);\n        eventCount -= overflow;\n      }\n      return new _Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from2, to) {\n      let maps = new Mapping();\n      this.items.forEach((item, i) => {\n        let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;\n        maps.appendMap(item.map, mirrorPos);\n      }, from2, to);\n      return maps;\n    }\n    addMaps(array) {\n      if (this.eventCount == 0)\n        return this;\n      return new _Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n      if (!this.eventCount)\n        return this;\n      let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n      let mapping = rebasedTransform.mapping;\n      let newUntil = rebasedTransform.steps.length;\n      let eventCount = this.eventCount;\n      this.items.forEach((item) => {\n        if (item.selection)\n          eventCount--;\n      }, start);\n      let iRebased = rebasedCount;\n      this.items.forEach((item) => {\n        let pos = mapping.getMirror(--iRebased);\n        if (pos == null)\n          return;\n        newUntil = Math.min(newUntil, pos);\n        let map2 = mapping.maps[pos];\n        if (item.step) {\n          let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n          let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n          if (selection)\n            eventCount++;\n          rebasedItems.push(new Item(map2, step, selection));\n        } else {\n          rebasedItems.push(new Item(map2));\n        }\n      }, start);\n      let newMaps = [];\n      for (let i = rebasedCount; i < newUntil; i++)\n        newMaps.push(new Item(mapping.maps[i]));\n      let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n      let branch = new _Branch(items, eventCount);\n      if (branch.emptyItemCount() > max_empty_items)\n        branch = branch.compress(this.items.length - rebasedItems.length);\n      return branch;\n    }\n    emptyItemCount() {\n      let count = 0;\n      this.items.forEach((item) => {\n        if (!item.step)\n          count++;\n      });\n      return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n      let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n      let items = [], events = 0;\n      this.items.forEach((item, i) => {\n        if (i >= upto) {\n          items.push(item);\n          if (item.selection)\n            events++;\n        } else if (item.step) {\n          let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();\n          mapFrom--;\n          if (map2)\n            remap.appendMap(map2, mapFrom);\n          if (step) {\n            let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n            if (selection)\n              events++;\n            let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;\n            if (merged = items.length && items[last].merge(newItem))\n              items[last] = merged;\n            else\n              items.push(newItem);\n          }\n        } else if (item.map) {\n          mapFrom--;\n        }\n      }, this.items.length, 0);\n      return new _Branch(dist_default2.from(items.reverse()), events);\n    }\n  };\n  Branch.empty = new Branch(dist_default2.empty, 0);\n  function cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n      if (item.selection && n-- == 0) {\n        cutPoint = i;\n        return false;\n      }\n    });\n    return items.slice(cutPoint);\n  }\n  var Item = class _Item {\n    constructor(map2, step, selection, mirrorOffset) {\n      this.map = map2;\n      this.step = step;\n      this.selection = selection;\n      this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n      if (this.step && other.step && !other.selection) {\n        let step = other.step.merge(this.step);\n        if (step)\n          return new _Item(step.getMap().invert(), step, this.selection);\n      }\n    }\n  };\n  var HistoryState = class {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n      this.done = done;\n      this.undone = undone;\n      this.prevRanges = prevRanges;\n      this.prevTime = prevTime;\n      this.prevComposition = prevComposition;\n    }\n  };\n  var DEPTH_OVERFLOW = 20;\n  function applyTransaction(history2, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n      return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n      history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n      return history2;\n    } else if (appended && appended.getMeta(historyKey)) {\n      if (appended.getMeta(historyKey).redo)\n        return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);\n      else\n        return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);\n    } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n      let composition = tr.getMeta(\"composition\");\n      let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));\n      let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n      return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);\n    } else if (rebased = tr.getMeta(\"rebased\")) {\n      return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);\n    } else {\n      return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);\n    }\n  }\n  function isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n      return false;\n    if (!transform.docChanged)\n      return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n      for (let i = 0; i < prevRanges.length; i += 2)\n        if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n          adjacent = true;\n    });\n    return adjacent;\n  }\n  function rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n      maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));\n    return result;\n  }\n  function mapRanges(ranges, mapping) {\n    if (!ranges)\n      return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n      if (from2 <= to)\n        result.push(from2, to);\n    }\n    return result;\n  }\n  function histTransaction(history2, state, redo2) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);\n    if (!pop)\n      return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });\n  }\n  var cachedPreserveItems = false;\n  var cachedPreserveItemsPlugins = null;\n  function mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n      cachedPreserveItems = false;\n      cachedPreserveItemsPlugins = plugins;\n      for (let i = 0; i < plugins.length; i++)\n        if (plugins[i].spec.historyPreserveItems) {\n          cachedPreserveItems = true;\n          break;\n        }\n    }\n    return cachedPreserveItems;\n  }\n  var historyKey = new PluginKey(\"history\");\n  var closeHistoryKey = new PluginKey(\"closeHistory\");\n  function history(config = {}) {\n    config = {\n      depth: config.depth || 100,\n      newGroupDelay: config.newGroupDelay || 500\n    };\n    return new Plugin({\n      key: historyKey,\n      state: {\n        init() {\n          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n        },\n        apply(tr, hist, state) {\n          return applyTransaction(hist, state, tr, config);\n        }\n      },\n      config,\n      props: {\n        handleDOMEvents: {\n          beforeinput(view, e) {\n            let inputType = e.inputType;\n            let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n            if (!command)\n              return false;\n            e.preventDefault();\n            return command(view.state, view.dispatch);\n          }\n        }\n      }\n    });\n  }\n  function buildCommand(redo2, scroll) {\n    return (state, dispatch) => {\n      let hist = historyKey.getState(state);\n      if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)\n        return false;\n      if (dispatch) {\n        let tr = histTransaction(hist, state, redo2);\n        if (tr)\n          dispatch(scroll ? tr.scrollIntoView() : tr);\n      }\n      return true;\n    };\n  }\n  var undo = buildCommand(false, true);\n  var redo = buildCommand(true, true);\n  var undoNoScroll = buildCommand(false, false);\n  var redoNoScroll = buildCommand(true, false);\n\n  // node_modules/prosemirror-commands/dist/index.js\n  var deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n  };\n  function atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0))\n      return null;\n    return $cursor;\n  }\n  var joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n      return false;\n    let $cut = findCutBefore($cursor);\n    if (!$cut) {\n      let range = $cursor.blockRange(), target = range && liftTarget(range);\n      if (target == null)\n        return false;\n      if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n      return true;\n    }\n    let before = $cut.nodeBefore;\n    if (deleteBarrier(state, $cut, dispatch, -1))\n      return true;\n    if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n      for (let depth = $cursor.depth; ; depth--) {\n        let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n          if (dispatch) {\n            let tr = state.tr.step(delStep);\n            tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n            dispatch(tr.scrollIntoView());\n          }\n          return true;\n        }\n        if (depth == 1 || $cursor.node(depth - 1).childCount > 1)\n          break;\n      }\n    }\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n      if (dispatch)\n        dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n      return true;\n    }\n    return false;\n  };\n  function textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild) {\n      if (scan.isTextblock)\n        return true;\n      if (only && scan.childCount != 1)\n        return false;\n    }\n    return false;\n  }\n  var selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty: empty2 } = state.selection, $cut = $head;\n    if (!empty2)\n      return false;\n    if ($head.parent.isTextblock) {\n      if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n        return false;\n      $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !NodeSelection.isSelectable(node))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n  };\n  function findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n      for (let i = $pos.depth - 1; i >= 0; i--) {\n        if ($pos.index(i) > 0)\n          return $pos.doc.resolve($pos.before(i + 1));\n        if ($pos.node(i).type.spec.isolating)\n          break;\n      }\n    return null;\n  }\n  function atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size))\n      return null;\n    return $cursor;\n  }\n  var joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n      return false;\n    let $cut = findCutAfter($cursor);\n    if (!$cut)\n      return false;\n    let after = $cut.nodeAfter;\n    if (deleteBarrier(state, $cut, dispatch, 1))\n      return true;\n    if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n      if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n        if (dispatch) {\n          let tr = state.tr.step(delStep);\n          tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n          dispatch(tr.scrollIntoView());\n        }\n        return true;\n      }\n    }\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n      if (dispatch)\n        dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n      return true;\n    }\n    return false;\n  };\n  var selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty: empty2 } = state.selection, $cut = $head;\n    if (!empty2)\n      return false;\n    if ($head.parent.isTextblock) {\n      if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n        return false;\n      $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !NodeSelection.isSelectable(node))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n  };\n  function findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n      for (let i = $pos.depth - 1; i >= 0; i--) {\n        let parent = $pos.node(i);\n        if ($pos.index(i) + 1 < parent.childCount)\n          return $pos.doc.resolve($pos.after(i + 1));\n        if (parent.type.spec.isolating)\n          break;\n      }\n    return null;\n  }\n  var newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n  };\n  function defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n      let { type } = match.edge(i);\n      if (type.isTextblock && !type.hasRequiredAttrs())\n        return type;\n    }\n    return null;\n  }\n  var exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n      return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n      return false;\n    if (dispatch) {\n      let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  };\n  var createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n      return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n      return false;\n    if (dispatch) {\n      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n      let tr = state.tr.insert(side, type.createAndFill());\n      tr.setSelection(TextSelection.create(tr.doc, side + 1));\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  };\n  var liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n      return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n      let before = $cursor.before();\n      if (canSplit(state.doc, before)) {\n        if (dispatch)\n          dispatch(state.tr.split(before).scrollIntoView());\n        return true;\n      }\n    }\n    let range = $cursor.blockRange(), target = range && liftTarget(range);\n    if (target == null)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  };\n  function splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n      let { $from, $to } = state.selection;\n      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))\n          return false;\n        if (dispatch)\n          dispatch(state.tr.split($from.pos).scrollIntoView());\n        return true;\n      }\n      if (!$from.depth)\n        return false;\n      let types = [];\n      let splitDepth, deflt, atEnd = false, atStart = false;\n      for (let d = $from.depth; ; d--) {\n        let node = $from.node(d);\n        if (node.isBlock) {\n          atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n          atStart = $from.start(d) == $from.pos - ($from.depth - d);\n          deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n          let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n          types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));\n          splitDepth = d;\n          break;\n        } else {\n          if (d == 1)\n            return false;\n          types.unshift(null);\n        }\n      }\n      let tr = state.tr;\n      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)\n        tr.deleteSelection();\n      let splitPos = tr.mapping.map($from.pos);\n      let can = canSplit(tr.doc, splitPos, types.length, types);\n      if (!can) {\n        types[0] = deflt ? { type: deflt } : null;\n        can = canSplit(tr.doc, splitPos, types.length, types);\n      }\n      if (!can)\n        return false;\n      tr.split(splitPos, types.length, types);\n      if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n        let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);\n        if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n      }\n      if (dispatch)\n        dispatch(tr.scrollIntoView());\n      return true;\n    };\n  }\n  var splitBlock = splitBlockAs();\n  var selectAll = (state, dispatch) => {\n    if (dispatch)\n      dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n    return true;\n  };\n  function joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n      return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n      if (dispatch)\n        dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n      return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.join($pos.pos).scrollIntoView());\n    return true;\n  }\n  function deleteBarrier(state, $cut, dispatch, dir) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    let isolated = before.type.spec.isolating || after.type.spec.isolating;\n    if (!isolated && joinMaybeClear(state, $cut, dispatch))\n      return true;\n    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n      if (dispatch) {\n        let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;\n        for (let i = conn.length - 1; i >= 0; i--)\n          wrap2 = Fragment.from(conn[i].create(null, wrap2));\n        wrap2 = Fragment.from(before.copy(wrap2));\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));\n        let $joinAt = tr.doc.resolve(end + 2 * conn.length);\n        if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))\n          tr.join($joinAt.pos);\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n    let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);\n    if (target != null && target >= $cut.depth) {\n      if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n      return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n      let at = before, wrap2 = [];\n      for (; ; ) {\n        wrap2.push(at);\n        if (at.isTextblock)\n          break;\n        at = at.lastChild;\n      }\n      let afterText = after, afterDepth = 1;\n      for (; !afterText.isTextblock; afterText = afterText.firstChild)\n        afterDepth++;\n      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n        if (dispatch) {\n          let end = Fragment.empty;\n          for (let i = wrap2.length - 1; i >= 0; i--)\n            end = Fragment.from(wrap2[i].copy(end));\n          let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));\n          dispatch(tr.scrollIntoView());\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  function selectTextblockSide(side) {\n    return function(state, dispatch) {\n      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n      let depth = $pos.depth;\n      while ($pos.node(depth).isInline) {\n        if (!depth)\n          return false;\n        depth--;\n      }\n      if (!$pos.node(depth).isTextblock)\n        return false;\n      if (dispatch)\n        dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n      return true;\n    };\n  }\n  var selectTextblockStart = selectTextblockSide(-1);\n  var selectTextblockEnd = selectTextblockSide(1);\n  function chainCommands(...commands) {\n    return function(state, dispatch, view) {\n      for (let i = 0; i < commands.length; i++)\n        if (commands[i](state, dispatch, view))\n          return true;\n      return false;\n    };\n  }\n  var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\n  var del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n  var pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n  };\n  var macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n  };\n  for (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\n  var mac4 = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n  var baseKeymap = mac4 ? macBaseKeymap : pcBaseKeymap;\n\n  // assets/prosemirror-collab-plugin.js\n  var collabKey = new PluginKey(\"collab\");\n  var CollabConnection = class {\n    constructor(socket, docId, userId, userName) {\n      this.socket = socket;\n      this.docId = docId;\n      this.userId = userId;\n      this.userName = userName;\n      this.version = 0;\n      this.doc = null;\n      this.users = /* @__PURE__ */ new Map();\n      this.pendingSteps = [];\n      this.view = null;\n      this.isConnected = false;\n      this.setupSocketHandlers();\n    }\n    setupSocketHandlers() {\n      this.socket.on(\"init\", ({ version, doc: doc3, users }) => {\n        console.log(\"[Collab] Received initial state, version:\", version);\n        this.version = version;\n        this.doc = doc3;\n        users.forEach((user) => {\n          this.users.set(user.id, user);\n        });\n        this.isConnected = true;\n        if (this.view && doc3) {\n          this.updateEditorDoc(doc3);\n        }\n      });\n      this.socket.on(\"steps\", ({ steps, clientID, version }) => {\n        console.log(\"[Collab] Received\", steps.length, \"steps from\", clientID);\n        if (this.view) {\n          this.receiveSteps(steps, clientID);\n        }\n        this.version = version;\n      });\n      this.socket.on(\"steps-rejected\", ({ currentVersion, steps }) => {\n        console.log(\"[Collab] Steps rejected, need to rebase from version\", currentVersion);\n        this.version = currentVersion;\n        if (this.pendingSteps.length > 0) {\n          this.sendSteps(this.pendingSteps);\n        }\n      });\n      this.socket.on(\"steps-accepted\", ({ version }) => {\n        console.log(\"[Collab] Steps accepted, new version:\", version);\n        this.version = version;\n        this.pendingSteps = [];\n      });\n      this.socket.on(\"user-joined\", ({ userId, userName, userColor }) => {\n        console.log(\"[Collab] User joined:\", userName);\n        this.users.set(userId, { id: userId, name: userName, color: userColor });\n        if (this.view) {\n          this.view.dispatch(this.view.state.tr);\n        }\n      });\n      this.socket.on(\"user-left\", ({ userId }) => {\n        console.log(\"[Collab] User left:\", userId);\n        this.users.delete(userId);\n        if (this.view) {\n          this.view.dispatch(this.view.state.tr);\n        }\n      });\n      this.socket.on(\"selection\", ({ userId, userName, userColor, from: from2, to }) => {\n        if (this.view && userId !== this.userId) {\n          this.updateUserCursor(userId, userName, userColor, from2, to);\n        }\n      });\n      this.socket.on(\"error\", (error) => {\n        console.error(\"[Collab] Socket error:\", error);\n        this.isConnected = false;\n      });\n      this.socket.on(\"disconnect\", () => {\n        console.log(\"[Collab] Disconnected from server\");\n        this.isConnected = false;\n      });\n    }\n    connect(view) {\n      this.view = view;\n      this.socket.emit(\"join-document\", {\n        documentId: this.docId,\n        clientName: this.userName,\n        initialDoc: view.state.doc.toJSON()\n      });\n    }\n    disconnect() {\n      if (this.socket.connected) {\n        this.socket.disconnect();\n      }\n      this.view = null;\n      this.isConnected = false;\n    }\n    sendSteps(steps) {\n      if (!this.isConnected) {\n        console.warn(\"[Collab] Not connected, queuing steps\");\n        this.pendingSteps.push(...steps);\n        return;\n      }\n      const serializedSteps = steps.map((step) => step.toJSON());\n      console.log(\"[Collab] Sending\", steps.length, \"steps, version:\", this.version);\n      this.socket.emit(\"send-steps\", {\n        version: this.version,\n        steps: serializedSteps,\n        clientID: this.userId\n      });\n      this.pendingSteps = steps;\n    }\n    receiveSteps(stepsJSON, clientID) {\n      if (!this.view) return;\n      try {\n        const { state, dispatch } = this.view;\n        const steps = stepsJSON.map((json) => Step.fromJSON(state.schema, json));\n        let tr = state.tr;\n        steps.forEach((step) => {\n          const result = step.apply(tr.doc);\n          if (result.failed) {\n            console.error(\"[Collab] Failed to apply step:\", result.failed);\n            return;\n          }\n          tr.step(step);\n        });\n        tr.setMeta(\"collab\", {\n          isRemote: true,\n          clientID\n        });\n        dispatch(tr);\n      } catch (error) {\n        console.error(\"[Collab] Error applying received steps:\", error);\n      }\n    }\n    updateEditorDoc(docJSON) {\n      if (!this.view) return;\n      try {\n        const { state, dispatch } = this.view;\n        const doc3 = state.schema.nodeFromJSON(docJSON);\n        const tr = state.tr.replaceWith(0, state.doc.content.size, doc3.content);\n        tr.setMeta(\"collab\", { isRemote: true, isInit: true });\n        dispatch(tr);\n      } catch (error) {\n        console.error(\"[Collab] Error updating document:\", error);\n      }\n    }\n    sendSelection(from2, to) {\n      if (!this.isConnected) return;\n      this.socket.emit(\"selection-changed\", { from: from2, to });\n    }\n    updateUserCursor(userId, userName, userColor, from2, to) {\n      if (!this.view) return;\n      const { state, dispatch } = this.view;\n      let tr = state.tr;\n      tr.setMeta(\"collab\", {\n        cursorUpdate: {\n          userId,\n          userName,\n          userColor,\n          from: from2,\n          to\n        }\n      });\n      dispatch(tr);\n    }\n  };\n  function createCollabPlugin(connection) {\n    return new Plugin({\n      key: collabKey,\n      state: {\n        init() {\n          return {\n            connection,\n            cursors: /* @__PURE__ */ new Map(),\n            decorations: DecorationSet.empty\n          };\n        },\n        apply(tr, value, oldState, newState) {\n          const cursorUpdate = tr.getMeta(\"collab\")?.cursorUpdate;\n          if (cursorUpdate) {\n            value.cursors.set(cursorUpdate.userId, cursorUpdate);\n            const decorations = [];\n            value.cursors.forEach((cursor, userId) => {\n              if (userId !== value.connection.userId) {\n                if (cursor.from === cursor.to) {\n                  const deco = Decoration.widget(cursor.from, () => {\n                    const cursorEl = document.createElement(\"span\");\n                    cursorEl.className = \"collab-cursor\";\n                    cursorEl.style.borderLeftColor = cursor.userColor;\n                    cursorEl.style.borderLeft = `2px solid ${cursor.userColor}`;\n                    cursorEl.style.marginLeft = \"-1px\";\n                    cursorEl.style.marginRight = \"-1px\";\n                    const labelEl = document.createElement(\"span\");\n                    labelEl.className = \"collab-cursor-label\";\n                    labelEl.textContent = cursor.userName;\n                    labelEl.style.backgroundColor = cursor.userColor;\n                    labelEl.style.color = \"white\";\n                    labelEl.style.fontSize = \"11px\";\n                    labelEl.style.padding = \"2px 4px\";\n                    labelEl.style.borderRadius = \"3px\";\n                    labelEl.style.position = \"absolute\";\n                    labelEl.style.bottom = \"100%\";\n                    labelEl.style.left = \"-2px\";\n                    labelEl.style.whiteSpace = \"nowrap\";\n                    labelEl.style.pointerEvents = \"none\";\n                    cursorEl.appendChild(labelEl);\n                    return cursorEl;\n                  }, {\n                    side: 1,\n                    key: `cursor-${userId}`\n                  });\n                  decorations.push(deco);\n                } else {\n                  const deco = Decoration.inline(\n                    cursor.from,\n                    cursor.to,\n                    {\n                      style: `background-color: ${cursor.userColor}33;`,\n                      // 33 = 20% opacity\n                      class: \"collab-selection\"\n                    },\n                    { key: `selection-${userId}` }\n                  );\n                  decorations.push(deco);\n                }\n              }\n            });\n            value.decorations = DecorationSet.create(newState.doc, decorations);\n          }\n          const isRemote = tr.getMeta(\"collab\")?.isRemote;\n          if (!isRemote && tr.docChanged) {\n            const steps = [];\n            for (let i = 0; i < tr.steps.length; i++) {\n              steps.push(tr.steps[i]);\n            }\n            if (steps.length > 0) {\n              value.connection.sendSteps(steps);\n            }\n          }\n          return value;\n        }\n      },\n      props: {\n        decorations(state) {\n          const pluginState = collabKey.getState(state);\n          return pluginState?.decorations || DecorationSet.empty;\n        }\n      },\n      view(view) {\n        const pluginState = collabKey.getState(view.state);\n        const connection2 = pluginState?.connection;\n        if (connection2) {\n          connection2.connect(view);\n          let selectionTimeout;\n          const handleSelectionChange = () => {\n            clearTimeout(selectionTimeout);\n            selectionTimeout = setTimeout(() => {\n              const { from: from2, to } = view.state.selection;\n              connection2.sendSelection(from2, to);\n            }, 100);\n          };\n          const originalUpdateState = view.updateState.bind(view);\n          view.updateState = function(state) {\n            originalUpdateState(state);\n            handleSelectionChange();\n          };\n        }\n        return {\n          destroy() {\n            if (connection2) {\n              connection2.disconnect();\n            }\n          }\n        };\n      }\n    });\n  }\n  function initializeCollaboration(socket, docId, userId, userName) {\n    const connection = new CollabConnection(socket, docId, userId, userName);\n    const plugin = createCollabPlugin(connection);\n    return {\n      connection,\n      plugin\n    };\n  }\n  if (typeof window !== \"undefined\") {\n    window.ProseMirrorCollab = {\n      CollabConnection,\n      createCollabPlugin,\n      initializeCollaboration\n    };\n  }\n\n  // assets/prosemirror-bundle-src.js\n  var mySchema = new Schema({\n    nodes: addListNodes(schema.spec.nodes, \"paragraph block*\", \"block\").addToEnd(\"geoMark\", {\n      inline: true,\n      group: \"inline\",\n      content: \"text*\",\n      attrs: {\n        geoId: { default: null },\n        placeName: { default: \"\" },\n        lat: { default: \"\" },\n        lng: { default: \"\" },\n        colorIndex: { default: 0 },\n        coordSource: { default: \"manual\" },\n        description: { default: null },\n        transportFrom: { default: null },\n        transportProfile: { default: null },\n        waypoints: { default: null },\n        visitDocument: { default: null },\n        photoName: { default: null }\n      },\n      parseDOM: [{\n        tag: \"span.geo-mark\",\n        getAttrs(dom) {\n          return {\n            geoId: dom.getAttribute(\"data-geo-id\"),\n            placeName: dom.getAttribute(\"data-place-name\"),\n            lat: dom.getAttribute(\"data-lat\"),\n            lng: dom.getAttribute(\"data-lng\"),\n            colorIndex: parseInt(dom.getAttribute(\"data-color-index\") || \"0\"),\n            coordSource: dom.getAttribute(\"data-coord-source\") || \"manual\"\n          };\n        }\n      }],\n      toDOM(node) {\n        return [\"span\", {\n          class: \"geo-mark\",\n          \"data-geo-id\": node.attrs.geoId,\n          \"data-place-name\": node.attrs.placeName,\n          \"data-lat\": node.attrs.lat,\n          \"data-lng\": node.attrs.lng,\n          \"data-color-index\": node.attrs.colorIndex,\n          \"data-coord-source\": node.attrs.coordSource\n        }, 0];\n      }\n    }),\n    marks: schema.spec.marks.addToEnd(\"comment\", {\n      attrs: {\n        commentId: { default: null },\n        userId: { default: null },\n        userName: { default: \"\" },\n        content: { default: \"\" },\n        createdAt: { default: null },\n        resolved: { default: false },\n        replies: { default: null },\n        aiReply: { default: null }\n      },\n      inclusive: false,\n      parseDOM: [{\n        tag: \"span.comment-mark\",\n        getAttrs(dom) {\n          const repliesStr = dom.getAttribute(\"data-replies\");\n          let replies = null;\n          if (repliesStr) {\n            try {\n              replies = JSON.parse(repliesStr);\n            } catch (e) {\n              console.error(\"Failed to parse replies:\", e);\n            }\n          }\n          return {\n            commentId: dom.getAttribute(\"data-comment-id\"),\n            userId: dom.getAttribute(\"data-user-id\"),\n            userName: dom.getAttribute(\"data-user-name\") || \"\",\n            content: dom.getAttribute(\"data-content\") || \"\",\n            createdAt: dom.getAttribute(\"data-created-at\"),\n            resolved: dom.getAttribute(\"data-resolved\") === \"true\",\n            replies\n          };\n        }\n      }],\n      toDOM(mark) {\n        const attrs = {\n          class: \"comment-mark\",\n          \"data-comment\": \"true\",\n          style: \"background-color: rgba(251, 191, 36, 0.3); border-bottom: 2px solid rgba(251, 191, 36, 0.6); cursor: pointer; padding: 1px 0;\"\n        };\n        if (mark.attrs.commentId) attrs[\"data-comment-id\"] = mark.attrs.commentId;\n        if (mark.attrs.userId) attrs[\"data-user-id\"] = mark.attrs.userId;\n        if (mark.attrs.userName) attrs[\"data-user-name\"] = mark.attrs.userName;\n        if (mark.attrs.content) attrs[\"data-content\"] = mark.attrs.content;\n        if (mark.attrs.createdAt) attrs[\"data-created-at\"] = mark.attrs.createdAt;\n        if (mark.attrs.resolved !== void 0) attrs[\"data-resolved\"] = mark.attrs.resolved.toString();\n        if (mark.attrs.replies) attrs[\"data-replies\"] = JSON.stringify(mark.attrs.replies);\n        if (mark.attrs.resolved) {\n          attrs.style = \"background-color: rgba(156, 163, 175, 0.2); border-bottom: 2px solid rgba(156, 163, 175, 0.4); cursor: pointer; padding: 1px 0; text-decoration: line-through;\";\n        }\n        return [\"span\", attrs, 0];\n      }\n    })\n  });\n  window.PM = {\n    state: { EditorState, TextSelection, Plugin, PluginKey },\n    view: { EditorView, Decoration, DecorationSet },\n    model: { Schema, DOMParser, DOMSerializer },\n    transform: { Step },\n    schema: mySchema,\n    keymap,\n    history: { history, undo, redo },\n    commands: { baseKeymap },\n    collab: { CollabConnection, createCollabPlugin, initializeCollaboration }\n  };\n  console.log(\"[ProseMirror Bundle] Loaded successfully\");\n})();\n\n  </script>\n\n  <script>\n    console.log('[WebView] [v4-fixed] Checking if ProseMirror loaded...');\n    console.log('[WebView] window.PM exists:', typeof window.PM !== 'undefined');\n    console.log('[WebView] PM contents:', window.PM);\n\n    if (typeof window.PM === 'undefined') {\n      setStatus('ERROR: ProseMirror failed to load', true);\n      sendMessageToNative({\n        type: 'error',\n        message: 'ProseMirror bundle did not load'\n      });\n    } else {\n      setStatus('ProseMirror loaded successfully!');\n\n      // Initialize editor\n      const { EditorState, Plugin, PluginKey } = window.PM.state;\n      const { EditorView, Decoration, DecorationSet } = window.PM.view;\n      const { schema } = window.PM;\n      const { keymap } = window.PM;\n      const { history, undo, redo } = window.PM.history;\n      const { baseKeymap } = window.PM.commands;\n      const { Step } = window.PM.transform;\n\n      console.log('[WebView] Creating editor state...');\n\n      let editorView = null;\n      let collabConnection = null;\n      let collabPlugin = null;\n      let socket = null;\n\n      // Create initial document - empty, content will be sent from React Native\n      const { DOMParser: PMDOMParser } = window.PM.model;\n\n      // Start with empty document\n      const doc = schema.node('doc', null, [\n        schema.node('paragraph', null, [])\n      ]);\n\n      // Create initial editor state\n      let editorState = EditorState.create({\n        doc: doc,\n        schema: schema,\n        plugins: [\n          history(),\n          keymap({ 'Mod-z': undo, 'Mod-y': redo }),\n          keymap(baseKeymap)\n        ]\n      });\n\n      console.log('[WebView] Creating editor view...');\n\n      // Color palette for geo-marks\n      const COLORS = [\n        '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',\n        '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'\n      ];\n\n      // NodeView for geo-marks\n      function createGeoMarkNodeView(node) {\n        const span = document.createElement('span');\n        span.className = 'geo-mark';\n\n        // Apply background color based on colorIndex\n        const colorIndex = node.attrs.colorIndex || 0;\n        const color = COLORS[colorIndex % COLORS.length];\n        span.style.backgroundColor = color + '33'; // 33 = 20% opacity\n        span.style.padding = '2px 4px';\n        span.style.borderRadius = '3px';\n        span.style.cursor = 'pointer';\n        span.style.transition = 'all 0.2s ease';\n        span.style.textDecoration = 'none';\n        span.style.border = 'none';\n        span.style.borderBottom = 'none';\n\n        // Store attributes as data attributes for click handling\n        if (node.attrs.geoId) span.setAttribute('data-geo-id', node.attrs.geoId);\n        if (node.attrs.placeName) span.setAttribute('data-place-name', node.attrs.placeName);\n        if (node.attrs.lat) span.setAttribute('data-lat', node.attrs.lat);\n        if (node.attrs.lng) span.setAttribute('data-lng', node.attrs.lng);\n        if (node.attrs.colorIndex !== undefined) span.setAttribute('data-color-index', node.attrs.colorIndex);\n        if (node.attrs.coordSource) span.setAttribute('data-coord-source', node.attrs.coordSource);\n\n        console.log('[WebView] Created geo-mark NodeView with color:', color, 'for:', node.attrs.placeName);\n\n        return {\n          dom: span,\n          contentDOM: span\n        };\n      }\n\n      // Typing cursor management\n      const typingCursor = document.getElementById('typing-cursor');\n      let isTypingActive = false;\n\n      function updateTypingCursor() {\n        if (!isTypingActive || !editorView) {\n          typingCursor.classList.remove('visible');\n          return;\n        }\n\n        const { state } = editorView;\n        const { selection } = state;\n        const { from } = selection;\n\n        // Get the coordinates of the cursor position\n        try {\n          const coords = editorView.coordsAtPos(from);\n          const editorContainer = document.querySelector('#editor-container');\n          const editorRect = editorContainer.getBoundingClientRect();\n\n          // Calculate cursor height based on line height\n          const cursorHeight = coords.bottom - coords.top;\n\n          // Position and size the cursor indicator\n          typingCursor.style.left = (coords.left - editorRect.left) + 'px';\n          typingCursor.style.top = (coords.top - editorRect.top) + 'px';\n          typingCursor.style.height = cursorHeight + 'px';\n          typingCursor.classList.add('visible');\n\n          console.log('[WebView] Cursor updated: height =', cursorHeight);\n        } catch (e) {\n          console.warn('[WebView] Could not get cursor coordinates:', e);\n          typingCursor.classList.remove('visible');\n        }\n      }\n\n      function showTypingCursor() {\n        isTypingActive = true;\n        updateTypingCursor();\n        console.log('[WebView] Typing cursor shown');\n      }\n\n      function hideTypingCursor() {\n        isTypingActive = false;\n        typingCursor.classList.remove('visible');\n        console.log('[WebView] Typing cursor hidden');\n      }\n\n      // Expose for native to control\n      window.showTypingCursor = showTypingCursor;\n      window.hideTypingCursor = hideTypingCursor;\n\n      // Helper functions for toolbar state (must be defined before EditorView)\n      // Helper function to update collaboration users display\n      function updateCollabUsers() {\n        if (!collabConnection) return;\n\n        const usersEl = document.getElementById('collab-users');\n        usersEl.innerHTML = '';\n\n        collabConnection.users.forEach((user, userId) => {\n          if (userId !== collabConnection.userId) {\n            const userEl = document.createElement('div');\n            userEl.className = 'collab-user';\n            userEl.style.backgroundColor = user.color;\n            userEl.textContent = user.name;\n            usersEl.appendChild(userEl);\n          }\n        });\n      }\n\n      function isNodeTypeActive(state, nodeType, attrs = {}) {\n        const { $from } = state.selection;\n        const node = $from.parent;\n\n        if (node.type.name !== nodeType.name) {\n          return false;\n        }\n\n        // Check attributes match\n        for (let key in attrs) {\n          if (node.attrs[key] !== attrs[key]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      function isMarkActive(state, markType) {\n        const { from, to } = state.selection;\n        return state.doc.rangeHasMark(from, to, markType);\n      }\n\n      // Get current toolbar state based on selection\n      function getToolbarState() {\n        const state = editorView.state;\n        return {\n          paragraph: isNodeTypeActive(state, schema.nodes.paragraph),\n          h1: isNodeTypeActive(state, schema.nodes.heading, { level: 1 }),\n          h2: isNodeTypeActive(state, schema.nodes.heading, { level: 2 }),\n          h3: isNodeTypeActive(state, schema.nodes.heading, { level: 3 }),\n          bold: schema.marks.strong ? isMarkActive(state, schema.marks.strong) : false,\n          italic: schema.marks.em ? isMarkActive(state, schema.marks.em) : false\n        };\n      }\n\n      // Create editor view\n      editorView = new EditorView(document.querySelector('#editor-container'), {\n        state: editorState,\n        nodeViews: {\n          geoMark: createGeoMarkNodeView\n        },\n        attributes: {\n          spellcheck: 'false',\n          autocorrect: 'off',\n          autocapitalize: 'off'\n        },\n        dispatchTransaction(transaction) {\n          const oldState = editorView.state;\n          const newState = oldState.apply(transaction);\n          editorView.updateState(newState);\n\n          // Update typing cursor position on any change\n          if (isTypingActive) {\n            updateTypingCursor();\n          }\n\n          // Send document changes to native\n          if (transaction.docChanged) {\n            const docJSON = newState.doc.toJSON();\n            console.log('[WebView] Document changed, sending to native:', JSON.stringify(docJSON));\n            sendMessageToNative({\n              type: 'documentChange',\n              doc: docJSON\n            });\n          }\n\n          // Send selection changes to native\n          const oldSelection = oldState.selection;\n          const newSelection = newState.selection;\n          if (!oldSelection.eq(newSelection)) {\n            console.log('[WebView] Selection changed, empty:', newSelection.empty);\n            sendMessageToNative({\n              type: 'selectionChange',\n              empty: newSelection.empty\n            });\n\n            // Send toolbar state update\n            const toolbarState = getToolbarState();\n            sendMessageToNative({\n              type: 'toolbarStateChange',\n              state: toolbarState\n            });\n          }\n        }\n      });\n\n      console.log('[WebView] Editor created successfully');\n      setStatus('Editor ready');\n\n      // Add click handler for geo-marks and comments\n      document.querySelector('#editor-container').addEventListener('click', function(e) {\n        if (e.target.classList.contains('geo-mark')) {\n          const attrs = {\n            geoId: e.target.getAttribute('data-geo-id'),\n            placeName: e.target.getAttribute('data-place-name'),\n            lat: e.target.getAttribute('data-lat'),\n            lng: e.target.getAttribute('data-lng'),\n            colorIndex: parseInt(e.target.getAttribute('data-color-index') || '0'),\n            coordSource: e.target.getAttribute('data-coord-source')\n          };\n          console.log('[WebView] Geo-mark clicked:', attrs);\n          sendMessageToNative({\n            type: 'geoMarkNavigate',\n            attrs: attrs\n          });\n        }\n\n        if (e.target.classList.contains('comment-mark')) {\n          const repliesStr = e.target.getAttribute('data-replies');\n          let replies = null;\n          if (repliesStr) {\n            try {\n              replies = JSON.parse(repliesStr);\n            } catch (err) {\n              console.error('[WebView] Error parsing replies:', err);\n            }\n          }\n\n          const attrs = {\n            commentId: e.target.getAttribute('data-comment-id'),\n            userId: e.target.getAttribute('data-user-id'),\n            userName: e.target.getAttribute('data-user-name') || '',\n            content: e.target.getAttribute('data-content') || '',\n            createdAt: e.target.getAttribute('data-created-at'),\n            resolved: e.target.getAttribute('data-resolved') === 'true',\n            replies: replies\n          };\n          console.log('[WebView] Comment clicked:', attrs);\n          sendMessageToNative({\n            type: 'commentClick',\n            attrs: attrs\n          });\n        }\n      });\n\n      // Send ready message\n      sendMessageToNative({\n        type: 'ready',\n        message: 'ProseMirror editor initialized'\n      });\n\n      // Send initial toolbar state\n      const initialToolbarState = getToolbarState();\n      sendMessageToNative({\n        type: 'toolbarStateChange',\n        state: initialToolbarState\n      });\n\n      // Listen for iOS custom menu actions\n      // iOS will trigger this when custom menu items are selected\n      document.addEventListener('selectionchange', function() {\n        console.log('[WebView] Selection changed via DOM');\n        const selection = window.getSelection();\n        if (selection && !selection.isCollapsed) {\n          const selectedText = selection.toString();\n          console.log('[WebView] Selected text from DOM:', selectedText);\n        }\n      });\n\n      // Intercept iOS UIMenuItem actions via a hidden input trick\n      // When iOS menu items are clicked, we can detect it through focus/blur events\n      let lastSelectedText = '';\n      let pendingGeoMarkCreation = false;\n\n      // Store selection when text is selected\n      document.addEventListener('selectionchange', function() {\n        const selection = window.getSelection();\n        if (selection && !selection.isCollapsed) {\n          lastSelectedText = selection.toString();\n          console.log('[WebView] Stored selected text:', lastSelectedText);\n        }\n      });\n\n      // Create a global function that iOS can call\n      window.createLocationFromSelection = function() {\n        console.log('[WebView] createLocationFromSelection called!');\n        const { state } = editorView;\n        const { selection } = state;\n\n        if (selection.empty) {\n          console.warn('[WebView] No text selected');\n          return;\n        }\n\n        const selectedText = state.doc.textBetween(\n          selection.from,\n          selection.to,\n          ' '\n        );\n\n        console.log('[WebView] Creating location from iOS menu for:', selectedText);\n\n        // Send request to show geo-mark editor\n        sendMessageToNative({\n          type: 'showGeoMarkEditor',\n          data: {\n            placeName: selectedText,\n            from: selection.from,\n            to: selection.to\n          },\n          existingLocations: []\n        });\n      };\n\n      // Expose to window for iOS to call\n      window.handleCreateLocation = window.createLocationFromSelection;\n\n      // Listen for messages from React Native and native iOS menu\n      window.addEventListener('message', function(event) {\n        console.log('[WebView] Received message:', event.data);\n\n        // Handle native iOS menu actions\n        if (event.data && event.data.source === 'nativeMenu') {\n          console.log('[WebView] Native menu action:', event.data.action);\n\n          if (event.data.action === 'createLocation') {\n            console.log('[WebView] Create location from native menu:', event.data.data.selectedText);\n            // Trigger the create location function\n            if (window.createLocationFromSelection) {\n              window.createLocationFromSelection();\n            }\n            return;\n          }\n\n          if (event.data.action === 'addNote') {\n            console.log('[WebView] Add note from native menu:', event.data.data.selectedText);\n            // Handle add note action\n            return;\n          }\n        }\n\n        try {\n          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n\n          switch (data.type) {\n            case 'setContent':\n              console.log('[WebView] Setting content:', JSON.stringify(data.content));\n              if (data.content && editorView) {\n                try {\n                  const doc = schema.nodeFromJSON(data.content);\n                  console.log('[WebView] Created doc from JSON:', doc.toString());\n                  console.log('[WebView] Doc content:', doc.content.toString());\n\n                  // Check for headings in the document\n                  let hasHeadings = false;\n                  doc.descendants((node) => {\n                    if (node.type.name === 'heading') {\n                      console.log('[WebView] Found heading node, level:', node.attrs.level);\n                      hasHeadings = true;\n                    }\n                  });\n                  console.log('[WebView] Document has headings:', hasHeadings);\n\n                  // Create new state with fresh plugins\n                  const newState = EditorState.create({\n                    doc: doc,\n                    schema: schema,\n                    plugins: [\n                      history(),\n                      keymap({ 'Mod-z': undo, 'Mod-y': redo }),\n                      keymap(baseKeymap)\n                    ]\n                  });\n                  editorView.updateState(newState);\n                  editorState = newState;\n\n                  // Send updated toolbar state after loading content\n                  const toolbarState = getToolbarState();\n                  sendMessageToNative({\n                    type: 'toolbarStateChange',\n                    state: toolbarState\n                  });\n                } catch (e) {\n                  console.error('[WebView] Error creating doc from JSON:', e);\n                  console.error('[WebView] Content was:', JSON.stringify(data.content));\n                }\n              }\n              break;\n\n            case 'setEditable':\n              console.log('[WebView] Setting editable:', data.editable);\n              if (editorView) {\n                editorView.setProps({ editable: () => data.editable });\n              }\n              break;\n\n            case 'getState':\n              console.log('[WebView] Getting state');\n              if (editorView) {\n                sendMessageToNative({\n                  type: 'stateResponse',\n                  state: editorView.state.doc.toJSON()\n                });\n              }\n              break;\n\n            case 'createGeoMark':\n              console.log('[WebView] Creating geo-mark with data:', data.geoMarkData);\n              sendMessageToNative({\n                type: 'debug',\n                message: '[WebView DEBUG] Received createGeoMark message'\n              });\n\n              if (editorView && data.geoMarkData) {\n                const { state, dispatch } = editorView;\n                const { selection } = state;\n                const { from, to } = selection;\n\n                sendMessageToNative({\n                  type: 'debug',\n                  message: `[WebView DEBUG] Selection from ${from} to ${to}, selected text: \"${state.doc.textBetween(from, to, ' ')}\"`\n                });\n\n                // Create a geoMark NODE (not mark) with the location data\n                const geoMarkType = schema.nodes.geoMark;\n                if (!geoMarkType) {\n                  console.error('[WebView] geoMark node type not found in schema');\n                  break;\n                }\n\n                // Get the selected text\n                const selectedText = state.doc.textBetween(from, to, ' ');\n\n                // Create geoMark node with text content and all attributes\n                const geoMarkNode = geoMarkType.create(\n                  {\n                    geoId: data.geoMarkData.geoId,\n                    placeName: data.geoMarkData.placeName,\n                    lat: data.geoMarkData.lat,\n                    lng: data.geoMarkData.lng,\n                    colorIndex: data.geoMarkData.colorIndex || 0,\n                    coordSource: data.geoMarkData.coordSource || 'manual',\n                    description: data.geoMarkData.description || null,\n                    transportFrom: data.geoMarkData.transportFrom || null,\n                    transportProfile: data.geoMarkData.transportProfile || null,\n                    waypoints: data.geoMarkData.waypoints || null,\n                    visitDocument: data.geoMarkData.visitDocument || null,\n                    photoName: data.geoMarkData.photoName || null\n                  },\n                  schema.text(selectedText)\n                );\n\n                // Replace the selected text with the geo-mark node\n                const tr = state.tr.replaceSelectionWith(geoMarkNode);\n                dispatch(tr);\n\n                console.log('[WebView] Geo-mark NODE created successfully');\n                sendMessageToNative({\n                  type: 'info',\n                  message: 'Location created: ' + data.geoMarkData.placeName\n                });\n              }\n              break;\n\n            case 'command':\n              console.log('[WebView] Executing command:', data.command, data.params);\n              if (!editorView) {\n                console.warn('[WebView] Editor view not available');\n                break;\n              }\n\n              const { state, dispatch } = editorView;\n              const { selection } = state;\n              const { from, to } = selection;\n\n              switch (data.command) {\n                case 'setParagraph':\n                  console.log('[WebView] Setting paragraph');\n                  const paragraphTr = state.tr.setBlockType(from, to, schema.nodes.paragraph);\n                  dispatch(paragraphTr);\n                  editorView.focus();\n                  break;\n\n                case 'setHeading':\n                  const level = data.params?.level || 1;\n                  console.log('[WebView] Setting heading level:', level);\n                  // Get the current cursor position\n                  const cursorPos = state.selection.$from.pos;\n                  // Find the bounds of the current block (paragraph)\n                  const $pos = state.doc.resolve(cursorPos);\n                  const blockStart = $pos.before($pos.depth);\n                  const blockEnd = $pos.after($pos.depth);\n                  // Only set heading for the current block\n                  const headingTr = state.tr.setBlockType(blockStart, blockEnd, schema.nodes.heading, { level });\n                  dispatch(headingTr);\n                  console.log('[WebView] Set heading from', blockStart, 'to', blockEnd);\n                  editorView.focus();\n                  break;\n\n                case 'toggleBold':\n                  console.log('[WebView] Toggling bold');\n                  if (schema.marks.strong) {\n                    const hasBold = state.doc.rangeHasMark(from, to, schema.marks.strong);\n                    if (hasBold) {\n                      dispatch(state.tr.removeMark(from, to, schema.marks.strong));\n                    } else {\n                      dispatch(state.tr.addMark(from, to, schema.marks.strong.create()));\n                    }\n                    editorView.focus();\n                  }\n                  break;\n\n                case 'toggleItalic':\n                  console.log('[WebView] Toggling italic');\n                  if (schema.marks.em) {\n                    const hasItalic = state.doc.rangeHasMark(from, to, schema.marks.em);\n                    if (hasItalic) {\n                      dispatch(state.tr.removeMark(from, to, schema.marks.em));\n                    } else {\n                      dispatch(state.tr.addMark(from, to, schema.marks.em.create()));\n                    }\n                    editorView.focus();\n                  }\n                  break;\n\n                case 'createGeoMark':\n                  // Check if there's selected text\n                  if (selection.empty) {\n                    console.warn('[WebView] No text selected for geo-mark');\n                    sendMessageToNative({\n                      type: 'error',\n                      message: 'Please select text to create a location'\n                    });\n                    break;\n                  }\n\n                  // Get selected text\n                  const selectedText = state.doc.textBetween(from, to, ' ');\n                  console.log('[WebView] Selected text:', selectedText);\n\n                  // Send request to show geo-mark editor with selected text\n                  sendMessageToNative({\n                    type: 'showGeoMarkEditor',\n                    data: {\n                      placeName: selectedText,\n                      from: selection.from,\n                      to: selection.to\n                    },\n                    existingLocations: []\n                  });\n                  break;\n\n                case 'addComment':\n                  // Check if there's selected text\n                  if (selection.empty) {\n                    console.warn('[WebView] No text selected for comment');\n                    sendMessageToNative({\n                      type: 'error',\n                      message: 'Please select text to add a comment'\n                    });\n                    break;\n                  }\n\n                  // Get selected text\n                  const commentSelectedText = state.doc.textBetween(from, to, ' ');\n                  console.log('[WebView] Selected text for comment:', commentSelectedText);\n\n                  // Send request to show comment editor\n                  sendMessageToNative({\n                    type: 'showCommentEditor',\n                    data: {\n                      selectedText: commentSelectedText,\n                      from: selection.from,\n                      to: selection.to\n                    }\n                  });\n                  break;\n\n                case 'createComment':\n                  // Create a comment mark with the provided data\n                  if (data.params && schema.marks.comment) {\n                    const commentMark = schema.marks.comment.create({\n                      commentId: data.params.commentId,\n                      userId: data.params.userId,\n                      userName: data.params.userName,\n                      content: data.params.content,\n                      createdAt: data.params.createdAt,\n                      resolved: data.params.resolved || false,\n                      replies: data.params.replies || null\n                    });\n\n                    const commentTr = state.tr.addMark(\n                      data.params.from || from,\n                      data.params.to || to,\n                      commentMark\n                    );\n                    dispatch(commentTr);\n                    console.log('[WebView] Comment created successfully');\n                    editorView.focus();\n                  }\n                  break;\n\n                case 'updateCommentAIReply':\n                  // Update a comment mark's aiReply attribute\n                  console.log('[WebView] Updating comment AI reply:', data.commentId);\n                  if (data.commentId && data.aiReplyDoc && schema.marks.comment) {\n                    let commentFound = false;\n                    const updateTr = state.tr;\n\n                    // Find all comment marks in the document\n                    state.doc.descendants((node, pos) => {\n                      if (!node.isText) return;\n\n                      // Check if this text node has a comment mark with matching ID\n                      const commentMark = node.marks.find(\n                        mark => mark.type.name === 'comment' && mark.attrs.commentId === data.commentId\n                      );\n\n                      if (commentMark) {\n                        commentFound = true;\n                        const nodeStart = pos;\n                        const nodeEnd = pos + node.nodeSize;\n\n                        console.log('[WebView] Found comment mark at', nodeStart, '-', nodeEnd);\n\n                        // Create updated comment mark with aiReply\n                        const updatedCommentMark = schema.marks.comment.create({\n                          ...commentMark.attrs,\n                          aiReply: data.aiReplyDoc\n                        });\n\n                        // Remove old mark and add updated one\n                        updateTr.removeMark(nodeStart, nodeEnd, commentMark);\n                        updateTr.addMark(nodeStart, nodeEnd, updatedCommentMark);\n\n                        console.log('[WebView] Updated comment with AI reply');\n                      }\n                    });\n\n                    if (commentFound) {\n                      dispatch(updateTr);\n                      console.log('[WebView] Comment AI reply updated successfully');\n                      sendMessageToNative({\n                        type: 'info',\n                        message: 'AI reply received'\n                      });\n                    } else {\n                      console.warn('[WebView] Comment not found:', data.commentId);\n                    }\n                  }\n                  break;\n\n                case 'focusEditor':\n                  console.log('[WebView] Focusing editor');\n                  // Focus the editor\n                  editorView.focus();\n                  // Move cursor to end of document\n                  const endPos = state.doc.content.size;\n                  const focusTr = state.tr.setSelection(\n                    window.PM.state.Selection.near(state.doc.resolve(endPos))\n                  );\n                  dispatch(focusTr);\n                  console.log('[WebView] Editor focused, cursor at end');\n                  break;\n\n                case 'insertText':\n                  console.log('[WebView] Inserting text:', data.params?.text);\n                  // Insert text at current cursor position\n                  const text = data.params?.text || '';\n                  const insertTextTr = state.tr.insertText(text);\n                  dispatch(insertTextTr);\n                  console.log('[WebView] Text inserted at pos:', state.selection.$from.pos);\n                  break;\n\n                case 'insertParagraph':\n                  console.log('[WebView] Inserting paragraph');\n                  // Split the current block and reset to paragraph\n                  let paraTr = state.tr.split(state.selection.to);\n                  // After split, set the new block to paragraph (not heading)\n                  const newPos = paraTr.selection.$from.pos;\n                  const $newPos = paraTr.doc.resolve(newPos);\n                  const newBlockStart = $newPos.before($newPos.depth);\n                  const newBlockEnd = $newPos.after($newPos.depth);\n                  paraTr = paraTr.setBlockType(newBlockStart, newBlockEnd, schema.nodes.paragraph);\n                  dispatch(paraTr);\n                  console.log('[WebView] Paragraph split/inserted and reset to paragraph type');\n                  break;\n\n                case 'selectBackward':\n                  console.log('[WebView] Selecting backward:', data.params?.length);\n                  sendMessageToNative({\n                    type: 'debug',\n                    message: `[WebView DEBUG] selectBackward command received, length: ${data.params?.length}`\n                  });\n\n                  try {\n                    // Select text backwards from cursor by the specified length\n                    const length = data.params?.length || 0;\n                    const currentPos = state.selection.to;\n                    const startPos = Math.max(0, currentPos - length);\n\n                    sendMessageToNative({\n                      type: 'debug',\n                      message: `[WebView DEBUG] Before selection: currentPos=${currentPos}, will select from ${startPos} to ${currentPos}`\n                    });\n\n                    const selectTr = state.tr.setSelection(\n                      window.PM.state.TextSelection.create(state.doc, startPos, currentPos)\n                    );\n\n                    sendMessageToNative({\n                      type: 'debug',\n                      message: `[WebView DEBUG] Created selection transaction, about to dispatch`\n                    });\n\n                    dispatch(selectTr);\n\n                    sendMessageToNative({\n                      type: 'debug',\n                      message: `[WebView DEBUG] After selection dispatch: from ${startPos} to ${currentPos}`\n                    });\n                  } catch (error) {\n                    sendMessageToNative({\n                      type: 'error',\n                      message: `[WebView ERROR] selectBackward failed: ${error.message}`\n                    });\n                  }\n                  break;\n\n                case 'selectRange':\n                  console.log('[WebView] Selecting range:', data.params?.from, 'to', data.params?.to);\n                  try {\n                    const rangeFrom = data.params?.from || 0;\n                    const rangeTo = data.params?.to || 0;\n\n                    // Create selection for the specified range\n                    const rangeTr = state.tr.setSelection(\n                      window.PM.state.TextSelection.create(state.doc, rangeFrom, rangeTo)\n                    );\n                    dispatch(rangeTr);\n                    console.log('[WebView] Range selected from', rangeFrom, 'to', rangeTo);\n                  } catch (error) {\n                    console.error('[WebView] selectRange failed:', error);\n                  }\n                  break;\n\n                case 'deleteSelection':\n                  console.log('[WebView] Deleting selection');\n                  try {\n                    // Delete the current selection\n                    const deleteTr = state.tr.deleteSelection();\n                    dispatch(deleteTr);\n                    console.log('[WebView] Selection deleted');\n                  } catch (error) {\n                    console.error('[WebView] deleteSelection failed:', error);\n                  }\n                  break;\n\n                case 'showTypingCursor':\n                  console.log('[WebView] Showing typing cursor');\n                  showTypingCursor();\n                  break;\n\n                case 'hideTypingCursor':\n                  console.log('[WebView] Hiding typing cursor');\n                  hideTypingCursor();\n                  break;\n\n                default:\n                  console.warn('[WebView] Unknown command:', data.command);\n              }\n              break;\n\n            case 'startCollaboration':\n              console.log('[WebView] Starting collaboration:', data);\n              if (editorView && window.io && window.PM.collab) {\n                const { serverUrl, documentId, userId, userName } = data;\n\n                // Connect to WebSocket server\n                socket = window.io(serverUrl, {\n                  transports: ['websocket'],\n                  reconnectionDelayMax: 10000\n                });\n\n                // Initialize collaboration\n                const { CollabConnection, createCollabPlugin } = window.PM.collab;\n                collabConnection = new CollabConnection(socket, documentId, userId, userName);\n                collabPlugin = createCollabPlugin(collabConnection);\n\n                // Update editor state with collaboration plugin\n                const plugins = editorView.state.plugins.filter(p => !p.spec.key || p.spec.key.key !== 'collab');\n                plugins.push(collabPlugin);\n\n                const newState = editorView.state.reconfigure({ plugins });\n                editorView.updateState(newState);\n\n                // Update UI\n                const statusEl = document.getElementById('collab-status');\n                statusEl.textContent = 'Connecting...';\n                statusEl.className = 'disconnected';\n\n                // Socket event handlers for UI updates\n                socket.on('connect', () => {\n                  console.log('[WebView] Connected to collaboration server');\n                  statusEl.textContent = 'Connected';\n                  statusEl.className = 'connected';\n\n                  sendMessageToNative({\n                    type: 'collaborationStatus',\n                    status: 'connected'\n                  });\n                });\n\n                socket.on('disconnect', () => {\n                  console.log('[WebView] Disconnected from collaboration server');\n                  statusEl.textContent = 'Disconnected';\n                  statusEl.className = 'disconnected';\n\n                  sendMessageToNative({\n                    type: 'collaborationStatus',\n                    status: 'disconnected'\n                  });\n                });\n\n                socket.on('user-joined', ({ userId, userName, userColor }) => {\n                  console.log('[WebView] User joined:', userName);\n                  updateCollabUsers();\n                });\n\n                socket.on('user-left', ({ userId }) => {\n                  console.log('[WebView] User left:', userId);\n                  updateCollabUsers();\n                });\n\n                sendMessageToNative({\n                  type: 'collaborationStarted',\n                  success: true\n                });\n              } else {\n                console.error('[WebView] Cannot start collaboration - missing dependencies');\n                sendMessageToNative({\n                  type: 'collaborationStarted',\n                  success: false,\n                  error: 'Missing Socket.io or collaboration plugin'\n                });\n              }\n              break;\n\n            case 'stopCollaboration':\n              console.log('[WebView] Stopping collaboration');\n              if (socket) {\n                socket.disconnect();\n                socket = null;\n              }\n              if (collabConnection) {\n                collabConnection.disconnect();\n                collabConnection = null;\n              }\n\n              // Remove collaboration plugin\n              if (editorView && collabPlugin) {\n                const plugins = editorView.state.plugins.filter(p => p !== collabPlugin);\n                const newState = editorView.state.reconfigure({ plugins });\n                editorView.updateState(newState);\n                collabPlugin = null;\n              }\n\n              // Update UI\n              const statusEl = document.getElementById('collab-status');\n              statusEl.textContent = 'Disconnected';\n              statusEl.className = 'disconnected';\n              document.getElementById('collab-users').innerHTML = '';\n\n              sendMessageToNative({\n                type: 'collaborationStopped'\n              });\n              break;\n\n            case 'applySteps':\n              console.log('[WebView] Applying steps from', data.clientID, '- version:', data.version, '- steps:', data.steps.length);\n              if (editorView && data.steps && data.steps.length > 0) {\n                try {\n                  let tr = editorView.state.tr;\n\n                  // Apply each step to the transaction\n                  for (const stepJSON of data.steps) {\n                    const step = Step.fromJSON(schema, stepJSON);\n                    tr.step(step);\n                  }\n\n                  // Apply the transaction to update the editor\n                  editorView.dispatch(tr);\n                  editorState = editorView.state;\n\n                  console.log('[WebView] Successfully applied', data.steps.length, 'steps');\n\n                  // Notify React Native that document changed\n                  sendMessageToNative({\n                    type: 'documentChange',\n                    document: editorView.state.doc.toJSON()\n                  });\n                } catch (e) {\n                  console.error('[WebView] Error applying steps:', e);\n                }\n              }\n              break;\n\n            default:\n              console.warn('[WebView] Unknown message type:', data.type);\n          }\n        } catch (e) {\n          console.error('[WebView] Error handling message:', e);\n        }\n      });\n    }\n  </script>\n</body>\n</html>\n";
