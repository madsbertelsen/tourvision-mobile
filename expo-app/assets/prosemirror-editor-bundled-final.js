// Auto-generated file - do not edit directly
// Generated from: prosemirror-editor-bundled.html + prosemirror-bundle-src.js
// To rebuild: node build-prosemirror.js

export default "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\">\n  <title>ProseMirror Editor</title>\n  <!-- Socket.io client for collaboration -->\n  <script src=\"https://cdn.socket.io/4.6.1/socket.io.min.js\"></script>\n  <style>\n    * {\n      box-sizing: border-box;\n    }\n\n    html, body {\n      margin: 0;\n      padding: 0;\n      height: 100%;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n      background: #ffffff;\n    }\n\n    #editor-container {\n      padding: 0;\n      height: 100%;\n      background: white;\n      display: flex;\n      justify-content: center;\n      /* Thin, auto-hiding scrollbar for WebKit browsers (Chrome, Safari, Edge) */\n      scrollbar-width: thin;\n      scrollbar-color: rgba(0, 0, 0, 0.2) transparent;\n    }\n\n    /* Custom scrollbar styling for WebKit browsers */\n    #editor-container::-webkit-scrollbar {\n      width: 6px;\n    }\n\n    #editor-container::-webkit-scrollbar-track {\n      background: transparent;\n    }\n\n    #editor-container::-webkit-scrollbar-thumb {\n      background-color: rgba(0, 0, 0, 0.2);\n      border-radius: 3px;\n      transition: background-color 0.2s;\n    }\n\n    #editor-container::-webkit-scrollbar-thumb:hover {\n      background-color: rgba(0, 0, 0, 0.3);\n    }\n\n    .ProseMirror {\n      outline: none;\n      padding: 20px 32px;\n      min-height: 100%;\n      max-width: 700px;\n      width: 100%;\n      background: white;\n      border: none;\n      border-radius: 0;\n      caret-color: #3b82f6; /* Bright blue cursor */\n      -webkit-text-size-adjust: 100%;\n      -webkit-tap-highlight-color: transparent;\n    }\n\n    /* Disable spell checking underlines */\n    .ProseMirror * {\n      -webkit-text-decoration-skip: none;\n      text-decoration-skip-ink: none;\n    }\n\n    /* Make cursor/caret more visible with animation */\n    @keyframes blink {\n      0%, 49% { opacity: 1; }\n      50%, 100% { opacity: 0; }\n    }\n\n    /* Enhanced selection highlighting */\n    .ProseMirror ::selection {\n      background-color: #3b82f6; /* Bright blue */\n      color: white;\n    }\n\n    /* Animated selection highlight for demo */\n    .selection-highlight {\n      background-color: rgba(59, 130, 246, 0.4) !important;\n      box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.6);\n      animation: pulse-selection 0.3s ease-in-out;\n    }\n\n    @keyframes pulse-selection {\n      0%, 100% { background-color: rgba(59, 130, 246, 0.3); }\n      50% { background-color: rgba(59, 130, 246, 0.5); }\n    }\n\n    .ProseMirror ::-moz-selection {\n      background-color: #3b82f6;\n      color: white;\n    }\n\n    /* ProseMirror's own selection styling */\n    .ProseMirror-selectednode {\n      outline: 3px solid #3b82f6;\n      outline-offset: 2px;\n    }\n\n    /* Make the gapcursor more visible */\n    .ProseMirror-gapcursor {\n      display: block;\n      pointer-events: none;\n      position: absolute;\n    }\n\n    .ProseMirror-gapcursor:after {\n      content: \"\";\n      display: block;\n      position: absolute;\n      top: -2px;\n      width: 20px;\n      border-top: 2px solid #3b82f6;\n      animation: blink 1.2s step-end infinite;\n    }\n\n    /* Custom typing cursor indicator */\n    #typing-cursor {\n      position: absolute;\n      width: 3px;\n      background-color: #EF4444; /* Bright red for visibility */\n      pointer-events: none;\n      z-index: 1000;\n      animation: blink 0.8s ease-in-out infinite;\n      display: none; /* Hidden by default, shown during typing */\n      box-shadow: 0 0 8px rgba(239, 68, 68, 0.8);\n    }\n\n    #typing-cursor.visible {\n      display: block;\n    }\n\n    /* Collaboration cursors and selections */\n    .collab-cursor {\n      position: relative;\n      display: inline-block;\n      width: 0;\n      height: 1em;\n    }\n\n    .collab-cursor-label {\n      position: absolute;\n      bottom: 100%;\n      left: -2px;\n      background-color: #3b82f6;\n      color: white;\n      font-size: 11px;\n      padding: 2px 4px;\n      border-radius: 3px;\n      white-space: nowrap;\n      pointer-events: none;\n      z-index: 10;\n    }\n\n    .collab-selection {\n      background-color: rgba(59, 130, 246, 0.2);\n    }\n\n    /* Y.js remote cursor and selection styles */\n    .ProseMirror-yjs-cursor {\n      position: relative;\n      margin-left: -1px;\n      margin-right: -1px;\n      border-left: 2px solid;\n      border-right: 2px solid;\n      word-break: normal;\n      pointer-events: none;\n      height: 1em;\n      display: inline-block;\n    }\n\n    .ProseMirror-yjs-cursor > div {\n      position: absolute;\n      top: -1.4em;\n      left: -1px;\n      font-size: 11px;\n      color: white;\n      padding: 2px 6px;\n      border-radius: 3px;\n      white-space: nowrap;\n      font-weight: 500;\n      pointer-events: none;\n      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);\n      z-index: 1000;\n    }\n\n    /* Collaboration status indicator */\n    #collab-status {\n      position: fixed;\n      top: 10px;\n      right: 10px;\n      padding: 4px 8px;\n      background: rgba(0, 0, 0, 0.8);\n      color: white;\n      font-size: 11px;\n      border-radius: 4px;\n      z-index: 100;\n      display: none;\n    }\n\n    #collab-status.connected {\n      background: rgba(16, 185, 129, 0.9);\n      display: block;\n    }\n\n    #collab-status.disconnected {\n      background: rgba(239, 68, 68, 0.9);\n      display: block;\n    }\n\n    #collab-users {\n      position: fixed;\n      top: 10px;\n      left: 10px;\n      display: flex;\n      gap: 8px;\n      z-index: 100;\n    }\n\n    .collab-user {\n      padding: 4px 8px;\n      border-radius: 4px;\n      font-size: 11px;\n      color: white;\n      font-weight: 500;\n    }\n\n    .ProseMirror h1 {\n      font-size: 2em;\n      margin: 0.67em 0;\n      font-weight: bold;\n    }\n\n    .ProseMirror h2 {\n      font-size: 1.5em;\n      margin: 0.75em 0;\n      font-weight: bold;\n    }\n\n    .ProseMirror p {\n      margin: 1em 0;\n    }\n\n    .ProseMirror ul, .ProseMirror ol {\n      padding-left: 30px;\n    }\n\n    .ProseMirror strong {\n      font-weight: bold;\n    }\n\n    .ProseMirror em {\n      font-style: italic;\n    }\n\n    .ProseMirror .geo-mark {\n      background-color: rgba(59, 130, 246, 0.2);\n      padding: 2px 4px;\n      border-radius: 3px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      text-decoration: none !important;\n      border: none !important;\n      border-bottom: none !important;\n      -webkit-text-decoration: none !important;\n    }\n\n    .ProseMirror .geo-mark:hover {\n      background-color: rgba(59, 130, 246, 0.3);\n    }\n\n    .ProseMirror .comment-mark {\n      background-color: rgba(251, 191, 36, 0.3);\n      border-bottom: 2px solid rgba(251, 191, 36, 0.6);\n      cursor: pointer;\n      padding: 1px 0;\n      transition: all 0.2s ease;\n    }\n\n    .ProseMirror .comment-mark:hover {\n      background-color: rgba(251, 191, 36, 0.4);\n      border-bottom-color: rgba(251, 191, 36, 0.9);\n    }\n\n    .ProseMirror .comment-mark[data-resolved=\"true\"] {\n      background-color: rgba(156, 163, 175, 0.2);\n      border-bottom-color: rgba(156, 163, 175, 0.4);\n      opacity: 0.7;\n    }\n\n    .status-bar {\n      display: none; /* Hidden to save space */\n    }\n\n    #editor-container {\n      padding: 0;\n      height: 100%;\n      overflow-y: auto;\n    }\n  </style>\n</head>\n<body>\n  <div class=\"status-bar\" id=\"status\">Loading ProseMirror...</div>\n  <div id=\"collab-status\">Disconnected</div>\n  <div id=\"collab-users\"></div>\n  <div id=\"editor-container\"></div>\n  <div id=\"typing-cursor\"></div>\n\n  <script>\n    console.log('[WebView] Script starting...');\n\n    // Polyfill Web Locks API for sandboxed iframes\n    if (!navigator.locks) {\n      console.log('[WebView] Polyfilling Web Locks API');\n      navigator.locks = {\n        request: async function(name, options, callback) {\n          if (typeof options === 'function') {\n            callback = options;\n            options = {};\n          }\n          // Simple polyfill - just run the callback immediately\n          // This doesn't provide actual locking, but Supabase should handle it\n          return await callback({ name, mode: options.mode || 'exclusive' });\n        }\n      };\n    }\n\n    // Set up message handler\n    function sendMessageToNative(message) {\n      try {\n        const json = JSON.stringify(message);\n        if (window.ReactNativeWebView) {\n          // Native WebView (iOS/Android)\n          window.ReactNativeWebView.postMessage(json);\n        } else if (window.parent && window.parent !== window) {\n          // Web iframe\n          window.parent.postMessage(json, '*');\n        } else {\n          console.warn('[WebView] No message handler available');\n        }\n      } catch (e) {\n        console.error('[WebView] Error sending message:', e);\n      }\n    }\n\n    function setStatus(text, isError = false) {\n      const statusEl = document.getElementById('status');\n      statusEl.textContent = text;\n      statusEl.className = isError ? 'status-bar error' : 'status-bar';\n    }\n\n    // Handle errors\n    window.addEventListener('error', function(e) {\n      console.error('[WebView] Error:', e.message, e.filename, e.lineno);\n      setStatus('Error: ' + e.message, true);\n      sendMessageToNative({\n        type: 'error',\n        message: e.message,\n        filename: e.filename,\n        lineno: e.lineno\n      });\n    });\n\n    // Load ProseMirror bundle\n    console.log('[WebView] About to load ProseMirror bundle...');\n    setStatus('Loading ProseMirror bundle...');\n  </script>\n\n  <!-- INLINE PROSEMIRROR BUNDLE WILL BE INSERTED HERE -->\n  <script id=\"prosemirror-bundle\">\n\"use strict\";\nvar PMBundle = (() => {\n  var __defProp = Object.defineProperty;\n  var __export = (target, all2) => {\n    for (var name in all2)\n      __defProp(target, name, { get: all2[name], enumerable: true });\n  };\n\n  // node_modules/orderedmap/dist/index.js\n  function OrderedMap(content) {\n    this.content = content;\n  }\n  OrderedMap.prototype = {\n    constructor: OrderedMap,\n    find: function(key) {\n      for (var i = 0; i < this.content.length; i += 2)\n        if (this.content[i] === key) return i;\n      return -1;\n    },\n    // :: (string) → ?any\n    // Retrieve the value stored under `key`, or return undefined when\n    // no such key exists.\n    get: function(key) {\n      var found2 = this.find(key);\n      return found2 == -1 ? void 0 : this.content[found2 + 1];\n    },\n    // :: (string, any, ?string) → OrderedMap\n    // Create a new map by replacing the value of `key` with a new\n    // value, or adding a binding to the end of the map. If `newKey` is\n    // given, the key of the binding will be replaced with that key.\n    update: function(key, value, newKey) {\n      var self = newKey && newKey != key ? this.remove(newKey) : this;\n      var found2 = self.find(key), content = self.content.slice();\n      if (found2 == -1) {\n        content.push(newKey || key, value);\n      } else {\n        content[found2 + 1] = value;\n        if (newKey) content[found2] = newKey;\n      }\n      return new OrderedMap(content);\n    },\n    // :: (string) → OrderedMap\n    // Return a map with the given key removed, if it existed.\n    remove: function(key) {\n      var found2 = this.find(key);\n      if (found2 == -1) return this;\n      var content = this.content.slice();\n      content.splice(found2, 2);\n      return new OrderedMap(content);\n    },\n    // :: (string, any) → OrderedMap\n    // Add a new key to the start of the map.\n    addToStart: function(key, value) {\n      return new OrderedMap([key, value].concat(this.remove(key).content));\n    },\n    // :: (string, any) → OrderedMap\n    // Add a new key to the end of the map.\n    addToEnd: function(key, value) {\n      var content = this.remove(key).content.slice();\n      content.push(key, value);\n      return new OrderedMap(content);\n    },\n    // :: (string, string, any) → OrderedMap\n    // Add a key after the given key. If `place` is not found, the new\n    // key is added to the end.\n    addBefore: function(place, key, value) {\n      var without = this.remove(key), content = without.content.slice();\n      var found2 = without.find(place);\n      content.splice(found2 == -1 ? content.length : found2, 0, key, value);\n      return new OrderedMap(content);\n    },\n    // :: ((key: string, value: any))\n    // Call the given function for each key/value pair in the map, in\n    // order.\n    forEach: function(f) {\n      for (var i = 0; i < this.content.length; i += 2)\n        f(this.content[i], this.content[i + 1]);\n    },\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a new map by prepending the keys in this map that don't\n    // appear in `map` before the keys in `map`.\n    prepend: function(map3) {\n      map3 = OrderedMap.from(map3);\n      if (!map3.size) return this;\n      return new OrderedMap(map3.content.concat(this.subtract(map3).content));\n    },\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a new map by appending the keys in this map that don't\n    // appear in `map` after the keys in `map`.\n    append: function(map3) {\n      map3 = OrderedMap.from(map3);\n      if (!map3.size) return this;\n      return new OrderedMap(this.subtract(map3).content.concat(map3.content));\n    },\n    // :: (union<Object, OrderedMap>) → OrderedMap\n    // Create a map containing all the keys in this map that don't\n    // appear in `map`.\n    subtract: function(map3) {\n      var result = this;\n      map3 = OrderedMap.from(map3);\n      for (var i = 0; i < map3.content.length; i += 2)\n        result = result.remove(map3.content[i]);\n      return result;\n    },\n    // :: () → Object\n    // Turn ordered map into a plain object.\n    toObject: function() {\n      var result = {};\n      this.forEach(function(key, value) {\n        result[key] = value;\n      });\n      return result;\n    },\n    // :: number\n    // The amount of keys in this map.\n    get size() {\n      return this.content.length >> 1;\n    }\n  };\n  OrderedMap.from = function(value) {\n    if (value instanceof OrderedMap) return value;\n    var content = [];\n    if (value) for (var prop in value) content.push(prop, value[prop]);\n    return new OrderedMap(content);\n  };\n  var dist_default = OrderedMap;\n\n  // node_modules/prosemirror-model/dist/index.js\n  function findDiffStart(a, b, pos) {\n    for (let i = 0; ; i++) {\n      if (i == a.childCount || i == b.childCount)\n        return a.childCount == b.childCount ? null : pos;\n      let childA = a.child(i), childB = b.child(i);\n      if (childA == childB) {\n        pos += childA.nodeSize;\n        continue;\n      }\n      if (!childA.sameMarkup(childB))\n        return pos;\n      if (childA.isText && childA.text != childB.text) {\n        for (let j = 0; childA.text[j] == childB.text[j]; j++)\n          pos++;\n        return pos;\n      }\n      if (childA.content.size || childB.content.size) {\n        let inner = findDiffStart(childA.content, childB.content, pos + 1);\n        if (inner != null)\n          return inner;\n      }\n      pos += childA.nodeSize;\n    }\n  }\n  function findDiffEnd(a, b, posA, posB) {\n    for (let iA = a.childCount, iB = b.childCount; ; ) {\n      if (iA == 0 || iB == 0)\n        return iA == iB ? null : { a: posA, b: posB };\n      let childA = a.child(--iA), childB = b.child(--iB), size2 = childA.nodeSize;\n      if (childA == childB) {\n        posA -= size2;\n        posB -= size2;\n        continue;\n      }\n      if (!childA.sameMarkup(childB))\n        return { a: posA, b: posB };\n      if (childA.isText && childA.text != childB.text) {\n        let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n        while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n          same++;\n          posA--;\n          posB--;\n        }\n        return { a: posA, b: posB };\n      }\n      if (childA.content.size || childB.content.size) {\n        let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n        if (inner)\n          return inner;\n      }\n      posA -= size2;\n      posB -= size2;\n    }\n  }\n  var Fragment = class _Fragment {\n    /**\n    @internal\n    */\n    constructor(content, size2) {\n      this.content = content;\n      this.size = size2 || 0;\n      if (size2 == null)\n        for (let i = 0; i < content.length; i++)\n          this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn't descend\n    into a node when the callback returns `false`.\n    */\n    nodesBetween(from4, to, f, nodeStart = 0, parent) {\n      for (let i = 0, pos = 0; pos < to; i++) {\n        let child = this.content[i], end = pos + child.nodeSize;\n        if (end > from4 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n          let start = pos + 1;\n          child.nodesBetween(Math.max(0, from4 - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n        }\n        pos = end;\n      }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */\n    descendants(f) {\n      this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */\n    textBetween(from4, to, blockSeparator, leafText) {\n      let text2 = \"\", first = true;\n      this.nodesBetween(from4, to, (node, pos) => {\n        let nodeText = node.isText ? node.text.slice(Math.max(from4, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n          if (first)\n            first = false;\n          else\n            text2 += blockSeparator;\n        }\n        text2 += nodeText;\n      }, 0);\n      return text2;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */\n    append(other) {\n      if (!other.size)\n        return this;\n      if (!this.size)\n        return other;\n      let last2 = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n      if (last2.isText && last2.sameMarkup(first)) {\n        content[content.length - 1] = last2.withText(last2.text + first.text);\n        i = 1;\n      }\n      for (; i < other.content.length; i++)\n        content.push(other.content[i]);\n      return new _Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */\n    cut(from4, to = this.size) {\n      if (from4 == 0 && to == this.size)\n        return this;\n      let result = [], size2 = 0;\n      if (to > from4)\n        for (let i = 0, pos = 0; pos < to; i++) {\n          let child = this.content[i], end = pos + child.nodeSize;\n          if (end > from4) {\n            if (pos < from4 || end > to) {\n              if (child.isText)\n                child = child.cut(Math.max(0, from4 - pos), Math.min(child.text.length, to - pos));\n              else\n                child = child.cut(Math.max(0, from4 - pos - 1), Math.min(child.content.size, to - pos - 1));\n            }\n            result.push(child);\n            size2 += child.nodeSize;\n          }\n          pos = end;\n        }\n      return new _Fragment(result, size2);\n    }\n    /**\n    @internal\n    */\n    cutByIndex(from4, to) {\n      if (from4 == to)\n        return _Fragment.empty;\n      if (from4 == 0 && to == this.content.length)\n        return this;\n      return new _Fragment(this.content.slice(from4, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */\n    replaceChild(index, node) {\n      let current = this.content[index];\n      if (current == node)\n        return this;\n      let copy3 = this.content.slice();\n      let size2 = this.size + node.nodeSize - current.nodeSize;\n      copy3[index] = node;\n      return new _Fragment(copy3, size2);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */\n    addToStart(node) {\n      return new _Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */\n    addToEnd(node) {\n      return new _Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */\n    eq(other) {\n      if (this.content.length != other.content.length)\n        return false;\n      for (let i = 0; i < this.content.length; i++)\n        if (!this.content[i].eq(other.content[i]))\n          return false;\n      return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */\n    get firstChild() {\n      return this.content.length ? this.content[0] : null;\n    }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */\n    get lastChild() {\n      return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n    /**\n    The number of child nodes in this fragment.\n    */\n    get childCount() {\n      return this.content.length;\n    }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */\n    child(index) {\n      let found2 = this.content[index];\n      if (!found2)\n        throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n      return found2;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) {\n      return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) {\n      for (let i = 0, p = 0; i < this.content.length; i++) {\n        let child = this.content[i];\n        f(child, p, i);\n        p += child.nodeSize;\n      }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */\n    findDiffStart(other, pos = 0) {\n      return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */\n    findDiffEnd(other, pos = this.size, otherPos = other.size) {\n      return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. @internal\n    */\n    findIndex(pos) {\n      if (pos == 0)\n        return retIndex(0, pos);\n      if (pos == this.size)\n        return retIndex(this.content.length, pos);\n      if (pos > this.size || pos < 0)\n        throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n      for (let i = 0, curPos = 0; ; i++) {\n        let cur = this.child(i), end = curPos + cur.nodeSize;\n        if (end >= pos) {\n          if (end == pos)\n            return retIndex(i + 1, end);\n          return retIndex(i, curPos);\n        }\n        curPos = end;\n      }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */\n    toString() {\n      return \"<\" + this.toStringInner() + \">\";\n    }\n    /**\n    @internal\n    */\n    toStringInner() {\n      return this.content.join(\", \");\n    }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */\n    toJSON() {\n      return this.content.length ? this.content.map((n) => n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */\n    static fromJSON(schema2, value) {\n      if (!value)\n        return _Fragment.empty;\n      if (!Array.isArray(value))\n        throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n      return new _Fragment(value.map(schema2.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */\n    static fromArray(array) {\n      if (!array.length)\n        return _Fragment.empty;\n      let joined, size2 = 0;\n      for (let i = 0; i < array.length; i++) {\n        let node = array[i];\n        size2 += node.nodeSize;\n        if (i && node.isText && array[i - 1].sameMarkup(node)) {\n          if (!joined)\n            joined = array.slice(0, i);\n          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n        } else if (joined) {\n          joined.push(node);\n        }\n      }\n      return new _Fragment(joined || array, size2);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */\n    static from(nodes2) {\n      if (!nodes2)\n        return _Fragment.empty;\n      if (nodes2 instanceof _Fragment)\n        return nodes2;\n      if (Array.isArray(nodes2))\n        return this.fromArray(nodes2);\n      if (nodes2.attrs)\n        return new _Fragment([nodes2], nodes2.nodeSize);\n      throw new RangeError(\"Can not convert \" + nodes2 + \" to a Fragment\" + (nodes2.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n  };\n  Fragment.empty = new Fragment([], 0);\n  var found = { index: 0, offset: 0 };\n  function retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n  }\n  function compareDeep(a, b) {\n    if (a === b)\n      return true;\n    if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\"))\n      return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array)\n      return false;\n    if (array) {\n      if (a.length != b.length)\n        return false;\n      for (let i = 0; i < a.length; i++)\n        if (!compareDeep(a[i], b[i]))\n          return false;\n    } else {\n      for (let p in a)\n        if (!(p in b) || !compareDeep(a[p], b[p]))\n          return false;\n      for (let p in b)\n        if (!(p in a))\n          return false;\n    }\n    return true;\n  }\n  var Mark = class _Mark {\n    /**\n    @internal\n    */\n    constructor(type, attrs) {\n      this.type = type;\n      this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */\n    addToSet(set) {\n      let copy3, placed = false;\n      for (let i = 0; i < set.length; i++) {\n        let other = set[i];\n        if (this.eq(other))\n          return set;\n        if (this.type.excludes(other.type)) {\n          if (!copy3)\n            copy3 = set.slice(0, i);\n        } else if (other.type.excludes(this.type)) {\n          return set;\n        } else {\n          if (!placed && other.type.rank > this.type.rank) {\n            if (!copy3)\n              copy3 = set.slice(0, i);\n            copy3.push(this);\n            placed = true;\n          }\n          if (copy3)\n            copy3.push(other);\n        }\n      }\n      if (!copy3)\n        copy3 = set.slice();\n      if (!placed)\n        copy3.push(this);\n      return copy3;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */\n    removeFromSet(set) {\n      for (let i = 0; i < set.length; i++)\n        if (this.eq(set[i]))\n          return set.slice(0, i).concat(set.slice(i + 1));\n      return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */\n    isInSet(set) {\n      for (let i = 0; i < set.length; i++)\n        if (this.eq(set[i]))\n          return true;\n      return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */\n    eq(other) {\n      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */\n    toJSON() {\n      let obj = { type: this.type.name };\n      for (let _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */\n    static fromJSON(schema2, json) {\n      if (!json)\n        throw new RangeError(\"Invalid input for Mark.fromJSON\");\n      let type = schema2.marks[json.type];\n      if (!type)\n        throw new RangeError(`There is no mark type ${json.type} in this schema`);\n      let mark = type.create(json.attrs);\n      type.checkAttrs(mark.attrs);\n      return mark;\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */\n    static sameSet(a, b) {\n      if (a == b)\n        return true;\n      if (a.length != b.length)\n        return false;\n      for (let i = 0; i < a.length; i++)\n        if (!a[i].eq(b[i]))\n          return false;\n      return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */\n    static setFrom(marks2) {\n      if (!marks2 || Array.isArray(marks2) && marks2.length == 0)\n        return _Mark.none;\n      if (marks2 instanceof _Mark)\n        return [marks2];\n      let copy3 = marks2.slice();\n      copy3.sort((a, b) => a.type.rank - b.type.rank);\n      return copy3;\n    }\n  };\n  Mark.none = [];\n  var ReplaceError = class extends Error {\n  };\n  var Slice = class _Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can't be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema's content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */\n    constructor(content, openStart, openEnd) {\n      this.content = content;\n      this.openStart = openStart;\n      this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */\n    get size() {\n      return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */\n    insertAt(pos, fragment) {\n      let content = insertInto(this.content, pos + this.openStart, fragment);\n      return content && new _Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */\n    removeBetween(from4, to) {\n      return new _Slice(removeRange(this.content, from4 + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */\n    eq(other) {\n      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */\n    toString() {\n      return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */\n    toJSON() {\n      if (!this.content.size)\n        return null;\n      let json = { content: this.content.toJSON() };\n      if (this.openStart > 0)\n        json.openStart = this.openStart;\n      if (this.openEnd > 0)\n        json.openEnd = this.openEnd;\n      return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */\n    static fromJSON(schema2, json) {\n      if (!json)\n        return _Slice.empty;\n      let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n      if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n        throw new RangeError(\"Invalid input for Slice.fromJSON\");\n      return new _Slice(Fragment.fromJSON(schema2, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */\n    static maxOpen(fragment, openIsolating = true) {\n      let openStart = 0, openEnd = 0;\n      for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)\n        openStart++;\n      for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)\n        openEnd++;\n      return new _Slice(fragment, openStart, openEnd);\n    }\n  };\n  Slice.empty = new Slice(Fragment.empty, 0, 0);\n  function removeRange(content, from4, to) {\n    let { index, offset } = content.findIndex(from4), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from4 || child.isText) {\n      if (offsetTo != to && !content.child(indexTo).isText)\n        throw new RangeError(\"Removing non-flat range\");\n      return content.cut(0, from4).append(content.cut(to));\n    }\n    if (index != indexTo)\n      throw new RangeError(\"Removing non-flat range\");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from4 - offset - 1, to - offset - 1)));\n  }\n  function insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n      if (parent && !parent.canReplace(index, index, insert))\n        return null;\n      return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert, child);\n    return inner && content.replaceChild(index, child.copy(inner));\n  }\n  function replace($from, $to, slice2) {\n    if (slice2.openStart > $from.depth)\n      throw new ReplaceError(\"Inserted content deeper than insertion position\");\n    if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)\n      throw new ReplaceError(\"Inconsistent open depths\");\n    return replaceOuter($from, $to, slice2, 0);\n  }\n  function replaceOuter($from, $to, slice2, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice2.openStart) {\n      let inner = replaceOuter($from, $to, slice2, depth + 1);\n      return node.copy(node.content.replaceChild(index, inner));\n    } else if (!slice2.content.size) {\n      return close(node, replaceTwoWay($from, $to, depth));\n    } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {\n      let parent = $from.parent, content = parent.content;\n      return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));\n    } else {\n      let { start, end } = prepareSliceForReplace(slice2, $from);\n      return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n  }\n  function checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type))\n      throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n  }\n  function joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n  }\n  function addNode(child, target) {\n    let last2 = target.length - 1;\n    if (last2 >= 0 && child.isText && child.sameMarkup(target[last2]))\n      target[last2] = child.withText(target[last2].text + child.text);\n    else\n      target.push(child);\n  }\n  function addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n      startIndex = $start.index(depth);\n      if ($start.depth > depth) {\n        startIndex++;\n      } else if ($start.textOffset) {\n        addNode($start.nodeAfter, target);\n        startIndex++;\n      }\n    }\n    for (let i = startIndex; i < endIndex; i++)\n      addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset)\n      addNode($end.nodeBefore, target);\n  }\n  function close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n  }\n  function replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n      checkJoin(openStart, openEnd);\n      addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    } else {\n      if (openStart)\n        addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n      addRange($start, $end, depth, content);\n      if (openEnd)\n        addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n  }\n  function replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n      let type = joinable($from, $to, depth + 1);\n      addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n  }\n  function prepareSliceForReplace(slice2, $along) {\n    let extra = $along.depth - slice2.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice2.content);\n    for (let i = extra - 1; i >= 0; i--)\n      node = $along.node(i).copy(Fragment.from(node));\n    return {\n      start: node.resolveNoCache(slice2.openStart + extra),\n      end: node.resolveNoCache(node.content.size - slice2.openEnd - extra)\n    };\n  }\n  var ResolvedPos = class _ResolvedPos {\n    /**\n    @internal\n    */\n    constructor(pos, path, parentOffset) {\n      this.pos = pos;\n      this.path = path;\n      this.parentOffset = parentOffset;\n      this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */\n    resolveDepth(val) {\n      if (val == null)\n        return this.depth;\n      if (val < 0)\n        return this.depth + val;\n      return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */\n    get parent() {\n      return this.node(this.depth);\n    }\n    /**\n    The root node in which the position was resolved.\n    */\n    get doc() {\n      return this.node(0);\n    }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */\n    node(depth) {\n      return this.path[this.resolveDepth(depth) * 3];\n    }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */\n    index(depth) {\n      return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */\n    indexAfter(depth) {\n      depth = this.resolveDepth(depth);\n      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */\n    start(depth) {\n      depth = this.resolveDepth(depth);\n      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */\n    end(depth) {\n      depth = this.resolveDepth(depth);\n      return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */\n    before(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth)\n        throw new RangeError(\"There is no position before the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */\n    after(depth) {\n      depth = this.resolveDepth(depth);\n      if (!depth)\n        throw new RangeError(\"There is no position after the top-level node\");\n      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */\n    get textOffset() {\n      return this.pos - this.path[this.path.length - 1];\n    }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */\n    get nodeAfter() {\n      let parent = this.parent, index = this.index(this.depth);\n      if (index == parent.childCount)\n        return null;\n      let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n      return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */\n    get nodeBefore() {\n      let index = this.index(this.depth);\n      let dOff = this.pos - this.path[this.path.length - 1];\n      if (dOff)\n        return this.parent.child(index).cut(0, dOff);\n      return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */\n    posAtIndex(index, depth) {\n      depth = this.resolveDepth(depth);\n      let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n      for (let i = 0; i < index; i++)\n        pos += node.child(i).nodeSize;\n      return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */\n    marks() {\n      let parent = this.parent, index = this.index();\n      if (parent.content.size == 0)\n        return Mark.none;\n      if (this.textOffset)\n        return parent.child(index).marks;\n      let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n      if (!main) {\n        let tmp = main;\n        main = other;\n        other = tmp;\n      }\n      let marks2 = main.marks;\n      for (var i = 0; i < marks2.length; i++)\n        if (marks2[i].type.spec.inclusive === false && (!other || !marks2[i].isInSet(other.marks)))\n          marks2 = marks2[i--].removeFromSet(marks2);\n      return marks2;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */\n    marksAcross($end) {\n      let after = this.parent.maybeChild(this.index());\n      if (!after || !after.isInline)\n        return null;\n      let marks2 = after.marks, next = $end.parent.maybeChild($end.index());\n      for (var i = 0; i < marks2.length; i++)\n        if (marks2[i].type.spec.inclusive === false && (!next || !marks2[i].isInSet(next.marks)))\n          marks2 = marks2[i--].removeFromSet(marks2);\n      return marks2;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */\n    sharedDepth(pos) {\n      for (let depth = this.depth; depth > 0; depth--)\n        if (this.start(depth) <= pos && this.end(depth) >= pos)\n          return depth;\n      return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */\n    blockRange(other = this, pred) {\n      if (other.pos < this.pos)\n        return other.blockRange(this);\n      for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n        if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n          return new NodeRange(this, other, d);\n      return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */\n    sameParent(other) {\n      return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */\n    max(other) {\n      return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */\n    min(other) {\n      return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */\n    toString() {\n      let str = \"\";\n      for (let i = 1; i <= this.depth; i++)\n        str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n      return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */\n    static resolve(doc4, pos) {\n      if (!(pos >= 0 && pos <= doc4.content.size))\n        throw new RangeError(\"Position \" + pos + \" out of range\");\n      let path = [];\n      let start = 0, parentOffset = pos;\n      for (let node = doc4; ; ) {\n        let { index, offset } = node.content.findIndex(parentOffset);\n        let rem = parentOffset - offset;\n        path.push(node, index, start + offset);\n        if (!rem)\n          break;\n        node = node.child(index);\n        if (node.isText)\n          break;\n        parentOffset = rem - 1;\n        start += offset + 1;\n      }\n      return new _ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */\n    static resolveCached(doc4, pos) {\n      let cache = resolveCache.get(doc4);\n      if (cache) {\n        for (let i = 0; i < cache.elts.length; i++) {\n          let elt = cache.elts[i];\n          if (elt.pos == pos)\n            return elt;\n        }\n      } else {\n        resolveCache.set(doc4, cache = new ResolveCache());\n      }\n      let result = cache.elts[cache.i] = _ResolvedPos.resolve(doc4, pos);\n      cache.i = (cache.i + 1) % resolveCacheSize;\n      return result;\n    }\n  };\n  var ResolveCache = class {\n    constructor() {\n      this.elts = [];\n      this.i = 0;\n    }\n  };\n  var resolveCacheSize = 12;\n  var resolveCache = /* @__PURE__ */ new WeakMap();\n  var NodeRange = class {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */\n    constructor($from, $to, depth) {\n      this.$from = $from;\n      this.$to = $to;\n      this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */\n    get start() {\n      return this.$from.before(this.depth + 1);\n    }\n    /**\n    The position at the end of the range.\n    */\n    get end() {\n      return this.$to.after(this.depth + 1);\n    }\n    /**\n    The parent node that the range points into.\n    */\n    get parent() {\n      return this.$from.node(this.depth);\n    }\n    /**\n    The start index of the range in the parent node.\n    */\n    get startIndex() {\n      return this.$from.index(this.depth);\n    }\n    /**\n    The end index of the range in the parent node.\n    */\n    get endIndex() {\n      return this.$to.indexAfter(this.depth);\n    }\n  };\n  var emptyAttrs = /* @__PURE__ */ Object.create(null);\n  var Node = class _Node {\n    /**\n    @internal\n    */\n    constructor(type, attrs, content, marks2 = Mark.none) {\n      this.type = type;\n      this.attrs = attrs;\n      this.marks = marks2;\n      this.content = content || Fragment.empty;\n    }\n    /**\n    The array of this node's child nodes.\n    */\n    get children() {\n      return this.content.content;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */\n    get nodeSize() {\n      return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n    /**\n    The number of children that the node has.\n    */\n    get childCount() {\n      return this.content.childCount;\n    }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */\n    child(index) {\n      return this.content.child(index);\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) {\n      return this.content.maybeChild(index);\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) {\n      this.content.forEach(f);\n    }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */\n    nodesBetween(from4, to, f, startPos = 0) {\n      this.content.nodesBetween(from4, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */\n    descendants(f) {\n      this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */\n    get textContent() {\n      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.\n    */\n    textBetween(from4, to, blockSeparator, leafText) {\n      return this.content.textBetween(from4, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */\n    get firstChild() {\n      return this.content.firstChild;\n    }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */\n    get lastChild() {\n      return this.content.lastChild;\n    }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */\n    eq(other) {\n      return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */\n    sameMarkup(other) {\n      return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */\n    hasMarkup(type, attrs, marks2) {\n      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks2 || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */\n    copy(content = null) {\n      if (content == this.content)\n        return this;\n      return new _Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */\n    mark(marks2) {\n      return marks2 == this.marks ? this : new _Node(this.type, this.attrs, this.content, marks2);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */\n    cut(from4, to = this.content.size) {\n      if (from4 == 0 && to == this.content.size)\n        return this;\n      return this.copy(this.content.cut(from4, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */\n    slice(from4, to = this.content.size, includeParents = false) {\n      if (from4 == to)\n        return Slice.empty;\n      let $from = this.resolve(from4), $to = this.resolve(to);\n      let depth = includeParents ? 0 : $from.sharedDepth(to);\n      let start = $from.start(depth), node = $from.node(depth);\n      let content = node.content.cut($from.pos - start, $to.pos - start);\n      return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */\n    replace(from4, to, slice2) {\n      return replace(this.resolve(from4), this.resolve(to), slice2);\n    }\n    /**\n    Find the node directly after the given position.\n    */\n    nodeAt(pos) {\n      for (let node = this; ; ) {\n        let { index, offset } = node.content.findIndex(pos);\n        node = node.maybeChild(index);\n        if (!node)\n          return null;\n        if (offset == pos || node.isText)\n          return node;\n        pos -= offset + 1;\n      }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childAfter(pos) {\n      let { index, offset } = this.content.findIndex(pos);\n      return { node: this.content.maybeChild(index), index, offset };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childBefore(pos) {\n      if (pos == 0)\n        return { node: null, index: 0, offset: 0 };\n      let { index, offset } = this.content.findIndex(pos);\n      if (offset < pos)\n        return { node: this.content.child(index), index, offset };\n      let node = this.content.child(index - 1);\n      return { node, index: index - 1, offset: offset - node.nodeSize };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */\n    resolve(pos) {\n      return ResolvedPos.resolveCached(this, pos);\n    }\n    /**\n    @internal\n    */\n    resolveNoCache(pos) {\n      return ResolvedPos.resolve(this, pos);\n    }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */\n    rangeHasMark(from4, to, type) {\n      let found2 = false;\n      if (to > from4)\n        this.nodesBetween(from4, to, (node) => {\n          if (type.isInSet(node.marks))\n            found2 = true;\n          return !found2;\n        });\n      return found2;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */\n    get isBlock() {\n      return this.type.isBlock;\n    }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */\n    get isTextblock() {\n      return this.type.isTextblock;\n    }\n    /**\n    True when this node allows inline content.\n    */\n    get inlineContent() {\n      return this.type.inlineContent;\n    }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */\n    get isInline() {\n      return this.type.isInline;\n    }\n    /**\n    True when this is a text node.\n    */\n    get isText() {\n      return this.type.isText;\n    }\n    /**\n    True when this is a leaf node.\n    */\n    get isLeaf() {\n      return this.type.isLeaf;\n    }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */\n    get isAtom() {\n      return this.type.isAtom;\n    }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */\n    toString() {\n      if (this.type.spec.toDebugString)\n        return this.type.spec.toDebugString(this);\n      let name = this.type.name;\n      if (this.content.size)\n        name += \"(\" + this.content.toStringInner() + \")\";\n      return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */\n    contentMatchAt(index) {\n      let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n      if (!match)\n        throw new Error(\"Called contentMatchAt on a node with invalid content\");\n      return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */\n    canReplace(from4, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n      let one = this.contentMatchAt(from4).matchFragment(replacement, start, end);\n      let two = one && one.matchFragment(this.content, to);\n      if (!two || !two.validEnd)\n        return false;\n      for (let i = start; i < end; i++)\n        if (!this.type.allowsMarks(replacement.child(i).marks))\n          return false;\n      return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */\n    canReplaceWith(from4, to, type, marks2) {\n      if (marks2 && !this.type.allowsMarks(marks2))\n        return false;\n      let start = this.contentMatchAt(from4).matchType(type);\n      let end = start && start.matchFragment(this.content, to);\n      return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */\n    canAppend(other) {\n      if (other.content.size)\n        return this.canReplace(this.childCount, this.childCount, other.content);\n      else\n        return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise an exception when they do not.\n    */\n    check() {\n      this.type.checkContent(this.content);\n      this.type.checkAttrs(this.attrs);\n      let copy3 = Mark.none;\n      for (let i = 0; i < this.marks.length; i++) {\n        let mark = this.marks[i];\n        mark.type.checkAttrs(mark.attrs);\n        copy3 = mark.addToSet(copy3);\n      }\n      if (!Mark.sameSet(copy3, this.marks))\n        throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m) => m.type.name)}`);\n      this.content.forEach((node) => node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */\n    toJSON() {\n      let obj = { type: this.type.name };\n      for (let _ in this.attrs) {\n        obj.attrs = this.attrs;\n        break;\n      }\n      if (this.content.size)\n        obj.content = this.content.toJSON();\n      if (this.marks.length)\n        obj.marks = this.marks.map((n) => n.toJSON());\n      return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */\n    static fromJSON(schema2, json) {\n      if (!json)\n        throw new RangeError(\"Invalid input for Node.fromJSON\");\n      let marks2 = void 0;\n      if (json.marks) {\n        if (!Array.isArray(json.marks))\n          throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n        marks2 = json.marks.map(schema2.markFromJSON);\n      }\n      if (json.type == \"text\") {\n        if (typeof json.text != \"string\")\n          throw new RangeError(\"Invalid text node in JSON\");\n        return schema2.text(json.text, marks2);\n      }\n      let content = Fragment.fromJSON(schema2, json.content);\n      let node = schema2.nodeType(json.type).create(json.attrs, content, marks2);\n      node.type.checkAttrs(node.attrs);\n      return node;\n    }\n  };\n  Node.prototype.text = void 0;\n  var TextNode = class _TextNode extends Node {\n    /**\n    @internal\n    */\n    constructor(type, attrs, content, marks2) {\n      super(type, attrs, null, marks2);\n      if (!content)\n        throw new RangeError(\"Empty text nodes are not allowed\");\n      this.text = content;\n    }\n    toString() {\n      if (this.type.spec.toDebugString)\n        return this.type.spec.toDebugString(this);\n      return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() {\n      return this.text;\n    }\n    textBetween(from4, to) {\n      return this.text.slice(from4, to);\n    }\n    get nodeSize() {\n      return this.text.length;\n    }\n    mark(marks2) {\n      return marks2 == this.marks ? this : new _TextNode(this.type, this.attrs, this.text, marks2);\n    }\n    withText(text2) {\n      if (text2 == this.text)\n        return this;\n      return new _TextNode(this.type, this.attrs, text2, this.marks);\n    }\n    cut(from4 = 0, to = this.text.length) {\n      if (from4 == 0 && to == this.text.length)\n        return this;\n      return this.withText(this.text.slice(from4, to));\n    }\n    eq(other) {\n      return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n      let base2 = super.toJSON();\n      base2.text = this.text;\n      return base2;\n    }\n  };\n  function wrapMarks(marks2, str) {\n    for (let i = marks2.length - 1; i >= 0; i--)\n      str = marks2[i].type.name + \"(\" + str + \")\";\n    return str;\n  }\n  var ContentMatch = class _ContentMatch {\n    /**\n    @internal\n    */\n    constructor(validEnd) {\n      this.validEnd = validEnd;\n      this.next = [];\n      this.wrapCache = [];\n    }\n    /**\n    @internal\n    */\n    static parse(string, nodeTypes) {\n      let stream = new TokenStream(string, nodeTypes);\n      if (stream.next == null)\n        return _ContentMatch.empty;\n      let expr = parseExpr(stream);\n      if (stream.next)\n        stream.err(\"Unexpected trailing text\");\n      let match = dfa(nfa(expr));\n      checkForDeadEnds(match, stream);\n      return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */\n    matchType(type) {\n      for (let i = 0; i < this.next.length; i++)\n        if (this.next[i].type == type)\n          return this.next[i].next;\n      return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */\n    matchFragment(frag, start = 0, end = frag.childCount) {\n      let cur = this;\n      for (let i = start; cur && i < end; i++)\n        cur = cur.matchType(frag.child(i).type);\n      return cur;\n    }\n    /**\n    @internal\n    */\n    get inlineContent() {\n      return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */\n    get defaultType() {\n      for (let i = 0; i < this.next.length; i++) {\n        let { type } = this.next[i];\n        if (!(type.isText || type.hasRequiredAttrs()))\n          return type;\n      }\n      return null;\n    }\n    /**\n    @internal\n    */\n    compatible(other) {\n      for (let i = 0; i < this.next.length; i++)\n        for (let j = 0; j < other.next.length; j++)\n          if (this.next[i].type == other.next[j].type)\n            return true;\n      return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */\n    fillBefore(after, toEnd = false, startIndex = 0) {\n      let seen = [this];\n      function search(match, types) {\n        let finished = match.matchFragment(after, startIndex);\n        if (finished && (!toEnd || finished.validEnd))\n          return Fragment.from(types.map((tp) => tp.createAndFill()));\n        for (let i = 0; i < match.next.length; i++) {\n          let { type, next } = match.next[i];\n          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n            seen.push(next);\n            let found2 = search(next, types.concat(type));\n            if (found2)\n              return found2;\n          }\n        }\n        return null;\n      }\n      return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */\n    findWrapping(target) {\n      for (let i = 0; i < this.wrapCache.length; i += 2)\n        if (this.wrapCache[i] == target)\n          return this.wrapCache[i + 1];\n      let computed = this.computeWrapping(target);\n      this.wrapCache.push(target, computed);\n      return computed;\n    }\n    /**\n    @internal\n    */\n    computeWrapping(target) {\n      let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];\n      while (active.length) {\n        let current = active.shift(), match = current.match;\n        if (match.matchType(target)) {\n          let result = [];\n          for (let obj = current; obj.type; obj = obj.via)\n            result.push(obj.type);\n          return result.reverse();\n        }\n        for (let i = 0; i < match.next.length; i++) {\n          let { type, next } = match.next[i];\n          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n            active.push({ match: type.contentMatch, type, via: current });\n            seen[type.name] = true;\n          }\n        }\n      }\n      return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */\n    get edgeCount() {\n      return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */\n    edge(n) {\n      if (n >= this.next.length)\n        throw new RangeError(`There's no ${n}th edge in this content match`);\n      return this.next[n];\n    }\n    /**\n    @internal\n    */\n    toString() {\n      let seen = [];\n      function scan(m) {\n        seen.push(m);\n        for (let i = 0; i < m.next.length; i++)\n          if (seen.indexOf(m.next[i].next) == -1)\n            scan(m.next[i].next);\n      }\n      scan(this);\n      return seen.map((m, i) => {\n        let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n        for (let i2 = 0; i2 < m.next.length; i2++)\n          out += (i2 ? \", \" : \"\") + m.next[i2].type.name + \"->\" + seen.indexOf(m.next[i2].next);\n        return out;\n      }).join(\"\\n\");\n    }\n  };\n  ContentMatch.empty = new ContentMatch(true);\n  var TokenStream = class {\n    constructor(string, nodeTypes) {\n      this.string = string;\n      this.nodeTypes = nodeTypes;\n      this.inline = null;\n      this.pos = 0;\n      this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n      if (this.tokens[this.tokens.length - 1] == \"\")\n        this.tokens.pop();\n      if (this.tokens[0] == \"\")\n        this.tokens.shift();\n    }\n    get next() {\n      return this.tokens[this.pos];\n    }\n    eat(tok) {\n      return this.next == tok && (this.pos++ || true);\n    }\n    err(str) {\n      throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n  };\n  function parseExpr(stream) {\n    let exprs = [];\n    do {\n      exprs.push(parseExprSeq(stream));\n    } while (stream.eat(\"|\"));\n    return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n  }\n  function parseExprSeq(stream) {\n    let exprs = [];\n    do {\n      exprs.push(parseExprSubscript(stream));\n    } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n    return exprs.length == 1 ? exprs[0] : { type: \"seq\", exprs };\n  }\n  function parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for (; ; ) {\n      if (stream.eat(\"+\"))\n        expr = { type: \"plus\", expr };\n      else if (stream.eat(\"*\"))\n        expr = { type: \"star\", expr };\n      else if (stream.eat(\"?\"))\n        expr = { type: \"opt\", expr };\n      else if (stream.eat(\"{\"))\n        expr = parseExprRange(stream, expr);\n      else\n        break;\n    }\n    return expr;\n  }\n  function parseNum(stream) {\n    if (/\\D/.test(stream.next))\n      stream.err(\"Expected number, got '\" + stream.next + \"'\");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n  }\n  function parseExprRange(stream, expr) {\n    let min4 = parseNum(stream), max4 = min4;\n    if (stream.eat(\",\")) {\n      if (stream.next != \"}\")\n        max4 = parseNum(stream);\n      else\n        max4 = -1;\n    }\n    if (!stream.eat(\"}\"))\n      stream.err(\"Unclosed braced range\");\n    return { type: \"range\", min: min4, max: max4, expr };\n  }\n  function resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type)\n      return [type];\n    let result = [];\n    for (let typeName in types) {\n      let type2 = types[typeName];\n      if (type2.isInGroup(name))\n        result.push(type2);\n    }\n    if (result.length == 0)\n      stream.err(\"No node type or group '\" + name + \"' found\");\n    return result;\n  }\n  function parseExprAtom(stream) {\n    if (stream.eat(\"(\")) {\n      let expr = parseExpr(stream);\n      if (!stream.eat(\")\"))\n        stream.err(\"Missing closing paren\");\n      return expr;\n    } else if (!/\\W/.test(stream.next)) {\n      let exprs = resolveName(stream, stream.next).map((type) => {\n        if (stream.inline == null)\n          stream.inline = type.isInline;\n        else if (stream.inline != type.isInline)\n          stream.err(\"Mixing inline and block content\");\n        return { type: \"name\", value: type };\n      });\n      stream.pos++;\n      return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n    } else {\n      stream.err(\"Unexpected token '\" + stream.next + \"'\");\n    }\n  }\n  function nfa(expr) {\n    let nfa2 = [[]];\n    connect(compile(expr, 0), node());\n    return nfa2;\n    function node() {\n      return nfa2.push([]) - 1;\n    }\n    function edge(from4, to, term) {\n      let edge2 = { term, to };\n      nfa2[from4].push(edge2);\n      return edge2;\n    }\n    function connect(edges, to) {\n      edges.forEach((edge2) => edge2.to = to);\n    }\n    function compile(expr2, from4) {\n      if (expr2.type == \"choice\") {\n        return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from4)), []);\n      } else if (expr2.type == \"seq\") {\n        for (let i = 0; ; i++) {\n          let next = compile(expr2.exprs[i], from4);\n          if (i == expr2.exprs.length - 1)\n            return next;\n          connect(next, from4 = node());\n        }\n      } else if (expr2.type == \"star\") {\n        let loop = node();\n        edge(from4, loop);\n        connect(compile(expr2.expr, loop), loop);\n        return [edge(loop)];\n      } else if (expr2.type == \"plus\") {\n        let loop = node();\n        connect(compile(expr2.expr, from4), loop);\n        connect(compile(expr2.expr, loop), loop);\n        return [edge(loop)];\n      } else if (expr2.type == \"opt\") {\n        return [edge(from4)].concat(compile(expr2.expr, from4));\n      } else if (expr2.type == \"range\") {\n        let cur = from4;\n        for (let i = 0; i < expr2.min; i++) {\n          let next = node();\n          connect(compile(expr2.expr, cur), next);\n          cur = next;\n        }\n        if (expr2.max == -1) {\n          connect(compile(expr2.expr, cur), cur);\n        } else {\n          for (let i = expr2.min; i < expr2.max; i++) {\n            let next = node();\n            edge(cur, next);\n            connect(compile(expr2.expr, cur), next);\n            cur = next;\n          }\n        }\n        return [edge(cur)];\n      } else if (expr2.type == \"name\") {\n        return [edge(from4, void 0, expr2.value)];\n      } else {\n        throw new Error(\"Unknown expr type\");\n      }\n    }\n  }\n  function cmp(a, b) {\n    return b - a;\n  }\n  function nullFrom(nfa2, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node2) {\n      let edges = nfa2[node2];\n      if (edges.length == 1 && !edges[0].term)\n        return scan(edges[0].to);\n      result.push(node2);\n      for (let i = 0; i < edges.length; i++) {\n        let { term, to } = edges[i];\n        if (!term && result.indexOf(to) == -1)\n          scan(to);\n      }\n    }\n  }\n  function dfa(nfa2) {\n    let labeled = /* @__PURE__ */ Object.create(null);\n    return explore(nullFrom(nfa2, 0));\n    function explore(states) {\n      let out = [];\n      states.forEach((node) => {\n        nfa2[node].forEach(({ term, to }) => {\n          if (!term)\n            return;\n          let set;\n          for (let i = 0; i < out.length; i++)\n            if (out[i][0] == term)\n              set = out[i][1];\n          nullFrom(nfa2, to).forEach((node2) => {\n            if (!set)\n              out.push([term, set = []]);\n            if (set.indexOf(node2) == -1)\n              set.push(node2);\n          });\n        });\n      });\n      let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);\n      for (let i = 0; i < out.length; i++) {\n        let states2 = out[i][1].sort(cmp);\n        state.next.push({ type: out[i][0], next: labeled[states2.join(\",\")] || explore(states2) });\n      }\n      return state;\n    }\n  }\n  function checkForDeadEnds(match, stream) {\n    for (let i = 0, work = [match]; i < work.length; i++) {\n      let state = work[i], dead = !state.validEnd, nodes2 = [];\n      for (let j = 0; j < state.next.length; j++) {\n        let { type, next } = state.next[j];\n        nodes2.push(type.name);\n        if (dead && !(type.isText || type.hasRequiredAttrs()))\n          dead = false;\n        if (work.indexOf(next) == -1)\n          work.push(next);\n      }\n      if (dead)\n        stream.err(\"Only non-generatable nodes (\" + nodes2.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n  }\n  function defaultAttrs(attrs) {\n    let defaults = /* @__PURE__ */ Object.create(null);\n    for (let attrName in attrs) {\n      let attr = attrs[attrName];\n      if (!attr.hasDefault)\n        return null;\n      defaults[attrName] = attr.default;\n    }\n    return defaults;\n  }\n  function computeAttrs(attrs, value) {\n    let built = /* @__PURE__ */ Object.create(null);\n    for (let name in attrs) {\n      let given = value && value[name];\n      if (given === void 0) {\n        let attr = attrs[name];\n        if (attr.hasDefault)\n          given = attr.default;\n        else\n          throw new RangeError(\"No value supplied for attribute \" + name);\n      }\n      built[name] = given;\n    }\n    return built;\n  }\n  function checkAttrs(attrs, values, type, name) {\n    for (let name2 in values)\n      if (!(name2 in attrs))\n        throw new RangeError(`Unsupported attribute ${name2} for ${type} of type ${name2}`);\n    for (let name2 in attrs) {\n      let attr = attrs[name2];\n      if (attr.validate)\n        attr.validate(values[name2]);\n    }\n  }\n  function initAttrs(typeName, attrs) {\n    let result = /* @__PURE__ */ Object.create(null);\n    if (attrs)\n      for (let name in attrs)\n        result[name] = new Attribute(typeName, name, attrs[name]);\n    return result;\n  }\n  var NodeType = class _NodeType {\n    /**\n    @internal\n    */\n    constructor(name, schema2, spec) {\n      this.name = name;\n      this.schema = schema2;\n      this.spec = spec;\n      this.markSet = null;\n      this.groups = spec.group ? spec.group.split(\" \") : [];\n      this.attrs = initAttrs(name, spec.attrs);\n      this.defaultAttrs = defaultAttrs(this.attrs);\n      this.contentMatch = null;\n      this.inlineContent = null;\n      this.isBlock = !(spec.inline || name == \"text\");\n      this.isText = name == \"text\";\n    }\n    /**\n    True if this is an inline type.\n    */\n    get isInline() {\n      return !this.isBlock;\n    }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */\n    get isTextblock() {\n      return this.isBlock && this.inlineContent;\n    }\n    /**\n    True for node types that allow no content.\n    */\n    get isLeaf() {\n      return this.contentMatch == ContentMatch.empty;\n    }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */\n    get isAtom() {\n      return this.isLeaf || !!this.spec.atom;\n    }\n    /**\n    Return true when this node type is part of the given\n    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).\n    */\n    isInGroup(group) {\n      return this.groups.indexOf(group) > -1;\n    }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */\n    get whitespace() {\n      return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */\n    hasRequiredAttrs() {\n      for (let n in this.attrs)\n        if (this.attrs[n].isRequired)\n          return true;\n      return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */\n    compatibleContent(other) {\n      return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */\n    computeAttrs(attrs) {\n      if (!attrs && this.defaultAttrs)\n        return this.defaultAttrs;\n      else\n        return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */\n    create(attrs = null, content, marks2) {\n      if (this.isText)\n        throw new Error(\"NodeType.create can't construct text nodes\");\n      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks2));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */\n    createChecked(attrs = null, content, marks2) {\n      content = Fragment.from(content);\n      this.checkContent(content);\n      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks2));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */\n    createAndFill(attrs = null, content, marks2) {\n      attrs = this.computeAttrs(attrs);\n      content = Fragment.from(content);\n      if (content.size) {\n        let before = this.contentMatch.fillBefore(content);\n        if (!before)\n          return null;\n        content = before.append(content);\n      }\n      let matched = this.contentMatch.matchFragment(content);\n      let after = matched && matched.fillBefore(Fragment.empty, true);\n      if (!after)\n        return null;\n      return new Node(this, attrs, content.append(after), Mark.setFrom(marks2));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type.\n    */\n    validContent(content) {\n      let result = this.contentMatch.matchFragment(content);\n      if (!result || !result.validEnd)\n        return false;\n      for (let i = 0; i < content.childCount; i++)\n        if (!this.allowsMarks(content.child(i).marks))\n          return false;\n      return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */\n    checkContent(content) {\n      if (!this.validContent(content))\n        throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    @internal\n    */\n    checkAttrs(attrs) {\n      checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */\n    allowsMarkType(markType) {\n      return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */\n    allowsMarks(marks2) {\n      if (this.markSet == null)\n        return true;\n      for (let i = 0; i < marks2.length; i++)\n        if (!this.allowsMarkType(marks2[i].type))\n          return false;\n      return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */\n    allowedMarks(marks2) {\n      if (this.markSet == null)\n        return marks2;\n      let copy3;\n      for (let i = 0; i < marks2.length; i++) {\n        if (!this.allowsMarkType(marks2[i].type)) {\n          if (!copy3)\n            copy3 = marks2.slice(0, i);\n        } else if (copy3) {\n          copy3.push(marks2[i]);\n        }\n      }\n      return !copy3 ? marks2 : copy3.length ? copy3 : Mark.none;\n    }\n    /**\n    @internal\n    */\n    static compile(nodes2, schema2) {\n      let result = /* @__PURE__ */ Object.create(null);\n      nodes2.forEach((name, spec) => result[name] = new _NodeType(name, schema2, spec));\n      let topType = schema2.spec.topNode || \"doc\";\n      if (!result[topType])\n        throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n      if (!result.text)\n        throw new RangeError(\"Every schema needs a 'text' type\");\n      for (let _ in result.text.attrs)\n        throw new RangeError(\"The text node type should not have attributes\");\n      return result;\n    }\n  };\n  function validateType(typeName, attrName, type) {\n    let types = type.split(\"|\");\n    return (value) => {\n      let name = value === null ? \"null\" : typeof value;\n      if (types.indexOf(name) < 0)\n        throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);\n    };\n  }\n  var Attribute = class {\n    constructor(typeName, attrName, options) {\n      this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n      this.default = options.default;\n      this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n    }\n    get isRequired() {\n      return !this.hasDefault;\n    }\n  };\n  var MarkType = class _MarkType {\n    /**\n    @internal\n    */\n    constructor(name, rank, schema2, spec) {\n      this.name = name;\n      this.rank = rank;\n      this.schema = schema2;\n      this.spec = spec;\n      this.attrs = initAttrs(name, spec.attrs);\n      this.excluded = null;\n      let defaults = defaultAttrs(this.attrs);\n      this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark's attributes. The others, if\n    they have defaults, will be added.\n    */\n    create(attrs = null) {\n      if (!attrs && this.instance)\n        return this.instance;\n      return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */\n    static compile(marks2, schema2) {\n      let result = /* @__PURE__ */ Object.create(null), rank = 0;\n      marks2.forEach((name, spec) => result[name] = new _MarkType(name, rank++, schema2, spec));\n      return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */\n    removeFromSet(set) {\n      for (var i = 0; i < set.length; i++)\n        if (set[i].type == this) {\n          set = set.slice(0, i).concat(set.slice(i + 1));\n          i--;\n        }\n      return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */\n    isInSet(set) {\n      for (let i = 0; i < set.length; i++)\n        if (set[i].type == this)\n          return set[i];\n    }\n    /**\n    @internal\n    */\n    checkAttrs(attrs) {\n      checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */\n    excludes(other) {\n      return this.excluded.indexOf(other) > -1;\n    }\n  };\n  var Schema = class {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */\n    constructor(spec) {\n      this.linebreakReplacement = null;\n      this.cached = /* @__PURE__ */ Object.create(null);\n      let instanceSpec = this.spec = {};\n      for (let prop in spec)\n        instanceSpec[prop] = spec[prop];\n      instanceSpec.nodes = dist_default.from(spec.nodes), instanceSpec.marks = dist_default.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n      this.marks = MarkType.compile(this.spec.marks, this);\n      let contentExprCache = /* @__PURE__ */ Object.create(null);\n      for (let prop in this.nodes) {\n        if (prop in this.marks)\n          throw new RangeError(prop + \" can not be both a node and a mark\");\n        let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n        type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n        type.inlineContent = type.contentMatch.inlineContent;\n        if (type.spec.linebreakReplacement) {\n          if (this.linebreakReplacement)\n            throw new RangeError(\"Multiple linebreak nodes defined\");\n          if (!type.isInline || !type.isLeaf)\n            throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n          this.linebreakReplacement = type;\n        }\n        type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n      }\n      for (let prop in this.marks) {\n        let type = this.marks[prop], excl = type.spec.excludes;\n        type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n      }\n      this.nodeFromJSON = (json) => Node.fromJSON(this, json);\n      this.markFromJSON = (json) => Mark.fromJSON(this, json);\n      this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n      this.cached.wrappings = /* @__PURE__ */ Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */\n    node(type, attrs = null, content, marks2) {\n      if (typeof type == \"string\")\n        type = this.nodeType(type);\n      else if (!(type instanceof NodeType))\n        throw new RangeError(\"Invalid node type: \" + type);\n      else if (type.schema != this)\n        throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n      return type.createChecked(attrs, content, marks2);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */\n    text(text2, marks2) {\n      let type = this.nodes.text;\n      return new TextNode(type, type.defaultAttrs, text2, Mark.setFrom(marks2));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */\n    mark(type, attrs) {\n      if (typeof type == \"string\")\n        type = this.marks[type];\n      return type.create(attrs);\n    }\n    /**\n    @internal\n    */\n    nodeType(name) {\n      let found2 = this.nodes[name];\n      if (!found2)\n        throw new RangeError(\"Unknown node type: \" + name);\n      return found2;\n    }\n  };\n  function gatherMarks(schema2, marks2) {\n    let found2 = [];\n    for (let i = 0; i < marks2.length; i++) {\n      let name = marks2[i], mark = schema2.marks[name], ok = mark;\n      if (mark) {\n        found2.push(mark);\n      } else {\n        for (let prop in schema2.marks) {\n          let mark2 = schema2.marks[prop];\n          if (name == \"_\" || mark2.spec.group && mark2.spec.group.split(\" \").indexOf(name) > -1)\n            found2.push(ok = mark2);\n        }\n      }\n      if (!ok)\n        throw new SyntaxError(\"Unknown mark type: '\" + marks2[i] + \"'\");\n    }\n    return found2;\n  }\n  function isTagRule(rule) {\n    return rule.tag != null;\n  }\n  function isStyleRule(rule) {\n    return rule.style != null;\n  }\n  var DOMParser2 = class _DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */\n    constructor(schema2, rules) {\n      this.schema = schema2;\n      this.rules = rules;\n      this.tags = [];\n      this.styles = [];\n      let matchedStyles = this.matchedStyles = [];\n      rules.forEach((rule) => {\n        if (isTagRule(rule)) {\n          this.tags.push(rule);\n        } else if (isStyleRule(rule)) {\n          let prop = /[^=]*/.exec(rule.style)[0];\n          if (matchedStyles.indexOf(prop) < 0)\n            matchedStyles.push(prop);\n          this.styles.push(rule);\n        }\n      });\n      this.normalizeLists = !this.tags.some((r) => {\n        if (!/^(ul|ol)\\b/.test(r.tag) || !r.node)\n          return false;\n        let node = schema2.nodes[r.node];\n        return node.contentMatch.matchType(node);\n      });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */\n    parse(dom, options = {}) {\n      let context = new ParseContext(this, options, false);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */\n    parseSlice(dom, options = {}) {\n      let context = new ParseContext(this, options, true);\n      context.addAll(dom, Mark.none, options.from, options.to);\n      return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */\n    matchTag(dom, context, after) {\n      for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n        let rule = this.tags[i];\n        if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n          if (rule.getAttrs) {\n            let result = rule.getAttrs(dom);\n            if (result === false)\n              continue;\n            rule.attrs = result || void 0;\n          }\n          return rule;\n        }\n      }\n    }\n    /**\n    @internal\n    */\n    matchStyle(prop, value, context, after) {\n      for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n        let rule = this.styles[i], style = rule.style;\n        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,\n        // or has an '=' sign after the prop, followed by the given\n        // value.\n        style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))\n          continue;\n        if (rule.getAttrs) {\n          let result = rule.getAttrs(value);\n          if (result === false)\n            continue;\n          rule.attrs = result || void 0;\n        }\n        return rule;\n      }\n    }\n    /**\n    @internal\n    */\n    static schemaRules(schema2) {\n      let result = [];\n      function insert(rule) {\n        let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n        for (; i < result.length; i++) {\n          let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n          if (nextPriority < priority)\n            break;\n        }\n        result.splice(i, 0, rule);\n      }\n      for (let name in schema2.marks) {\n        let rules = schema2.marks[name].spec.parseDOM;\n        if (rules)\n          rules.forEach((rule) => {\n            insert(rule = copy(rule));\n            if (!(rule.mark || rule.ignore || rule.clearMark))\n              rule.mark = name;\n          });\n      }\n      for (let name in schema2.nodes) {\n        let rules = schema2.nodes[name].spec.parseDOM;\n        if (rules)\n          rules.forEach((rule) => {\n            insert(rule = copy(rule));\n            if (!(rule.node || rule.ignore || rule.mark))\n              rule.node = name;\n          });\n      }\n      return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).\n    */\n    static fromSchema(schema2) {\n      return schema2.cached.domParser || (schema2.cached.domParser = new _DOMParser(schema2, _DOMParser.schemaRules(schema2)));\n    }\n  };\n  var blockTags = {\n    address: true,\n    article: true,\n    aside: true,\n    blockquote: true,\n    canvas: true,\n    dd: true,\n    div: true,\n    dl: true,\n    fieldset: true,\n    figcaption: true,\n    figure: true,\n    footer: true,\n    form: true,\n    h1: true,\n    h2: true,\n    h3: true,\n    h4: true,\n    h5: true,\n    h6: true,\n    header: true,\n    hgroup: true,\n    hr: true,\n    li: true,\n    noscript: true,\n    ol: true,\n    output: true,\n    p: true,\n    pre: true,\n    section: true,\n    table: true,\n    tfoot: true,\n    ul: true\n  };\n  var ignoreTags = {\n    head: true,\n    noscript: true,\n    object: true,\n    script: true,\n    style: true,\n    title: true\n  };\n  var listTags = { ol: true, ul: true };\n  var OPT_PRESERVE_WS = 1;\n  var OPT_PRESERVE_WS_FULL = 2;\n  var OPT_OPEN_LEFT = 4;\n  function wsOptionsFor(type, preserveWhitespace, base2) {\n    if (preserveWhitespace != null)\n      return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;\n  }\n  var NodeContext = class {\n    constructor(type, attrs, marks2, solid, match, options) {\n      this.type = type;\n      this.attrs = attrs;\n      this.marks = marks2;\n      this.solid = solid;\n      this.options = options;\n      this.content = [];\n      this.activeMarks = Mark.none;\n      this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n      if (!this.match) {\n        if (!this.type)\n          return [];\n        let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n        if (fill) {\n          this.match = this.type.contentMatch.matchFragment(fill);\n        } else {\n          let start = this.type.contentMatch, wrap2;\n          if (wrap2 = start.findWrapping(node.type)) {\n            this.match = start;\n            return wrap2;\n          } else {\n            return null;\n          }\n        }\n      }\n      return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n      if (!(this.options & OPT_PRESERVE_WS)) {\n        let last2 = this.content[this.content.length - 1], m;\n        if (last2 && last2.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last2.text))) {\n          let text2 = last2;\n          if (last2.text.length == m[0].length)\n            this.content.pop();\n          else\n            this.content[this.content.length - 1] = text2.withText(text2.text.slice(0, text2.text.length - m[0].length));\n        }\n      }\n      let content = Fragment.from(this.content);\n      if (!openEnd && this.match)\n        content = content.append(this.match.fillBefore(Fragment.empty, true));\n      return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    inlineContext(node) {\n      if (this.type)\n        return this.type.inlineContent;\n      if (this.content.length)\n        return this.content[0].isInline;\n      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n  };\n  var ParseContext = class {\n    constructor(parser, options, isOpen) {\n      this.parser = parser;\n      this.options = options;\n      this.isOpen = isOpen;\n      this.open = 0;\n      this.localPreserveWS = false;\n      let topNode = options.topNode, topContext;\n      let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n      if (topNode)\n        topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n      else if (isOpen)\n        topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);\n      else\n        topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n      this.nodes = [topContext];\n      this.find = options.findPositions;\n      this.needsBlock = false;\n    }\n    get top() {\n      return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom, marks2) {\n      if (dom.nodeType == 3)\n        this.addTextNode(dom, marks2);\n      else if (dom.nodeType == 1)\n        this.addElement(dom, marks2);\n    }\n    addTextNode(dom, marks2) {\n      let value = dom.nodeValue;\n      let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n      if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n        if (!preserveWS) {\n          value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n          if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n            let nodeBefore = top.content[top.content.length - 1];\n            let domNodeBefore = dom.previousSibling;\n            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == \"BR\" || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text))\n              value = value.slice(1);\n          }\n        } else if (preserveWS !== \"full\") {\n          value = value.replace(/\\r?\\n|\\r/g, \" \");\n        } else {\n          value = value.replace(/\\r\\n?/g, \"\\n\");\n        }\n        if (value)\n          this.insertNode(this.parser.schema.text(value), marks2, !/\\S/.test(value));\n        this.findInText(dom);\n      } else {\n        this.findInside(dom);\n      }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n    addElement(dom, marks2, matchAfter) {\n      let outerWS = this.localPreserveWS, top = this.top;\n      if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace))\n        this.localPreserveWS = true;\n      let name = dom.nodeName.toLowerCase(), ruleID;\n      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)\n        normalizeList(dom);\n      let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n      out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n        this.findInside(dom);\n        this.ignoreFallback(dom, marks2);\n      } else if (!rule || rule.skip || rule.closeParent) {\n        if (rule && rule.closeParent)\n          this.open = Math.max(0, this.open - 1);\n        else if (rule && rule.skip.nodeType)\n          dom = rule.skip;\n        let sync, oldNeedsBlock = this.needsBlock;\n        if (blockTags.hasOwnProperty(name)) {\n          if (top.content.length && top.content[0].isInline && this.open) {\n            this.open--;\n            top = this.top;\n          }\n          sync = true;\n          if (!top.type)\n            this.needsBlock = true;\n        } else if (!dom.firstChild) {\n          this.leafFallback(dom, marks2);\n          break out;\n        }\n        let innerMarks = rule && rule.skip ? marks2 : this.readStyles(dom, marks2);\n        if (innerMarks)\n          this.addAll(dom, innerMarks);\n        if (sync)\n          this.sync(top);\n        this.needsBlock = oldNeedsBlock;\n      } else {\n        let innerMarks = this.readStyles(dom, marks2);\n        if (innerMarks)\n          this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);\n      }\n      this.localPreserveWS = outerWS;\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom, marks2) {\n      if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n        this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks2);\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom, marks2) {\n      if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n        this.findPlace(this.parser.schema.text(\"-\"), marks2, true);\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an updated array of marks, or null to indicate some of the\n    // styles had a rule with `ignore` set.\n    readStyles(dom, marks2) {\n      let styles = dom.style;\n      if (styles && styles.length)\n        for (let i = 0; i < this.parser.matchedStyles.length; i++) {\n          let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);\n          if (value)\n            for (let after = void 0; ; ) {\n              let rule = this.parser.matchStyle(name, value, this, after);\n              if (!rule)\n                break;\n              if (rule.ignore)\n                return null;\n              if (rule.clearMark)\n                marks2 = marks2.filter((m) => !rule.clearMark(m));\n              else\n                marks2 = marks2.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));\n              if (rule.consuming === false)\n                after = rule;\n              else\n                break;\n            }\n        }\n      return marks2;\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n    addElementByRule(dom, rule, marks2, continueAfter) {\n      let sync, nodeType;\n      if (rule.node) {\n        nodeType = this.parser.schema.nodes[rule.node];\n        if (!nodeType.isLeaf) {\n          let inner = this.enter(nodeType, rule.attrs || null, marks2, rule.preserveWhitespace);\n          if (inner) {\n            sync = true;\n            marks2 = inner;\n          }\n        } else if (!this.insertNode(nodeType.create(rule.attrs), marks2, dom.nodeName == \"BR\")) {\n          this.leafFallback(dom, marks2);\n        }\n      } else {\n        let markType = this.parser.schema.marks[rule.mark];\n        marks2 = marks2.concat(markType.create(rule.attrs));\n      }\n      let startIn = this.top;\n      if (nodeType && nodeType.isLeaf) {\n        this.findInside(dom);\n      } else if (continueAfter) {\n        this.addElement(dom, marks2, continueAfter);\n      } else if (rule.getContent) {\n        this.findInside(dom);\n        rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks2, false));\n      } else {\n        let contentDOM = dom;\n        if (typeof rule.contentElement == \"string\")\n          contentDOM = dom.querySelector(rule.contentElement);\n        else if (typeof rule.contentElement == \"function\")\n          contentDOM = rule.contentElement(dom);\n        else if (rule.contentElement)\n          contentDOM = rule.contentElement;\n        this.findAround(dom, contentDOM, true);\n        this.addAll(contentDOM, marks2);\n        this.findAround(dom, contentDOM, false);\n      }\n      if (sync && this.sync(startIn))\n        this.open--;\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, marks2, startIndex, endIndex) {\n      let index = startIndex || 0;\n      for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n        this.findAtPoint(parent, index);\n        this.addDOM(dom, marks2);\n      }\n      this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n    findPlace(node, marks2, cautious) {\n      let route, sync;\n      for (let depth = this.open, penalty = 0; depth >= 0; depth--) {\n        let cx = this.nodes[depth];\n        let found2 = cx.findWrapping(node);\n        if (found2 && (!route || route.length > found2.length + penalty)) {\n          route = found2;\n          sync = cx;\n          if (!found2.length)\n            break;\n        }\n        if (cx.solid) {\n          if (cautious)\n            break;\n          penalty += 2;\n        }\n      }\n      if (!route)\n        return null;\n      this.sync(sync);\n      for (let i = 0; i < route.length; i++)\n        marks2 = this.enterInner(route[i], null, marks2, false);\n      return marks2;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node, marks2, cautious) {\n      if (node.isInline && this.needsBlock && !this.top.type) {\n        let block = this.textblockFromContext();\n        if (block)\n          marks2 = this.enterInner(block, null, marks2);\n      }\n      let innerMarks = this.findPlace(node, marks2, cautious);\n      if (innerMarks) {\n        this.closeExtra();\n        let top = this.top;\n        if (top.match)\n          top.match = top.match.matchType(node.type);\n        let nodeMarks = Mark.none;\n        for (let m of innerMarks.concat(node.marks))\n          if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))\n            nodeMarks = m.addToSet(nodeMarks);\n        top.content.push(node.mark(nodeMarks));\n        return true;\n      }\n      return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, marks2, preserveWS) {\n      let innerMarks = this.findPlace(type.create(attrs), marks2, false);\n      if (innerMarks)\n        innerMarks = this.enterInner(type, attrs, marks2, true, preserveWS);\n      return innerMarks;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs, marks2, solid = false, preserveWS) {\n      this.closeExtra();\n      let top = this.top;\n      top.match = top.match && top.match.matchType(type);\n      let options = wsOptionsFor(type, preserveWS, top.options);\n      if (top.options & OPT_OPEN_LEFT && top.content.length == 0)\n        options |= OPT_OPEN_LEFT;\n      let applyMarks = Mark.none;\n      marks2 = marks2.filter((m) => {\n        if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n          applyMarks = m.addToSet(applyMarks);\n          return false;\n        }\n        return true;\n      });\n      this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n      this.open++;\n      return marks2;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n      let i = this.nodes.length - 1;\n      if (i > this.open) {\n        for (; i > this.open; i--)\n          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n        this.nodes.length = this.open + 1;\n      }\n    }\n    finish() {\n      this.open = 0;\n      this.closeExtra(this.isOpen);\n      return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n    sync(to) {\n      for (let i = this.open; i >= 0; i--) {\n        if (this.nodes[i] == to) {\n          this.open = i;\n          return true;\n        } else if (this.localPreserveWS) {\n          this.nodes[i].options |= OPT_PRESERVE_WS;\n        }\n      }\n      return false;\n    }\n    get currentPos() {\n      this.closeExtra();\n      let pos = 0;\n      for (let i = this.open; i >= 0; i--) {\n        let content = this.nodes[i].content;\n        for (let j = content.length - 1; j >= 0; j--)\n          pos += content[j].nodeSize;\n        if (i)\n          pos++;\n      }\n      return pos;\n    }\n    findAtPoint(parent, offset) {\n      if (this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].node == parent && this.find[i].offset == offset)\n            this.find[i].pos = this.currentPos;\n        }\n    }\n    findInside(parent) {\n      if (this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n            this.find[i].pos = this.currentPos;\n        }\n    }\n    findAround(parent, content, before) {\n      if (parent != content && this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n            let pos = content.compareDocumentPosition(this.find[i].node);\n            if (pos & (before ? 2 : 4))\n              this.find[i].pos = this.currentPos;\n          }\n        }\n    }\n    findInText(textNode) {\n      if (this.find)\n        for (let i = 0; i < this.find.length; i++) {\n          if (this.find[i].node == textNode)\n            this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n        }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n      if (context.indexOf(\"|\") > -1)\n        return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n      let parts = context.split(\"/\");\n      let option = this.options.context;\n      let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n      let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n      let match = (i, depth) => {\n        for (; i >= 0; i--) {\n          let part = parts[i];\n          if (part == \"\") {\n            if (i == parts.length - 1 || i == 0)\n              continue;\n            for (; depth >= minDepth; depth--)\n              if (match(i - 1, depth))\n                return true;\n            return false;\n          } else {\n            let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n            if (!next || next.name != part && !next.isInGroup(part))\n              return false;\n            depth--;\n          }\n        }\n        return true;\n      };\n      return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n      let $context = this.options.context;\n      if ($context)\n        for (let d = $context.depth; d >= 0; d--) {\n          let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n          if (deflt && deflt.isTextblock && deflt.defaultAttrs)\n            return deflt;\n        }\n      for (let name in this.parser.schema.nodes) {\n        let type = this.parser.schema.nodes[name];\n        if (type.isTextblock && type.defaultAttrs)\n          return type;\n      }\n    }\n  };\n  function normalizeList(dom) {\n    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n      let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n      if (name && listTags.hasOwnProperty(name) && prevItem) {\n        prevItem.appendChild(child);\n        child = prevItem;\n      } else if (name == \"li\") {\n        prevItem = child;\n      } else if (name) {\n        prevItem = null;\n      }\n    }\n  }\n  function matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n  }\n  function copy(obj) {\n    let copy3 = {};\n    for (let prop in obj)\n      copy3[prop] = obj[prop];\n    return copy3;\n  }\n  function markMayApply(markType, nodeType) {\n    let nodes2 = nodeType.schema.nodes;\n    for (let name in nodes2) {\n      let parent = nodes2[name];\n      if (!parent.allowsMarkType(markType))\n        continue;\n      let seen = [], scan = (match) => {\n        seen.push(match);\n        for (let i = 0; i < match.edgeCount; i++) {\n          let { type, next } = match.edge(i);\n          if (type == nodeType)\n            return true;\n          if (seen.indexOf(next) < 0 && scan(next))\n            return true;\n        }\n      };\n      if (scan(parent.contentMatch))\n        return true;\n    }\n  }\n  var DOMSerializer = class _DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark's content is block or\n    inline content (for typical use, it'll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */\n    constructor(nodes2, marks2) {\n      this.nodes = nodes2;\n      this.marks = marks2;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */\n    serializeFragment(fragment, options = {}, target) {\n      if (!target)\n        target = doc(options).createDocumentFragment();\n      let top = target, active = [];\n      fragment.forEach((node) => {\n        if (active.length || node.marks.length) {\n          let keep = 0, rendered = 0;\n          while (keep < active.length && rendered < node.marks.length) {\n            let next = node.marks[rendered];\n            if (!this.marks[next.type.name]) {\n              rendered++;\n              continue;\n            }\n            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)\n              break;\n            keep++;\n            rendered++;\n          }\n          while (keep < active.length)\n            top = active.pop()[1];\n          while (rendered < node.marks.length) {\n            let add2 = node.marks[rendered++];\n            let markDOM = this.serializeMark(add2, node.isInline, options);\n            if (markDOM) {\n              active.push([add2, top]);\n              top.appendChild(markDOM.dom);\n              top = markDOM.contentDOM || markDOM.dom;\n            }\n          }\n        }\n        top.appendChild(this.serializeNodeInner(node, options));\n      });\n      return target;\n    }\n    /**\n    @internal\n    */\n    serializeNodeInner(node, options) {\n      let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);\n      if (contentDOM) {\n        if (node.isLeaf)\n          throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n        this.serializeFragment(node.content, options, contentDOM);\n      }\n      return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */\n    serializeNode(node, options = {}) {\n      let dom = this.serializeNodeInner(node, options);\n      for (let i = node.marks.length - 1; i >= 0; i--) {\n        let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);\n        if (wrap2) {\n          (wrap2.contentDOM || wrap2.dom).appendChild(dom);\n          dom = wrap2.dom;\n        }\n      }\n      return dom;\n    }\n    /**\n    @internal\n    */\n    serializeMark(mark, inline, options = {}) {\n      let toDOM = this.marks[mark.type.name];\n      return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n    static renderSpec(doc4, structure, xmlNS = null, blockArraysIn) {\n      return renderSpec(doc4, structure, xmlNS, blockArraysIn);\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */\n    static fromSchema(schema2) {\n      return schema2.cached.domSerializer || (schema2.cached.domSerializer = new _DOMSerializer(this.nodesFromSchema(schema2), this.marksFromSchema(schema2)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */\n    static nodesFromSchema(schema2) {\n      let result = gatherToDOM(schema2.nodes);\n      if (!result.text)\n        result.text = (node) => node.text;\n      return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */\n    static marksFromSchema(schema2) {\n      return gatherToDOM(schema2.marks);\n    }\n  };\n  function gatherToDOM(obj) {\n    let result = {};\n    for (let name in obj) {\n      let toDOM = obj[name].spec.toDOM;\n      if (toDOM)\n        result[name] = toDOM;\n    }\n    return result;\n  }\n  function doc(options) {\n    return options.document || window.document;\n  }\n  var suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();\n  function suspiciousAttributes(attrs) {\n    let value = suspiciousAttributeCache.get(attrs);\n    if (value === void 0)\n      suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n    return value;\n  }\n  function suspiciousAttributesInner(attrs) {\n    let result = null;\n    function scan(value) {\n      if (value && typeof value == \"object\") {\n        if (Array.isArray(value)) {\n          if (typeof value[0] == \"string\") {\n            if (!result)\n              result = [];\n            result.push(value);\n          } else {\n            for (let i = 0; i < value.length; i++)\n              scan(value[i]);\n          }\n        } else {\n          for (let prop in value)\n            scan(value[prop]);\n        }\n      }\n    }\n    scan(attrs);\n    return result;\n  }\n  function renderSpec(doc4, structure, xmlNS, blockArraysIn) {\n    if (typeof structure == \"string\")\n      return { dom: doc4.createTextNode(structure) };\n    if (structure.nodeType != null)\n      return { dom: structure };\n    if (structure.dom && structure.dom.nodeType != null)\n      return structure;\n    let tagName = structure[0], suspicious;\n    if (typeof tagName != \"string\")\n      throw new RangeError(\"Invalid array passed to renderSpec\");\n    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)\n      throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n    let space = tagName.indexOf(\" \");\n    if (space > 0) {\n      xmlNS = tagName.slice(0, space);\n      tagName = tagName.slice(space + 1);\n    }\n    let contentDOM;\n    let dom = xmlNS ? doc4.createElementNS(xmlNS, tagName) : doc4.createElement(tagName);\n    let attrs = structure[1], start = 1;\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n      start = 2;\n      for (let name in attrs)\n        if (attrs[name] != null) {\n          let space2 = name.indexOf(\" \");\n          if (space2 > 0)\n            dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);\n          else if (name == \"style\" && dom.style)\n            dom.style.cssText = attrs[name];\n          else\n            dom.setAttribute(name, attrs[name]);\n        }\n    }\n    for (let i = start; i < structure.length; i++) {\n      let child = structure[i];\n      if (child === 0) {\n        if (i < structure.length - 1 || i > start)\n          throw new RangeError(\"Content hole must be the only child of its parent node\");\n        return { dom, contentDOM: dom };\n      } else {\n        let { dom: inner, contentDOM: innerContent } = renderSpec(doc4, child, xmlNS, blockArraysIn);\n        dom.appendChild(inner);\n        if (innerContent) {\n          if (contentDOM)\n            throw new RangeError(\"Multiple content holes\");\n          contentDOM = innerContent;\n        }\n      }\n    }\n    return { dom, contentDOM };\n  }\n\n  // node_modules/prosemirror-transform/dist/index.js\n  var lower16 = 65535;\n  var factor16 = Math.pow(2, 16);\n  function makeRecover(index, offset) {\n    return index + offset * factor16;\n  }\n  function recoverIndex(value) {\n    return value & lower16;\n  }\n  function recoverOffset(value) {\n    return (value - (value & lower16)) / factor16;\n  }\n  var DEL_BEFORE = 1;\n  var DEL_AFTER = 2;\n  var DEL_ACROSS = 4;\n  var DEL_SIDE = 8;\n  var MapResult = class {\n    /**\n    @internal\n    */\n    constructor(pos, delInfo, recover) {\n      this.pos = pos;\n      this.delInfo = delInfo;\n      this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() {\n      return (this.delInfo & DEL_SIDE) > 0;\n    }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() {\n      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n    }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() {\n      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n    }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() {\n      return (this.delInfo & DEL_ACROSS) > 0;\n    }\n  };\n  var StepMap = class _StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(ranges, inverted = false) {\n      this.ranges = ranges;\n      this.inverted = inverted;\n      if (!ranges.length && _StepMap.empty)\n        return _StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n      let diff = 0, index = recoverIndex(value);\n      if (!this.inverted)\n        for (let i = 0; i < index; i++)\n          diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n      return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) {\n      return this._map(pos, assoc, false);\n    }\n    map(pos, assoc = 1) {\n      return this._map(pos, assoc, true);\n    }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n      let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n      for (let i = 0; i < this.ranges.length; i += 3) {\n        let start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos)\n          break;\n        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n        if (pos <= end) {\n          let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n          let result = start + diff + (side < 0 ? 0 : newSize);\n          if (simple)\n            return result;\n          let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n          let del2 = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n          if (assoc < 0 ? pos != start : pos != end)\n            del2 |= DEL_SIDE;\n          return new MapResult(result, del2, recover);\n        }\n        diff += newSize - oldSize;\n      }\n      return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n      let diff = 0, index = recoverIndex(recover);\n      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n      for (let i = 0; i < this.ranges.length; i += 3) {\n        let start = this.ranges[i] - (this.inverted ? diff : 0);\n        if (start > pos)\n          break;\n        let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n        if (pos <= end && i == index * 3)\n          return true;\n        diff += this.ranges[i + newIndex] - oldSize;\n      }\n      return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n      let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n      for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n        let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n        let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n        diff += newSize - oldSize;\n      }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n      return new _StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n      return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n      return n == 0 ? _StepMap.empty : new _StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n  };\n  StepMap.empty = new StepMap([]);\n  var Mapping = class _Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(maps, mirror, from4 = 0, to = maps ? maps.length : 0) {\n      this.mirror = mirror;\n      this.from = from4;\n      this.to = to;\n      this._maps = maps || [];\n      this.ownData = !(maps || mirror);\n    }\n    /**\n    The step maps in this mapping.\n    */\n    get maps() {\n      return this._maps;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from4 = 0, to = this.maps.length) {\n      return new _Mapping(this._maps, this.mirror, from4, to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map3, mirrors) {\n      if (!this.ownData) {\n        this._maps = this._maps.slice();\n        this.mirror = this.mirror && this.mirror.slice();\n        this.ownData = true;\n      }\n      this.to = this._maps.push(map3);\n      if (mirrors != null)\n        this.setMirror(this._maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n      for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {\n        let mirr = mapping.getMirror(i);\n        this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);\n      }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n      if (this.mirror) {\n        for (let i = 0; i < this.mirror.length; i++)\n          if (this.mirror[i] == n)\n            return this.mirror[i + (i % 2 ? -1 : 1)];\n      }\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n      if (!this.mirror)\n        this.mirror = [];\n      this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n      for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {\n        let mirr = mapping.getMirror(i);\n        this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);\n      }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n      let inverse = new _Mapping();\n      inverse.appendMappingInverted(this);\n      return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n      if (this.mirror)\n        return this._map(pos, assoc, true);\n      for (let i = this.from; i < this.to; i++)\n        pos = this._maps[i].map(pos, assoc);\n      return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) {\n      return this._map(pos, assoc, false);\n    }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n      let delInfo = 0;\n      for (let i = this.from; i < this.to; i++) {\n        let map3 = this._maps[i], result = map3.mapResult(pos, assoc);\n        if (result.recover != null) {\n          let corr = this.getMirror(i);\n          if (corr != null && corr > i && corr < this.to) {\n            i = corr;\n            pos = this._maps[corr].recover(result.recover);\n            continue;\n          }\n        }\n        delInfo |= result.delInfo;\n        pos = result.pos;\n      }\n      return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n  };\n  var stepsByID = /* @__PURE__ */ Object.create(null);\n  var Step = class {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() {\n      return StepMap.empty;\n    }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n    merge(other) {\n      return null;\n    }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n    static fromJSON(schema2, json) {\n      if (!json || !json.stepType)\n        throw new RangeError(\"Invalid input for Step.fromJSON\");\n      let type = stepsByID[json.stepType];\n      if (!type)\n        throw new RangeError(`No step type ${json.stepType} defined`);\n      return type.fromJSON(schema2, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n    static jsonID(id2, stepClass) {\n      if (id2 in stepsByID)\n        throw new RangeError(\"Duplicate use of step JSON ID \" + id2);\n      stepsByID[id2] = stepClass;\n      stepClass.prototype.jsonID = id2;\n      return stepClass;\n    }\n  };\n  var StepResult = class _StepResult {\n    /**\n    @internal\n    */\n    constructor(doc4, failed) {\n      this.doc = doc4;\n      this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc4) {\n      return new _StepResult(doc4, null);\n    }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) {\n      return new _StepResult(null, message);\n    }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc4, from4, to, slice2) {\n      try {\n        return _StepResult.ok(doc4.replace(from4, to, slice2));\n      } catch (e) {\n        if (e instanceof ReplaceError)\n          return _StepResult.fail(e.message);\n        throw e;\n      }\n    }\n  };\n  function mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n      let child = fragment.child(i);\n      if (child.content.size)\n        child = child.copy(mapFragment(child.content, f, child));\n      if (child.isInline)\n        child = f(child, parent, i);\n      mapped.push(child);\n    }\n    return Fragment.fromArray(mapped);\n  }\n  var AddMarkStep = class _AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(from4, to, mark) {\n      super();\n      this.from = from4;\n      this.to = to;\n      this.mark = mark;\n    }\n    apply(doc4) {\n      let oldSlice = doc4.slice(this.from, this.to), $from = doc4.resolve(this.from);\n      let parent = $from.node($from.sharedDepth(this.to));\n      let slice2 = new Slice(mapFragment(oldSlice.content, (node, parent2) => {\n        if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))\n          return node;\n        return node.mark(this.mark.addToSet(node.marks));\n      }, parent), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc4, this.from, this.to, slice2);\n    }\n    invert() {\n      return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n      let from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      if (from4.deleted && to.deleted || from4.pos >= to.pos)\n        return null;\n      return new _AddMarkStep(from4.pos, to.pos, this.mark);\n    }\n    merge(other) {\n      if (other instanceof _AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n        return new _AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n    toJSON() {\n      return {\n        stepType: \"addMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\")\n        throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n      return new _AddMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"addMark\", AddMarkStep);\n  var RemoveMarkStep = class _RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(from4, to, mark) {\n      super();\n      this.from = from4;\n      this.to = to;\n      this.mark = mark;\n    }\n    apply(doc4) {\n      let oldSlice = doc4.slice(this.from, this.to);\n      let slice2 = new Slice(mapFragment(oldSlice.content, (node) => {\n        return node.mark(this.mark.removeFromSet(node.marks));\n      }, doc4), oldSlice.openStart, oldSlice.openEnd);\n      return StepResult.fromReplace(doc4, this.from, this.to, slice2);\n    }\n    invert() {\n      return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n      let from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      if (from4.deleted && to.deleted || from4.pos >= to.pos)\n        return null;\n      return new _RemoveMarkStep(from4.pos, to.pos, this.mark);\n    }\n    merge(other) {\n      if (other instanceof _RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)\n        return new _RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n      return null;\n    }\n    toJSON() {\n      return {\n        stepType: \"removeMark\",\n        mark: this.mark.toJSON(),\n        from: this.from,\n        to: this.to\n      };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\")\n        throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n      return new _RemoveMarkStep(json.from, json.to, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"removeMark\", RemoveMarkStep);\n  var AddNodeMarkStep = class _AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(pos, mark) {\n      super();\n      this.pos = pos;\n      this.mark = mark;\n    }\n    apply(doc4) {\n      let node = doc4.nodeAt(this.pos);\n      if (!node)\n        return StepResult.fail(\"No node at mark step's position\");\n      let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n      return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc4) {\n      let node = doc4.nodeAt(this.pos);\n      if (node) {\n        let newSet = this.mark.addToSet(node.marks);\n        if (newSet.length == node.marks.length) {\n          for (let i = 0; i < node.marks.length; i++)\n            if (!node.marks[i].isInSet(newSet))\n              return new _AddNodeMarkStep(this.pos, node.marks[i]);\n          return new _AddNodeMarkStep(this.pos, this.mark);\n        }\n      }\n      return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n      let pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new _AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n      return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.pos != \"number\")\n        throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n      return new _AddNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"addNodeMark\", AddNodeMarkStep);\n  var RemoveNodeMarkStep = class _RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(pos, mark) {\n      super();\n      this.pos = pos;\n      this.mark = mark;\n    }\n    apply(doc4) {\n      let node = doc4.nodeAt(this.pos);\n      if (!node)\n        return StepResult.fail(\"No node at mark step's position\");\n      let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n      return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc4) {\n      let node = doc4.nodeAt(this.pos);\n      if (!node || !this.mark.isInSet(node.marks))\n        return this;\n      return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n      let pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new _RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n      return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.pos != \"number\")\n        throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n      return new _RemoveNodeMarkStep(json.pos, schema2.markFromJSON(json.mark));\n    }\n  };\n  Step.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n  var ReplaceStep = class _ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */\n    constructor(from4, to, slice2, structure = false) {\n      super();\n      this.from = from4;\n      this.to = to;\n      this.slice = slice2;\n      this.structure = structure;\n    }\n    apply(doc4) {\n      if (this.structure && contentBetween(doc4, this.from, this.to))\n        return StepResult.fail(\"Structure replace would overwrite content\");\n      return StepResult.fromReplace(doc4, this.from, this.to, this.slice);\n    }\n    getMap() {\n      return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc4) {\n      return new _ReplaceStep(this.from, this.from + this.slice.size, doc4.slice(this.from, this.to));\n    }\n    map(mapping) {\n      let from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      if (from4.deletedAcross && to.deletedAcross)\n        return null;\n      return new _ReplaceStep(from4.pos, Math.max(from4.pos, to.pos), this.slice, this.structure);\n    }\n    merge(other) {\n      if (!(other instanceof _ReplaceStep) || other.structure || this.structure)\n        return null;\n      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n        return new _ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);\n      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n        let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n        return new _ReplaceStep(other.from, this.to, slice2, this.structure);\n      } else {\n        return null;\n      }\n    }\n    toJSON() {\n      let json = { stepType: \"replace\", from: this.from, to: this.to };\n      if (this.slice.size)\n        json.slice = this.slice.toJSON();\n      if (this.structure)\n        json.structure = true;\n      return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\")\n        throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n      return new _ReplaceStep(json.from, json.to, Slice.fromJSON(schema2, json.slice), !!json.structure);\n    }\n  };\n  Step.jsonID(\"replace\", ReplaceStep);\n  var ReplaceAroundStep = class _ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(from4, to, gapFrom, gapTo, slice2, insert, structure = false) {\n      super();\n      this.from = from4;\n      this.to = to;\n      this.gapFrom = gapFrom;\n      this.gapTo = gapTo;\n      this.slice = slice2;\n      this.insert = insert;\n      this.structure = structure;\n    }\n    apply(doc4) {\n      if (this.structure && (contentBetween(doc4, this.from, this.gapFrom) || contentBetween(doc4, this.gapTo, this.to)))\n        return StepResult.fail(\"Structure gap-replace would overwrite content\");\n      let gap = doc4.slice(this.gapFrom, this.gapTo);\n      if (gap.openStart || gap.openEnd)\n        return StepResult.fail(\"Gap is not a flat range\");\n      let inserted = this.slice.insertAt(this.insert, gap.content);\n      if (!inserted)\n        return StepResult.fail(\"Content does not fit in gap\");\n      return StepResult.fromReplace(doc4, this.from, this.to, inserted);\n    }\n    getMap() {\n      return new StepMap([\n        this.from,\n        this.gapFrom - this.from,\n        this.insert,\n        this.gapTo,\n        this.to - this.gapTo,\n        this.slice.size - this.insert\n      ]);\n    }\n    invert(doc4) {\n      let gap = this.gapTo - this.gapFrom;\n      return new _ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc4.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n      let from4 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n      let gapFrom = this.from == this.gapFrom ? from4.pos : mapping.map(this.gapFrom, -1);\n      let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n      if (from4.deletedAcross && to.deletedAcross || gapFrom < from4.pos || gapTo > to.pos)\n        return null;\n      return new _ReplaceAroundStep(from4.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n      let json = {\n        stepType: \"replaceAround\",\n        from: this.from,\n        to: this.to,\n        gapFrom: this.gapFrom,\n        gapTo: this.gapTo,\n        insert: this.insert\n      };\n      if (this.slice.size)\n        json.slice = this.slice.toJSON();\n      if (this.structure)\n        json.structure = true;\n      return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema2, json) {\n      if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n        throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n      return new _ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema2, json.slice), json.insert, !!json.structure);\n    }\n  };\n  Step.jsonID(\"replaceAround\", ReplaceAroundStep);\n  function contentBetween(doc4, from4, to) {\n    let $from = doc4.resolve(from4), dist = to - from4, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n      depth--;\n      dist--;\n    }\n    if (dist > 0) {\n      let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n      while (dist > 0) {\n        if (!next || next.isLeaf)\n          return true;\n        next = next.firstChild;\n        dist--;\n      }\n    }\n    return false;\n  }\n  function addMark(tr, from4, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from4, to, (node, pos, parent) => {\n      if (!node.isInline)\n        return;\n      let marks2 = node.marks;\n      if (!mark.isInSet(marks2) && parent.type.allowsMarkType(mark.type)) {\n        let start = Math.max(pos, from4), end = Math.min(pos + node.nodeSize, to);\n        let newSet = mark.addToSet(marks2);\n        for (let i = 0; i < marks2.length; i++) {\n          if (!marks2[i].isInSet(newSet)) {\n            if (removing && removing.to == start && removing.mark.eq(marks2[i]))\n              removing.to = end;\n            else\n              removed.push(removing = new RemoveMarkStep(start, end, marks2[i]));\n          }\n        }\n        if (adding && adding.to == start)\n          adding.to = end;\n        else\n          added.push(adding = new AddMarkStep(start, end, mark));\n      }\n    });\n    removed.forEach((s) => tr.step(s));\n    added.forEach((s) => tr.step(s));\n  }\n  function removeMark(tr, from4, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from4, to, (node, pos) => {\n      if (!node.isInline)\n        return;\n      step++;\n      let toRemove = null;\n      if (mark instanceof MarkType) {\n        let set = node.marks, found2;\n        while (found2 = mark.isInSet(set)) {\n          (toRemove || (toRemove = [])).push(found2);\n          set = found2.removeFromSet(set);\n        }\n      } else if (mark) {\n        if (mark.isInSet(node.marks))\n          toRemove = [mark];\n      } else {\n        toRemove = node.marks;\n      }\n      if (toRemove && toRemove.length) {\n        let end = Math.min(pos + node.nodeSize, to);\n        for (let i = 0; i < toRemove.length; i++) {\n          let style = toRemove[i], found2;\n          for (let j = 0; j < matched.length; j++) {\n            let m = matched[j];\n            if (m.step == step - 1 && style.eq(matched[j].style))\n              found2 = m;\n          }\n          if (found2) {\n            found2.to = end;\n            found2.step = step;\n          } else {\n            matched.push({ style, from: Math.max(pos, from4), to: end, step });\n          }\n        }\n      }\n    });\n    matched.forEach((m) => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n  }\n  function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n      let child = node.child(i), end = cur + child.nodeSize;\n      let allowed = match.matchType(child.type);\n      if (!allowed) {\n        replSteps.push(new ReplaceStep(cur, end, Slice.empty));\n      } else {\n        match = allowed;\n        for (let j = 0; j < child.marks.length; j++)\n          if (!parentType.allowsMarkType(child.marks[j].type))\n            tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n        if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n          let m, newline = /\\r?\\n|\\r/g, slice2;\n          while (m = newline.exec(child.text)) {\n            if (!slice2)\n              slice2 = new Slice(Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n            replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice2));\n          }\n        }\n      }\n      cur = end;\n    }\n    if (!match.validEnd) {\n      let fill = match.fillBefore(Fragment.empty, true);\n      tr.replace(cur, cur, new Slice(fill, 0, 0));\n    }\n    for (let i = replSteps.length - 1; i >= 0; i--)\n      tr.step(replSteps[i]);\n  }\n  function canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n  }\n  function liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for (let depth = range.depth; ; --depth) {\n      let node = range.$from.node(depth);\n      let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n      if (depth < range.depth && node.canReplace(index, endIndex, content))\n        return depth;\n      if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n        break;\n    }\n    return null;\n  }\n  function lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n      if (splitting || $from.index(d) > 0) {\n        splitting = true;\n        before = Fragment.from($from.node(d).copy(before));\n        openStart++;\n      } else {\n        start--;\n      }\n    let after = Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n      if (splitting || $to.after(d + 1) < $to.end(d)) {\n        splitting = true;\n        after = Fragment.from($to.node(d).copy(after));\n        openEnd++;\n      } else {\n        end++;\n      }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n  }\n  function wrap(tr, range, wrappers) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n      if (content.size) {\n        let match = wrappers[i].type.contentMatch.matchFragment(content);\n        if (!match || !match.validEnd)\n          throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n      }\n      content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));\n  }\n  function setBlockType(tr, from4, to, type, attrs) {\n    if (!type.isTextblock)\n      throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from4, to, (node, pos) => {\n      let attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n      if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n        let convertNewlines = null;\n        if (type.schema.linebreakReplacement) {\n          let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n          if (pre && !supportLinebreak)\n            convertNewlines = false;\n          else if (!pre && supportLinebreak)\n            convertNewlines = true;\n        }\n        if (convertNewlines === false)\n          replaceLinebreaks(tr, node, pos, mapFrom);\n        clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, void 0, convertNewlines === null);\n        let mapping = tr.mapping.slice(mapFrom);\n        let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n        tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n        if (convertNewlines === true)\n          replaceNewlines(tr, node, pos, mapFrom);\n        return false;\n      }\n    });\n  }\n  function replaceNewlines(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n      if (child.isText) {\n        let m, newline = /\\r?\\n|\\r/g;\n        while (m = newline.exec(child.text)) {\n          let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n          tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n        }\n      }\n    });\n  }\n  function replaceLinebreaks(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n      if (child.type == child.type.schema.linebreakReplacement) {\n        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n        tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n      }\n    });\n  }\n  function canChangeType(doc4, pos, type) {\n    let $pos = doc4.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n  }\n  function setNodeMarkup(tr, pos, type, attrs, marks2) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n      throw new RangeError(\"No node at given position\");\n    if (!type)\n      type = node.type;\n    let newNode = type.create(attrs, null, marks2 || node.marks);\n    if (node.isLeaf)\n      return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n      throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));\n  }\n  function canSplit(doc4, pos, depth = 1, typesAfter) {\n    let $pos = doc4.resolve(pos), base2 = $pos.depth - depth;\n    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n    if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n      return false;\n    for (let d = $pos.depth - 1, i = depth - 2; d > base2; d--, i--) {\n      let node = $pos.node(d), index2 = $pos.index(d);\n      if (node.type.spec.isolating)\n        return false;\n      let rest = node.content.cutByIndex(index2, node.childCount);\n      let overrideChild = typesAfter && typesAfter[i + 1];\n      if (overrideChild)\n        rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n      let after = typesAfter && typesAfter[i] || node;\n      if (!node.canReplace(index2 + 1, node.childCount) || !after.type.validContent(rest))\n        return false;\n    }\n    let index = $pos.indexAfter(base2);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base2).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base2 + 1).type);\n  }\n  function split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n      before = Fragment.from($pos.node(d).copy(before));\n      let typeAfter = typesAfter && typesAfter[i];\n      after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));\n  }\n  function canJoin(doc4, pos) {\n    let $pos = doc4.resolve(pos), index = $pos.index();\n    return joinable2($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n  }\n  function canAppendWithSubstitutedLinebreaks(a, b) {\n    if (!b.content.size)\n      a.type.compatibleContent(b.type);\n    let match = a.contentMatchAt(a.childCount);\n    let { linebreakReplacement } = a.type.schema;\n    for (let i = 0; i < b.childCount; i++) {\n      let child = b.child(i);\n      let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n      match = match.matchType(type);\n      if (!match)\n        return false;\n      if (!a.type.allowsMarks(child.marks))\n        return false;\n    }\n    return match.validEnd;\n  }\n  function joinable2(a, b) {\n    return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n  }\n  function join(tr, pos, depth) {\n    let convertNewlines = null;\n    let { linebreakReplacement } = tr.doc.type.schema;\n    let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;\n    if (linebreakReplacement && beforeType.inlineContent) {\n      let pre = beforeType.whitespace == \"pre\";\n      let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n      if (pre && !supportLinebreak)\n        convertNewlines = false;\n      else if (!pre && supportLinebreak)\n        convertNewlines = true;\n    }\n    let mapFrom = tr.steps.length;\n    if (convertNewlines === false) {\n      let $after = tr.doc.resolve(pos + depth);\n      replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n    }\n    if (beforeType.inlineContent)\n      clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n    let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);\n    tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));\n    if (convertNewlines === true) {\n      let $full = tr.doc.resolve(start);\n      replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n    }\n    return tr;\n  }\n  function insertPoint(doc4, pos, nodeType) {\n    let $pos = doc4.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n      return pos;\n    if ($pos.parentOffset == 0)\n      for (let d = $pos.depth - 1; d >= 0; d--) {\n        let index = $pos.index(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType))\n          return $pos.before(d + 1);\n        if (index > 0)\n          return null;\n      }\n    if ($pos.parentOffset == $pos.parent.content.size)\n      for (let d = $pos.depth - 1; d >= 0; d--) {\n        let index = $pos.indexAfter(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType))\n          return $pos.after(d + 1);\n        if (index < $pos.node(d).childCount)\n          return null;\n      }\n    return null;\n  }\n  function dropPoint(doc4, pos, slice2) {\n    let $pos = doc4.resolve(pos);\n    if (!slice2.content.size)\n      return pos;\n    let content = slice2.content;\n    for (let i = 0; i < slice2.openStart; i++)\n      content = content.firstChild.content;\n    for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {\n      for (let d = $pos.depth; d >= 0; d--) {\n        let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n        let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n        let parent = $pos.node(d), fits = false;\n        if (pass == 1) {\n          fits = parent.canReplace(insertPos, insertPos, content);\n        } else {\n          let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n          fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n        }\n        if (fits)\n          return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n      }\n    }\n    return null;\n  }\n  function replaceStep(doc4, from4, to = from4, slice2 = Slice.empty) {\n    if (from4 == to && !slice2.size)\n      return null;\n    let $from = doc4.resolve(from4), $to = doc4.resolve(to);\n    if (fitsTrivially($from, $to, slice2))\n      return new ReplaceStep(from4, to, slice2);\n    return new Fitter($from, $to, slice2).fit();\n  }\n  function fitsTrivially($from, $to, slice2) {\n    return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);\n  }\n  var Fitter = class {\n    constructor($from, $to, unplaced) {\n      this.$from = $from;\n      this.$to = $to;\n      this.unplaced = unplaced;\n      this.frontier = [];\n      this.placed = Fragment.empty;\n      for (let i = 0; i <= $from.depth; i++) {\n        let node = $from.node(i);\n        this.frontier.push({\n          type: node.type,\n          match: node.contentMatchAt($from.indexAfter(i))\n        });\n      }\n      for (let i = $from.depth; i > 0; i--)\n        this.placed = Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() {\n      return this.frontier.length - 1;\n    }\n    fit() {\n      while (this.unplaced.size) {\n        let fit = this.findFittable();\n        if (fit)\n          this.placeNodes(fit);\n        else\n          this.openMore() || this.dropNode();\n      }\n      let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n      let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n      if (!$to)\n        return null;\n      let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n      while (openStart && openEnd && content.childCount == 1) {\n        content = content.firstChild.content;\n        openStart--;\n        openEnd--;\n      }\n      let slice2 = new Slice(content, openStart, openEnd);\n      if (moveInline > -1)\n        return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);\n      if (slice2.size || $from.pos != this.$to.pos)\n        return new ReplaceStep($from.pos, $to.pos, slice2);\n      return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n      let startDepth = this.unplaced.openStart;\n      for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n        let node = cur.firstChild;\n        if (cur.childCount > 1)\n          openEnd = 0;\n        if (node.type.spec.isolating && openEnd <= d) {\n          startDepth = d;\n          break;\n        }\n        cur = node.content;\n      }\n      for (let pass = 1; pass <= 2; pass++) {\n        for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n          let fragment, parent = null;\n          if (sliceDepth) {\n            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n            fragment = parent.content;\n          } else {\n            fragment = this.unplaced.content;\n          }\n          let first = fragment.firstChild;\n          for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n            let { type, match } = this.frontier[frontierDepth], wrap2, inject = null;\n            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type.compatibleContent(parent.type)))\n              return { sliceDepth, frontierDepth, parent, inject };\n            else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))\n              return { sliceDepth, frontierDepth, parent, wrap: wrap2 };\n            if (parent && match.matchType(parent.type))\n              break;\n          }\n        }\n      }\n    }\n    openMore() {\n      let { content, openStart, openEnd } = this.unplaced;\n      let inner = contentAt(content, openStart);\n      if (!inner.childCount || inner.firstChild.isLeaf)\n        return false;\n      this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n      return true;\n    }\n    dropNode() {\n      let { content, openStart, openEnd } = this.unplaced;\n      let inner = contentAt(content, openStart);\n      if (inner.childCount <= 1 && openStart > 0) {\n        let openAtEnd = content.size - openStart <= openStart + inner.size;\n        this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n      } else {\n        this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n      }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {\n      while (this.depth > frontierDepth)\n        this.closeFrontierNode();\n      if (wrap2)\n        for (let i = 0; i < wrap2.length; i++)\n          this.openFrontierNode(wrap2[i]);\n      let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;\n      let openStart = slice2.openStart - sliceDepth;\n      let taken = 0, add2 = [];\n      let { match, type } = this.frontier[frontierDepth];\n      if (inject) {\n        for (let i = 0; i < inject.childCount; i++)\n          add2.push(inject.child(i));\n        match = match.matchFragment(inject);\n      }\n      let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);\n      while (taken < fragment.childCount) {\n        let next = fragment.child(taken), matches2 = match.matchType(next.type);\n        if (!matches2)\n          break;\n        taken++;\n        if (taken > 1 || openStart == 0 || next.content.size) {\n          match = matches2;\n          add2.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n        }\n      }\n      let toEnd = taken == fragment.childCount;\n      if (!toEnd)\n        openEndCount = -1;\n      this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add2));\n      this.frontier[frontierDepth].match = match;\n      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n        this.closeFrontierNode();\n      for (let i = 0, cur = fragment; i < openEndCount; i++) {\n        let node = cur.lastChild;\n        this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n        cur = node.content;\n      }\n      this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n      if (!this.$to.parent.isTextblock)\n        return -1;\n      let top = this.frontier[this.depth], level;\n      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)\n        return -1;\n      let { depth } = this.$to, after = this.$to.after(depth);\n      while (depth > 1 && after == this.$to.end(--depth))\n        ++after;\n      return after;\n    }\n    findCloseLevel($to) {\n      scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n        let { match, type } = this.frontier[i];\n        let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n        let fit = contentAfterFits($to, i, type, match, dropInner);\n        if (!fit)\n          continue;\n        for (let d = i - 1; d >= 0; d--) {\n          let { match: match2, type: type2 } = this.frontier[d];\n          let matches2 = contentAfterFits($to, d, type2, match2, true);\n          if (!matches2 || matches2.childCount)\n            continue scan;\n        }\n        return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n      }\n    }\n    close($to) {\n      let close2 = this.findCloseLevel($to);\n      if (!close2)\n        return null;\n      while (this.depth > close2.depth)\n        this.closeFrontierNode();\n      if (close2.fit.childCount)\n        this.placed = addToFragment(this.placed, close2.depth, close2.fit);\n      $to = close2.move;\n      for (let d = close2.depth + 1; d <= $to.depth; d++) {\n        let node = $to.node(d), add2 = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n        this.openFrontierNode(node.type, node.attrs, add2);\n      }\n      return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n      let top = this.frontier[this.depth];\n      top.match = top.match.matchType(type);\n      this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n      this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n      let open = this.frontier.pop();\n      let add2 = open.match.fillBefore(Fragment.empty, true);\n      if (add2.childCount)\n        this.placed = addToFragment(this.placed, this.frontier.length, add2);\n    }\n  };\n  function dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n      return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n  }\n  function addToFragment(fragment, depth, content) {\n    if (depth == 0)\n      return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n  }\n  function contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n      fragment = fragment.firstChild.content;\n    return fragment;\n  }\n  function closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n      return node;\n    let frag = node.content;\n    if (openStart > 1)\n      frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n      frag = node.type.contentMatch.fillBefore(frag).append(frag);\n      if (openEnd <= 0)\n        frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));\n    }\n    return node.copy(frag);\n  }\n  function contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n      return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n  }\n  function invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n      if (!type.allowsMarks(fragment.child(i).marks))\n        return true;\n    return false;\n  }\n  function definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n  }\n  function replaceRange(tr, from4, to, slice2) {\n    if (!slice2.size)\n      return tr.deleteRange(from4, to);\n    let $from = tr.doc.resolve(from4), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice2))\n      return tr.step(new ReplaceStep(from4, to, slice2));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    if (targetDepths[targetDepths.length - 1] == 0)\n      targetDepths.pop();\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n      let spec = $from.node(d).type.spec;\n      if (spec.defining || spec.definingAsContext || spec.isolating)\n        break;\n      if (targetDepths.indexOf(d) > -1)\n        preferredTarget = d;\n      else if ($from.before(d) == pos)\n        targetDepths.splice(1, 0, -d);\n    }\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice2.openStart;\n    for (let content = slice2.content, i = 0; ; i++) {\n      let node = content.firstChild;\n      leftNodes.push(node);\n      if (i == slice2.openStart)\n        break;\n      content = node.content;\n    }\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n      let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n      if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))\n        preferredDepth = d;\n      else if (def || !leftNode.type.isTextblock)\n        break;\n    }\n    for (let j = slice2.openStart; j >= 0; j--) {\n      let openDepth = (j + preferredDepth + 1) % (slice2.openStart + 1);\n      let insert = leftNodes[openDepth];\n      if (!insert)\n        continue;\n      for (let i = 0; i < targetDepths.length; i++) {\n        let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n        if (targetDepth < 0) {\n          expand = false;\n          targetDepth = -targetDepth;\n        }\n        let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n        if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n          return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));\n      }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n      tr.replace(from4, to, slice2);\n      if (tr.steps.length > startSteps)\n        break;\n      let depth = targetDepths[i];\n      if (depth < 0)\n        continue;\n      from4 = $from.before(depth);\n      to = $to.after(depth);\n    }\n  }\n  function closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n      let first = fragment.firstChild;\n      fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n      let match = parent.contentMatchAt(0);\n      let start = match.fillBefore(fragment).append(fragment);\n      fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n    }\n    return fragment;\n  }\n  function replaceRangeWith(tr, from4, to, node) {\n    if (!node.isInline && from4 == to && tr.doc.resolve(from4).parent.content.size) {\n      let point = insertPoint(tr.doc, from4, node.type);\n      if (point != null)\n        from4 = to = point;\n    }\n    tr.replaceRange(from4, to, new Slice(Fragment.from(node), 0, 0));\n  }\n  function deleteRange(tr, from4, to) {\n    let $from = tr.doc.resolve(from4), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n      let depth = covered[i], last2 = i == covered.length - 1;\n      if (last2 && depth == 0 || $from.node(depth).type.contentMatch.validEnd)\n        return tr.delete($from.start(depth), $to.end(depth));\n      if (depth > 0 && (last2 || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n        return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n      if (from4 - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))\n        return tr.delete($from.before(d), to);\n    }\n    tr.delete(from4, to);\n  }\n  function coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n      let start = $from.start(d);\n      if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating)\n        break;\n      if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1)\n        result.push(d);\n    }\n    return result;\n  }\n  var AttrStep = class _AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(pos, attr, value) {\n      super();\n      this.pos = pos;\n      this.attr = attr;\n      this.value = value;\n    }\n    apply(doc4) {\n      let node = doc4.nodeAt(this.pos);\n      if (!node)\n        return StepResult.fail(\"No node at attribute step's position\");\n      let attrs = /* @__PURE__ */ Object.create(null);\n      for (let name in node.attrs)\n        attrs[name] = node.attrs[name];\n      attrs[this.attr] = this.value;\n      let updated = node.type.create(attrs, null, node.marks);\n      return StepResult.fromReplace(doc4, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n      return StepMap.empty;\n    }\n    invert(doc4) {\n      return new _AttrStep(this.pos, this.attr, doc4.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n      let pos = mapping.mapResult(this.pos, 1);\n      return pos.deletedAfter ? null : new _AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n      return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema2, json) {\n      if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n        throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n      return new _AttrStep(json.pos, json.attr, json.value);\n    }\n  };\n  Step.jsonID(\"attr\", AttrStep);\n  var DocAttrStep = class _DocAttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(attr, value) {\n      super();\n      this.attr = attr;\n      this.value = value;\n    }\n    apply(doc4) {\n      let attrs = /* @__PURE__ */ Object.create(null);\n      for (let name in doc4.attrs)\n        attrs[name] = doc4.attrs[name];\n      attrs[this.attr] = this.value;\n      let updated = doc4.type.create(attrs, doc4.content, doc4.marks);\n      return StepResult.ok(updated);\n    }\n    getMap() {\n      return StepMap.empty;\n    }\n    invert(doc4) {\n      return new _DocAttrStep(this.attr, doc4.attrs[this.attr]);\n    }\n    map(mapping) {\n      return this;\n    }\n    toJSON() {\n      return { stepType: \"docAttr\", attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema2, json) {\n      if (typeof json.attr != \"string\")\n        throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n      return new _DocAttrStep(json.attr, json.value);\n    }\n  };\n  Step.jsonID(\"docAttr\", DocAttrStep);\n  var TransformError = class extends Error {\n  };\n  TransformError = function TransformError2(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError2.prototype;\n    return err;\n  };\n  TransformError.prototype = Object.create(Error.prototype);\n  TransformError.prototype.constructor = TransformError;\n  TransformError.prototype.name = \"TransformError\";\n  var Transform = class {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(doc4) {\n      this.doc = doc4;\n      this.steps = [];\n      this.docs = [];\n      this.mapping = new Mapping();\n    }\n    /**\n    The starting document.\n    */\n    get before() {\n      return this.docs.length ? this.docs[0] : this.doc;\n    }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n      let result = this.maybeStep(step);\n      if (result.failed)\n        throw new TransformError(result.failed);\n      return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n      let result = step.apply(this.doc);\n      if (!result.failed)\n        this.addStep(step, result.doc);\n      return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n      return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc4) {\n      this.docs.push(this.doc);\n      this.steps.push(step);\n      this.mapping.appendMap(step.getMap());\n      this.doc = doc4;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from4, to = from4, slice2 = Slice.empty) {\n      let step = replaceStep(this.doc, from4, to, slice2);\n      if (step)\n        this.step(step);\n      return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from4, to, content) {\n      return this.replace(from4, to, new Slice(Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from4, to) {\n      return this.replace(from4, to, Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n      return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from4, to, slice2) {\n      replaceRange(this, from4, to, slice2);\n      return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from4, to, node) {\n      replaceRangeWith(this, from4, to, node);\n      return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from4, to) {\n      deleteRange(this, from4, to);\n      return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n      lift(this, range, target);\n      return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n      join(this, pos, depth);\n      return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n      wrap(this, range, wrappers);\n      return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from4, to = from4, type, attrs = null) {\n      setBlockType(this, from4, to, type, attrs);\n      return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks2) {\n      setNodeMarkup(this, pos, type, attrs, marks2);\n      return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */\n    setNodeAttribute(pos, attr, value) {\n      this.step(new AttrStep(pos, attr, value));\n      return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */\n    setDocAttribute(attr, value) {\n      this.step(new DocAttrStep(attr, value));\n      return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n      this.step(new AddNodeMarkStep(pos, mark));\n      return this;\n    }\n    /**\n    Remove a mark (or all marks of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n      let node = this.doc.nodeAt(pos);\n      if (!node)\n        throw new RangeError(\"No node at position \" + pos);\n      if (mark instanceof Mark) {\n        if (mark.isInSet(node.marks))\n          this.step(new RemoveNodeMarkStep(pos, mark));\n      } else {\n        let set = node.marks, found2, steps = [];\n        while (found2 = mark.isInSet(set)) {\n          steps.push(new RemoveNodeMarkStep(pos, found2));\n          set = found2.removeFromSet(set);\n        }\n        for (let i = steps.length - 1; i >= 0; i--)\n          this.step(steps[i]);\n      }\n      return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split (with the outermost nodes coming first).\n    */\n    split(pos, depth = 1, typesAfter) {\n      split(this, pos, depth, typesAfter);\n      return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from4, to, mark) {\n      addMark(this, from4, to, mark);\n      return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from4, to, mark) {\n      removeMark(this, from4, to, mark);\n      return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n      clearIncompatible(this, pos, parentType, match);\n      return this;\n    }\n  };\n\n  // node_modules/prosemirror-state/dist/index.js\n  var classesById = /* @__PURE__ */ Object.create(null);\n  var Selection = class {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor($anchor, $head, ranges) {\n      this.$anchor = $anchor;\n      this.$head = $head;\n      this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection's anchor, as an unresolved position.\n    */\n    get anchor() {\n      return this.$anchor.pos;\n    }\n    /**\n    The selection's head.\n    */\n    get head() {\n      return this.$head.pos;\n    }\n    /**\n    The lower bound of the selection's main range.\n    */\n    get from() {\n      return this.$from.pos;\n    }\n    /**\n    The upper bound of the selection's main range.\n    */\n    get to() {\n      return this.$to.pos;\n    }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n    get $from() {\n      return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n    get $to() {\n      return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n      let ranges = this.ranges;\n      for (let i = 0; i < ranges.length; i++)\n        if (ranges[i].$from.pos != ranges[i].$to.pos)\n          return false;\n      return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n      return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = Slice.empty) {\n      let lastNode = content.content.lastChild, lastParent = null;\n      for (let i = 0; i < content.openEnd; i++) {\n        lastParent = lastNode;\n        lastNode = lastNode.lastChild;\n      }\n      let mapFrom = tr.steps.length, ranges = this.ranges;\n      for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n        if (i == 0)\n          selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n      }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n      let mapFrom = tr.steps.length, ranges = this.ranges;\n      for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n        let from4 = mapping.map($from.pos), to = mapping.map($to.pos);\n        if (i) {\n          tr.deleteRange(from4, to);\n        } else {\n          tr.replaceRangeWith(from4, to, node);\n          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n        }\n      }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n      let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n      if (inner)\n        return inner;\n      for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n        let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n        if (found2)\n          return found2;\n      }\n      return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc4) {\n      return findSelectionIn(doc4, doc4, 0, 0, 1) || new AllSelection(doc4);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc4) {\n      return findSelectionIn(doc4, doc4, doc4.content.size, doc4.childCount, -1) || new AllSelection(doc4);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc4, json) {\n      if (!json || !json.type)\n        throw new RangeError(\"Invalid input for Selection.fromJSON\");\n      let cls = classesById[json.type];\n      if (!cls)\n        throw new RangeError(`No selection type ${json.type} defined`);\n      return cls.fromJSON(doc4, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id2, selectionClass) {\n      if (id2 in classesById)\n        throw new RangeError(\"Duplicate use of selection JSON ID \" + id2);\n      classesById[id2] = selectionClass;\n      selectionClass.prototype.jsonID = id2;\n      return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n      return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n  };\n  Selection.prototype.visible = true;\n  var SelectionRange = class {\n    /**\n    Create a range.\n    */\n    constructor($from, $to) {\n      this.$from = $from;\n      this.$to = $to;\n    }\n  };\n  var warnedAboutTextSelection = false;\n  function checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n      warnedAboutTextSelection = true;\n      console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n    }\n  }\n  var TextSelection = class _TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n      checkTextSelection($anchor);\n      checkTextSelection($head);\n      super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() {\n      return this.$anchor.pos == this.$head.pos ? this.$head : null;\n    }\n    map(doc4, mapping) {\n      let $head = doc4.resolve(mapping.map(this.head));\n      if (!$head.parent.inlineContent)\n        return Selection.near($head);\n      let $anchor = doc4.resolve(mapping.map(this.anchor));\n      return new _TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = Slice.empty) {\n      super.replace(tr, content);\n      if (content == Slice.empty) {\n        let marks2 = this.$from.marksAcross(this.$to);\n        if (marks2)\n          tr.ensureMarks(marks2);\n      }\n    }\n    eq(other) {\n      return other instanceof _TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n      return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n      return { type: \"text\", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc4, json) {\n      if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n        throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n      return new _TextSelection(doc4.resolve(json.anchor), doc4.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc4, anchor, head = anchor) {\n      let $anchor = doc4.resolve(anchor);\n      return new this($anchor, head == anchor ? $anchor : doc4.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n      let dPos = $anchor.pos - $head.pos;\n      if (!bias || dPos)\n        bias = dPos >= 0 ? 1 : -1;\n      if (!$head.parent.inlineContent) {\n        let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n        if (found2)\n          $head = found2.$head;\n        else\n          return Selection.near($head, bias);\n      }\n      if (!$anchor.parent.inlineContent) {\n        if (dPos == 0) {\n          $anchor = $head;\n        } else {\n          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n          if ($anchor.pos < $head.pos != dPos < 0)\n            $anchor = $head;\n        }\n      }\n      return new _TextSelection($anchor, $head);\n    }\n  };\n  Selection.jsonID(\"text\", TextSelection);\n  var TextBookmark = class _TextBookmark {\n    constructor(anchor, head) {\n      this.anchor = anchor;\n      this.head = head;\n    }\n    map(mapping) {\n      return new _TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc4) {\n      return TextSelection.between(doc4.resolve(this.anchor), doc4.resolve(this.head));\n    }\n  };\n  var NodeSelection = class _NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n      let node = $pos.nodeAfter;\n      let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n      super($pos, $end);\n      this.node = node;\n    }\n    map(doc4, mapping) {\n      let { deleted, pos } = mapping.mapResult(this.anchor);\n      let $pos = doc4.resolve(pos);\n      if (deleted)\n        return Selection.near($pos);\n      return new _NodeSelection($pos);\n    }\n    content() {\n      return new Slice(Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n      return other instanceof _NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n      return { type: \"node\", anchor: this.anchor };\n    }\n    getBookmark() {\n      return new NodeBookmark(this.anchor);\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc4, json) {\n      if (typeof json.anchor != \"number\")\n        throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n      return new _NodeSelection(doc4.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc4, from4) {\n      return new _NodeSelection(doc4.resolve(from4));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n      return !node.isText && node.type.spec.selectable !== false;\n    }\n  };\n  NodeSelection.prototype.visible = false;\n  Selection.jsonID(\"node\", NodeSelection);\n  var NodeBookmark = class _NodeBookmark {\n    constructor(anchor) {\n      this.anchor = anchor;\n    }\n    map(mapping) {\n      let { deleted, pos } = mapping.mapResult(this.anchor);\n      return deleted ? new TextBookmark(pos, pos) : new _NodeBookmark(pos);\n    }\n    resolve(doc4) {\n      let $pos = doc4.resolve(this.anchor), node = $pos.nodeAfter;\n      if (node && NodeSelection.isSelectable(node))\n        return new NodeSelection($pos);\n      return Selection.near($pos);\n    }\n  };\n  var AllSelection = class _AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc4) {\n      super(doc4.resolve(0), doc4.resolve(doc4.content.size));\n    }\n    replace(tr, content = Slice.empty) {\n      if (content == Slice.empty) {\n        tr.delete(0, tr.doc.content.size);\n        let sel = Selection.atStart(tr.doc);\n        if (!sel.eq(tr.selection))\n          tr.setSelection(sel);\n      } else {\n        super.replace(tr, content);\n      }\n    }\n    toJSON() {\n      return { type: \"all\" };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc4) {\n      return new _AllSelection(doc4);\n    }\n    map(doc4) {\n      return new _AllSelection(doc4);\n    }\n    eq(other) {\n      return other instanceof _AllSelection;\n    }\n    getBookmark() {\n      return AllBookmark;\n    }\n  };\n  Selection.jsonID(\"all\", AllSelection);\n  var AllBookmark = {\n    map() {\n      return this;\n    },\n    resolve(doc4) {\n      return new AllSelection(doc4);\n    }\n  };\n  function findSelectionIn(doc4, node, pos, index, dir, text2 = false) {\n    if (node.inlineContent)\n      return TextSelection.create(doc4, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n      let child = node.child(i);\n      if (!child.isAtom) {\n        let inner = findSelectionIn(doc4, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text2);\n        if (inner)\n          return inner;\n      } else if (!text2 && NodeSelection.isSelectable(child)) {\n        return NodeSelection.create(doc4, pos - (dir < 0 ? child.nodeSize : 0));\n      }\n      pos += child.nodeSize * dir;\n    }\n    return null;\n  }\n  function selectionToInsertionEnd(tr, startLen, bias) {\n    let last2 = tr.steps.length - 1;\n    if (last2 < startLen)\n      return;\n    let step = tr.steps[last2];\n    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))\n      return;\n    let map3 = tr.mapping.maps[last2], end;\n    map3.forEach((_from, _to, _newFrom, newTo) => {\n      if (end == null)\n        end = newTo;\n    });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n  }\n  var UPDATED_SEL = 1;\n  var UPDATED_MARKS = 2;\n  var UPDATED_SCROLL = 4;\n  var Transaction = class extends Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n      super(state.doc);\n      this.curSelectionFor = 0;\n      this.updated = 0;\n      this.meta = /* @__PURE__ */ Object.create(null);\n      this.time = Date.now();\n      this.curSelection = state.selection;\n      this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction's current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n      if (this.curSelectionFor < this.steps.length) {\n        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n        this.curSelectionFor = this.steps.length;\n      }\n      return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n      if (selection.$from.doc != this.doc)\n        throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n      this.curSelection = selection;\n      this.curSelectionFor = this.steps.length;\n      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n      this.storedMarks = null;\n      return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n      return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks2) {\n      this.storedMarks = marks2;\n      this.updated |= UPDATED_MARKS;\n      return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks2) {\n      if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks2))\n        this.setStoredMarks(marks2);\n      return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n      return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc4) {\n      super.addStep(step, doc4);\n      this.updated = this.updated & ~UPDATED_MARKS;\n      this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n      this.time = time;\n      return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice2) {\n      this.selection.replace(this, slice2);\n      return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n      let selection = this.selection;\n      if (inheritMarks)\n        node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));\n      selection.replaceWith(this, node);\n      return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n      this.selection.replace(this);\n      return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text2, from4, to) {\n      let schema2 = this.doc.type.schema;\n      if (from4 == null) {\n        if (!text2)\n          return this.deleteSelection();\n        return this.replaceSelectionWith(schema2.text(text2), true);\n      } else {\n        if (to == null)\n          to = from4;\n        to = to == null ? from4 : to;\n        if (!text2)\n          return this.deleteRange(from4, to);\n        let marks2 = this.storedMarks;\n        if (!marks2) {\n          let $from = this.doc.resolve(from4);\n          marks2 = to == from4 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n        }\n        this.replaceRangeWith(from4, to, schema2.text(text2, marks2));\n        if (!this.selection.empty)\n          this.setSelection(Selection.near(this.selection.$to));\n        return this;\n      }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n      this.meta[typeof key == \"string\" ? key : key.key] = value;\n      return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n      return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n      for (let _ in this.meta)\n        return false;\n      return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n      this.updated |= UPDATED_SCROLL;\n      return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n      return (this.updated & UPDATED_SCROLL) > 0;\n    }\n  };\n  function bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n  }\n  var FieldDesc = class {\n    constructor(name, desc, self) {\n      this.name = name;\n      this.init = bind(desc.init, self);\n      this.apply = bind(desc.apply, self);\n    }\n  };\n  var baseFields = [\n    new FieldDesc(\"doc\", {\n      init(config) {\n        return config.doc || config.schema.topNodeType.createAndFill();\n      },\n      apply(tr) {\n        return tr.doc;\n      }\n    }),\n    new FieldDesc(\"selection\", {\n      init(config, instance) {\n        return config.selection || Selection.atStart(instance.doc);\n      },\n      apply(tr) {\n        return tr.selection;\n      }\n    }),\n    new FieldDesc(\"storedMarks\", {\n      init(config) {\n        return config.storedMarks || null;\n      },\n      apply(tr, _marks, _old, state) {\n        return state.selection.$cursor ? tr.storedMarks : null;\n      }\n    }),\n    new FieldDesc(\"scrollToSelection\", {\n      init() {\n        return 0;\n      },\n      apply(tr, prev) {\n        return tr.scrolledIntoView ? prev + 1 : prev;\n      }\n    })\n  ];\n  var Configuration = class {\n    constructor(schema2, plugins) {\n      this.schema = schema2;\n      this.plugins = [];\n      this.pluginsByKey = /* @__PURE__ */ Object.create(null);\n      this.fields = baseFields.slice();\n      if (plugins)\n        plugins.forEach((plugin) => {\n          if (this.pluginsByKey[plugin.key])\n            throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n          this.plugins.push(plugin);\n          this.pluginsByKey[plugin.key] = plugin;\n          if (plugin.spec.state)\n            this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n        });\n    }\n  };\n  var EditorState = class _EditorState {\n    /**\n    @internal\n    */\n    constructor(config) {\n      this.config = config;\n    }\n    /**\n    The schema of the state's document.\n    */\n    get schema() {\n      return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n      return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n      return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n    filterTransaction(tr, ignore = -1) {\n      for (let i = 0; i < this.config.plugins.length; i++)\n        if (i != ignore) {\n          let plugin = this.config.plugins[i];\n          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n            return false;\n        }\n      return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n      if (!this.filterTransaction(rootTr))\n        return { state: this, transactions: [] };\n      let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n      for (; ; ) {\n        let haveNew = false;\n        for (let i = 0; i < this.config.plugins.length; i++) {\n          let plugin = this.config.plugins[i];\n          if (plugin.spec.appendTransaction) {\n            let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n            let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n            if (tr && newState.filterTransaction(tr, i)) {\n              tr.setMeta(\"appendedTransaction\", rootTr);\n              if (!seen) {\n                seen = [];\n                for (let j = 0; j < this.config.plugins.length; j++)\n                  seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n              }\n              trs.push(tr);\n              newState = newState.applyInner(tr);\n              haveNew = true;\n            }\n            if (seen)\n              seen[i] = { state: newState, n: trs.length };\n          }\n        }\n        if (!haveNew)\n          return { state: newState, transactions: trs };\n      }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n      if (!tr.before.eq(this.doc))\n        throw new RangeError(\"Applying a mismatched transaction\");\n      let newInstance = new _EditorState(this.config), fields = this.config.fields;\n      for (let i = 0; i < fields.length; i++) {\n        let field = fields[i];\n        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n      }\n      return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() {\n      return new Transaction(this);\n    }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n      let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n      let instance = new _EditorState($config);\n      for (let i = 0; i < $config.fields.length; i++)\n        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n      return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n      let $config = new Configuration(this.schema, config.plugins);\n      let fields = $config.fields, instance = new _EditorState($config);\n      for (let i = 0; i < fields.length; i++) {\n        let name = fields[i].name;\n        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n      }\n      return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n      let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n      if (this.storedMarks)\n        result.storedMarks = this.storedMarks.map((m) => m.toJSON());\n      if (pluginFields && typeof pluginFields == \"object\")\n        for (let prop in pluginFields) {\n          if (prop == \"doc\" || prop == \"selection\")\n            throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n          let plugin = pluginFields[prop], state = plugin.spec.state;\n          if (state && state.toJSON)\n            result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n        }\n      return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n      if (!json)\n        throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n      if (!config.schema)\n        throw new RangeError(\"Required config field 'schema' missing\");\n      let $config = new Configuration(config.schema, config.plugins);\n      let instance = new _EditorState($config);\n      $config.fields.forEach((field) => {\n        if (field.name == \"doc\") {\n          instance.doc = Node.fromJSON(config.schema, json.doc);\n        } else if (field.name == \"selection\") {\n          instance.selection = Selection.fromJSON(instance.doc, json.selection);\n        } else if (field.name == \"storedMarks\") {\n          if (json.storedMarks)\n            instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n        } else {\n          if (pluginFields)\n            for (let prop in pluginFields) {\n              let plugin = pluginFields[prop], state = plugin.spec.state;\n              if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {\n                instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                return;\n              }\n            }\n          instance[field.name] = field.init(config, instance);\n        }\n      });\n      return instance;\n    }\n  };\n  function bindProps(obj, self, target) {\n    for (let prop in obj) {\n      let val = obj[prop];\n      if (val instanceof Function)\n        val = val.bind(self);\n      else if (prop == \"handleDOMEvents\")\n        val = bindProps(val, self, {});\n      target[prop] = val;\n    }\n    return target;\n  }\n  var Plugin = class {\n    /**\n    Create a plugin.\n    */\n    constructor(spec) {\n      this.spec = spec;\n      this.props = {};\n      if (spec.props)\n        bindProps(spec.props, this, this.props);\n      this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n    }\n    /**\n    Extract the plugin's state field from an editor state.\n    */\n    getState(state) {\n      return state[this.key];\n    }\n  };\n  var keys = /* @__PURE__ */ Object.create(null);\n  function createKey(name) {\n    if (name in keys)\n      return name + \"$\" + ++keys[name];\n    keys[name] = 0;\n    return name + \"$\";\n  }\n  var PluginKey = class {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = \"key\") {\n      this.key = createKey(name);\n    }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) {\n      return state.config.pluginsByKey[this.key];\n    }\n    /**\n    Get the plugin's state from an editor state.\n    */\n    getState(state) {\n      return state[this.key];\n    }\n  };\n\n  // node_modules/prosemirror-view/dist/index.js\n  var domIndex = function(node) {\n    for (var index = 0; ; index++) {\n      node = node.previousSibling;\n      if (!node)\n        return index;\n    }\n  };\n  var parentNode = function(node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n  };\n  var reusedRange = null;\n  var textRange = function(node, from4, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from4 || 0);\n    return range;\n  };\n  var clearReusedRange = function() {\n    reusedRange = null;\n  };\n  var isEquivalentPosition = function(node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));\n  };\n  var atomElements = /^(img|br|input|textarea|hr)$/i;\n  function scanFor(node, off, targetNode, targetOff, dir) {\n    var _a;\n    for (; ; ) {\n      if (node == targetNode && off == targetOff)\n        return true;\n      if (off == (dir < 0 ? 0 : nodeSize(node))) {\n        let parent = node.parentNode;\n        if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == \"false\")\n          return false;\n        off = domIndex(node) + (dir < 0 ? 0 : 1);\n        node = parent;\n      } else if (node.nodeType == 1) {\n        let child = node.childNodes[off + (dir < 0 ? -1 : 0)];\n        if (child.nodeType == 1 && child.contentEditable == \"false\") {\n          if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)\n            off += dir;\n          else\n            return false;\n        } else {\n          node = child;\n          off = dir < 0 ? nodeSize(node) : 0;\n        }\n      } else {\n        return false;\n      }\n    }\n  }\n  function nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n  }\n  function textNodeBefore$1(node, offset) {\n    for (; ; ) {\n      if (node.nodeType == 3 && offset)\n        return node;\n      if (node.nodeType == 1 && offset > 0) {\n        if (node.contentEditable == \"false\")\n          return null;\n        node = node.childNodes[offset - 1];\n        offset = nodeSize(node);\n      } else if (node.parentNode && !hasBlockDesc(node)) {\n        offset = domIndex(node);\n        node = node.parentNode;\n      } else {\n        return null;\n      }\n    }\n  }\n  function textNodeAfter$1(node, offset) {\n    for (; ; ) {\n      if (node.nodeType == 3 && offset < node.nodeValue.length)\n        return node;\n      if (node.nodeType == 1 && offset < node.childNodes.length) {\n        if (node.contentEditable == \"false\")\n          return null;\n        node = node.childNodes[offset];\n        offset = 0;\n      } else if (node.parentNode && !hasBlockDesc(node)) {\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n      } else {\n        return null;\n      }\n    }\n  }\n  function isOnEdge(node, offset, parent) {\n    for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd; ) {\n      if (node == parent)\n        return true;\n      let index = domIndex(node);\n      node = node.parentNode;\n      if (!node)\n        return false;\n      atStart = atStart && index == 0;\n      atEnd = atEnd && index == nodeSize(node);\n    }\n  }\n  function hasBlockDesc(dom) {\n    let desc;\n    for (let cur = dom; cur; cur = cur.parentNode)\n      if (desc = cur.pmViewDesc)\n        break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n  }\n  var selectionCollapsed = function(domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n  };\n  function keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n  }\n  function deepActiveElement(doc4) {\n    let elt = doc4.activeElement;\n    while (elt && elt.shadowRoot)\n      elt = elt.shadowRoot.activeElement;\n    return elt;\n  }\n  function caretFromPoint(doc4, x, y) {\n    if (doc4.caretPositionFromPoint) {\n      try {\n        let pos = doc4.caretPositionFromPoint(x, y);\n        if (pos)\n          return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };\n      } catch (_) {\n      }\n    }\n    if (doc4.caretRangeFromPoint) {\n      let range = doc4.caretRangeFromPoint(x, y);\n      if (range)\n        return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };\n    }\n  }\n  var nav = typeof navigator != \"undefined\" ? navigator : null;\n  var doc2 = typeof document != \"undefined\" ? document : null;\n  var agent = nav && nav.userAgent || \"\";\n  var ie_edge = /Edge\\/(\\d+)/.exec(agent);\n  var ie_upto10 = /MSIE \\d/.exec(agent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\n  var ie = !!(ie_upto10 || ie_11up || ie_edge);\n  var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\n  var gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\n  gecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\n  var _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\n  var chrome = !!_chrome;\n  var chrome_version = _chrome ? +_chrome[1] : 0;\n  var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n  var ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\n  var mac = ios || (nav ? /Mac/.test(nav.platform) : false);\n  var windows = nav ? /Win/.test(nav.platform) : false;\n  var android = /Android \\d/.test(agent);\n  var webkit = !!doc2 && \"webkitFontSmoothing\" in doc2.documentElement.style;\n  var webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\n  function windowRect(doc4) {\n    let vp = doc4.defaultView && doc4.defaultView.visualViewport;\n    if (vp)\n      return {\n        left: 0,\n        right: vp.width,\n        top: 0,\n        bottom: vp.height\n      };\n    return {\n      left: 0,\n      right: doc4.documentElement.clientWidth,\n      top: 0,\n      bottom: doc4.documentElement.clientHeight\n    };\n  }\n  function getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n  }\n  function clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    let scaleX = rect.width / node.offsetWidth || 1;\n    let scaleY = rect.height / node.offsetHeight || 1;\n    return {\n      left: rect.left,\n      right: rect.left + node.clientWidth * scaleX,\n      top: rect.top,\n      bottom: rect.top + node.clientHeight * scaleY\n    };\n  }\n  function scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc4 = view.dom.ownerDocument;\n    for (let parent = startDOM || view.dom; ; ) {\n      if (!parent)\n        break;\n      if (parent.nodeType != 1) {\n        parent = parentNode(parent);\n        continue;\n      }\n      let elt = parent;\n      let atTop = elt == doc4.body;\n      let bounding = atTop ? windowRect(doc4) : clientRect(elt);\n      let moveX = 0, moveY = 0;\n      if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n        moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n      else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n        moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, \"top\") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n      if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n        moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n      else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n        moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n      if (moveX || moveY) {\n        if (atTop) {\n          doc4.defaultView.scrollBy(moveX, moveY);\n        } else {\n          let startX = elt.scrollLeft, startY = elt.scrollTop;\n          if (moveY)\n            elt.scrollTop += moveY;\n          if (moveX)\n            elt.scrollLeft += moveX;\n          let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n          rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n        }\n      }\n      let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n      if (/^(fixed|sticky)$/.test(pos))\n        break;\n      parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n    }\n  }\n  function storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n      let dom = view.root.elementFromPoint(x, y);\n      if (!dom || dom == view.dom || !view.dom.contains(dom))\n        continue;\n      let localRect = dom.getBoundingClientRect();\n      if (localRect.top >= startY - 20) {\n        refDOM = dom;\n        refTop = localRect.top;\n        break;\n      }\n    }\n    return { refDOM, refTop, stack: scrollStack(view.dom) };\n  }\n  function scrollStack(dom) {\n    let stack = [], doc4 = dom.ownerDocument;\n    for (let cur = dom; cur; cur = parentNode(cur)) {\n      stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n      if (dom == doc4)\n        break;\n    }\n    return stack;\n  }\n  function resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n  }\n  function restoreScrollStack(stack, dTop) {\n    for (let i = 0; i < stack.length; i++) {\n      let { dom, top, left } = stack[i];\n      if (dom.scrollTop != top + dTop)\n        dom.scrollTop = top + dTop;\n      if (dom.scrollLeft != left)\n        dom.scrollLeft = left;\n    }\n  }\n  var preventScrollSupported = null;\n  function focusPreventScroll(dom) {\n    if (dom.setActive)\n      return dom.setActive();\n    if (preventScrollSupported)\n      return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n      get preventScroll() {\n        preventScrollSupported = { preventScroll: true };\n        return true;\n      }\n    } : void 0);\n    if (!preventScrollSupported) {\n      preventScrollSupported = false;\n      restoreScrollStack(stored, 0);\n    }\n  }\n  function findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n      let rects;\n      if (child.nodeType == 1)\n        rects = child.getClientRects();\n      else if (child.nodeType == 3)\n        rects = textRange(child).getClientRects();\n      else\n        continue;\n      for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        if (rect.top <= rowBot && rect.bottom >= rowTop) {\n          rowBot = Math.max(rect.bottom, rowBot);\n          rowTop = Math.min(rect.top, rowTop);\n          let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;\n          if (dx < dxClosest) {\n            closest = child;\n            dxClosest = dx;\n            coordsClosest = dx && closest.nodeType == 3 ? {\n              left: rect.right < coords.left ? rect.right : rect.left,\n              top: coords.top\n            } : coords;\n            if (child.nodeType == 1 && dx)\n              offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n            continue;\n          }\n        } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n          firstBelow = child;\n          coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };\n        }\n        if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))\n          offset = childIndex + 1;\n      }\n    }\n    if (!closest && firstBelow) {\n      closest = firstBelow;\n      coordsClosest = coordsBelow;\n      dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3)\n      return findOffsetInText(closest, coordsClosest);\n    if (!closest || dxClosest && closest.nodeType == 1)\n      return { node, offset };\n    return findOffsetInNode(closest, coordsClosest);\n  }\n  function findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for (let i = 0; i < len; i++) {\n      range.setEnd(node, i + 1);\n      range.setStart(node, i);\n      let rect = singleRect(range, 1);\n      if (rect.top == rect.bottom)\n        continue;\n      if (inRect(coords, rect))\n        return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n    }\n    return { node, offset: 0 };\n  }\n  function inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n  }\n  function targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n      return parent;\n    return dom;\n  }\n  function posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n      let rect = node.getBoundingClientRect();\n      bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n  }\n  function posFromCaret(view, node, offset, coords) {\n    let outsideBlock = -1;\n    for (let cur = node, sawBlock = false; ; ) {\n      if (cur == view.dom)\n        break;\n      let desc = view.docView.nearestDesc(cur, true), rect;\n      if (!desc)\n        return null;\n      if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles\n      ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n        if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {\n          if (!sawBlock && rect.left > coords.left || rect.top > coords.top)\n            outsideBlock = desc.posBefore;\n          else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)\n            outsideBlock = desc.posAfter;\n          sawBlock = true;\n        }\n        if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n          let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;\n          return before ? desc.posBefore : desc.posAfter;\n        }\n      }\n      cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n  }\n  function elementFromPoint(element2, coords, box) {\n    let len = element2.childNodes.length;\n    if (len && box.top < box.bottom) {\n      for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {\n        let child = element2.childNodes[i];\n        if (child.nodeType == 1) {\n          let rects = child.getClientRects();\n          for (let j = 0; j < rects.length; j++) {\n            let rect = rects[j];\n            if (inRect(coords, rect))\n              return elementFromPoint(child, coords, rect);\n          }\n        }\n        if ((i = (i + 1) % len) == startI)\n          break;\n      }\n    }\n    return element2;\n  }\n  function posAtCoords(view, coords) {\n    let doc4 = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc4, coords.left, coords.top);\n    if (caret)\n      ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc4).elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n      let box = view.dom.getBoundingClientRect();\n      if (!inRect(coords, box))\n        return null;\n      elt = elementFromPoint(view.dom, coords, box);\n      if (!elt)\n        return null;\n    }\n    if (safari) {\n      for (let p = elt; node && p; p = parentNode(p))\n        if (p.draggable)\n          node = void 0;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n      if (gecko && node.nodeType == 1) {\n        offset = Math.min(offset, node.childNodes.length);\n        if (offset < node.childNodes.length) {\n          let next = node.childNodes[offset], box;\n          if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)\n            offset++;\n        }\n      }\n      let prev;\n      if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top)\n        offset--;\n      if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)\n        pos = view.state.doc.content.size;\n      else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n        pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null)\n      pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n  }\n  function nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n  }\n  function singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n      let first = rects[bias < 0 ? 0 : rects.length - 1];\n      if (nonZero(first))\n        return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n  }\n  var BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n  function coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n      if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n        let rect = singleRect(textRange(node, offset, offset), side);\n        if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n          let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n          if (rectBefore.top == rect.top) {\n            let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n            if (rectAfter.top != rect.top)\n              return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n          }\n        }\n        return rect;\n      } else {\n        let from4 = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n        if (side < 0 && !offset) {\n          to++;\n          takeSide = -1;\n        } else if (side >= 0 && offset == node.nodeValue.length) {\n          from4--;\n          takeSide = 1;\n        } else if (side < 0) {\n          from4--;\n        } else {\n          to++;\n        }\n        return flattenV(singleRect(textRange(node, from4, to), takeSide), takeSide < 0);\n      }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    if (!$dom.parent.inlineContent) {\n      if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        if (before.nodeType == 1)\n          return flattenH(before.getBoundingClientRect(), false);\n      }\n      if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        if (after.nodeType == 1)\n          return flattenH(after.getBoundingClientRect(), true);\n      }\n      return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n      let before = node.childNodes[offset - 1];\n      let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n      if (target)\n        return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n      let after = node.childNodes[offset];\n      while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n        after = after.nextSibling;\n      let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;\n      if (target)\n        return flattenV(singleRect(target, -1), true);\n    }\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n  }\n  function flattenV(rect, left) {\n    if (rect.width == 0)\n      return rect;\n    let x = left ? rect.left : rect.right;\n    return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n  }\n  function flattenH(rect, top) {\n    if (rect.height == 0)\n      return rect;\n    let y = top ? rect.top : rect.bottom;\n    return { top: y, bottom: y, left: rect.left, right: rect.right };\n  }\n  function withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state)\n      view.updateState(state);\n    if (active != view.dom)\n      view.focus();\n    try {\n      return f();\n    } finally {\n      if (viewState != state)\n        view.updateState(viewState);\n      if (active != view.dom && active)\n        active.focus();\n    }\n  }\n  function endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, () => {\n      let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n      for (; ; ) {\n        let nearest = view.docView.nearestDesc(dom, true);\n        if (!nearest)\n          break;\n        if (nearest.node.isBlock) {\n          dom = nearest.contentDOM || nearest.dom;\n          break;\n        }\n        dom = nearest.dom.parentNode;\n      }\n      let coords = coordsAtPos(view, $pos.pos, 1);\n      for (let child = dom.firstChild; child; child = child.nextSibling) {\n        let boxes;\n        if (child.nodeType == 1)\n          boxes = child.getClientRects();\n        else if (child.nodeType == 3)\n          boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n        else\n          continue;\n        for (let i = 0; i < boxes.length; i++) {\n          let box = boxes[i];\n          if (box.bottom > box.top + 1 && (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n            return false;\n        }\n      }\n      return true;\n    });\n  }\n  var maybeRTL = /[\\u0590-\\u08ac]/;\n  function endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock)\n      return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    if (!sel)\n      return $head.pos == $head.start() || $head.pos == $head.end();\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n      return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, () => {\n      let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n      let oldBidiLevel = sel.caretBidiLevel;\n      sel.modify(\"move\", dir, \"character\");\n      let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n      let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n      let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;\n      try {\n        sel.collapse(anchorNode, anchorOffset);\n        if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n          sel.extend(oldNode, oldOff);\n      } catch (_) {\n      }\n      if (oldBidiLevel != null)\n        sel.caretBidiLevel = oldBidiLevel;\n      return result;\n    });\n  }\n  var cachedState = null;\n  var cachedDir = null;\n  var cachedResult = false;\n  function endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir)\n      return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);\n  }\n  var NOT_DIRTY = 0;\n  var CHILD_DIRTY = 1;\n  var CONTENT_DIRTY = 2;\n  var NODE_DIRTY = 3;\n  var ViewDesc = class {\n    constructor(parent, children, dom, contentDOM) {\n      this.parent = parent;\n      this.children = children;\n      this.dom = dom;\n      this.contentDOM = contentDOM;\n      this.dirty = NOT_DIRTY;\n      dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) {\n      return false;\n    }\n    matchesMark(mark) {\n      return false;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n      return false;\n    }\n    matchesHack(nodeName) {\n      return false;\n    }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() {\n      return null;\n    }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) {\n      return false;\n    }\n    // The size of the content represented by this desc.\n    get size() {\n      let size2 = 0;\n      for (let i = 0; i < this.children.length; i++)\n        size2 += this.children[i].size;\n      return size2;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() {\n      return 0;\n    }\n    destroy() {\n      this.parent = void 0;\n      if (this.dom.pmViewDesc == this)\n        this.dom.pmViewDesc = void 0;\n      for (let i = 0; i < this.children.length; i++)\n        this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n      for (let i = 0, pos = this.posAtStart; ; i++) {\n        let cur = this.children[i];\n        if (cur == child)\n          return pos;\n        pos += cur.size;\n      }\n    }\n    get posBefore() {\n      return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n      return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n      return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n        if (bias < 0) {\n          let domBefore, desc;\n          if (dom == this.contentDOM) {\n            domBefore = dom.childNodes[offset - 1];\n          } else {\n            while (dom.parentNode != this.contentDOM)\n              dom = dom.parentNode;\n            domBefore = dom.previousSibling;\n          }\n          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n            domBefore = domBefore.previousSibling;\n          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n        } else {\n          let domAfter, desc;\n          if (dom == this.contentDOM) {\n            domAfter = dom.childNodes[offset];\n          } else {\n            while (dom.parentNode != this.contentDOM)\n              dom = dom.parentNode;\n            domAfter = dom.nextSibling;\n          }\n          while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n            domAfter = domAfter.nextSibling;\n          return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n        }\n      }\n      let atEnd;\n      if (dom == this.dom && this.contentDOM) {\n        atEnd = offset > domIndex(this.contentDOM);\n      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n      } else if (this.dom.firstChild) {\n        if (offset == 0)\n          for (let search = dom; ; search = search.parentNode) {\n            if (search == this.dom) {\n              atEnd = false;\n              break;\n            }\n            if (search.previousSibling)\n              break;\n          }\n        if (atEnd == null && offset == dom.childNodes.length)\n          for (let search = dom; ; search = search.parentNode) {\n            if (search == this.dom) {\n              atEnd = true;\n              break;\n            }\n            if (search.nextSibling)\n              break;\n          }\n      }\n      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n      for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n        let desc = this.getDesc(cur), nodeDOM;\n        if (desc && (!onlyNodes || desc.node)) {\n          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n            first = false;\n          else\n            return desc;\n        }\n      }\n    }\n    getDesc(dom) {\n      let desc = dom.pmViewDesc;\n      for (let cur = desc; cur; cur = cur.parent)\n        if (cur == this)\n          return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n      for (let scan = dom; scan; scan = scan.parentNode) {\n        let desc = this.getDesc(scan);\n        if (desc)\n          return desc.localPosFromDOM(dom, offset, bias);\n      }\n      return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n      for (let i = 0, offset = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (offset == pos && end != offset) {\n          while (!child.border && child.children.length) {\n            for (let i2 = 0; i2 < child.children.length; i2++) {\n              let inner = child.children[i2];\n              if (inner.size) {\n                child = inner;\n                break;\n              }\n            }\n          }\n          return child;\n        }\n        if (pos < end)\n          return child.descAt(pos - offset - child.border);\n        offset = end;\n      }\n    }\n    domFromPos(pos, side) {\n      if (!this.contentDOM)\n        return { node: this.dom, offset: 0, atom: pos + 1 };\n      let i = 0, offset = 0;\n      for (let curPos = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = curPos + child.size;\n        if (end > pos || child instanceof TrailingHackViewDesc) {\n          offset = pos - curPos;\n          break;\n        }\n        curPos = end;\n      }\n      if (offset)\n        return this.children[i].domFromPos(offset - this.children[i].border, side);\n      for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {\n      }\n      if (side <= 0) {\n        let prev, enter = true;\n        for (; ; i--, enter = false) {\n          prev = i ? this.children[i - 1] : null;\n          if (!prev || prev.dom.parentNode == this.contentDOM)\n            break;\n        }\n        if (prev && side && enter && !prev.border && !prev.domAtom)\n          return prev.domFromPos(prev.size, side);\n        return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n      } else {\n        let next, enter = true;\n        for (; ; i++, enter = false) {\n          next = i < this.children.length ? this.children[i] : null;\n          if (!next || next.dom.parentNode == this.contentDOM)\n            break;\n        }\n        if (next && enter && !next.border && !next.domAtom)\n          return next.domFromPos(0, side);\n        return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n      }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from4, to, base2 = 0) {\n      if (this.children.length == 0)\n        return { node: this.contentDOM, from: from4, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n      let fromOffset = -1, toOffset = -1;\n      for (let offset = base2, i = 0; ; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (fromOffset == -1 && from4 <= end) {\n          let childBase = offset + child.border;\n          if (from4 >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))\n            return child.parseRange(from4, to, childBase);\n          from4 = offset;\n          for (let j = i; j > 0; j--) {\n            let prev = this.children[j - 1];\n            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n              fromOffset = domIndex(prev.dom) + 1;\n              break;\n            }\n            from4 -= prev.size;\n          }\n          if (fromOffset == -1)\n            fromOffset = 0;\n        }\n        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n          to = end;\n          for (let j = i + 1; j < this.children.length; j++) {\n            let next = this.children[j];\n            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n              toOffset = domIndex(next.dom);\n              break;\n            }\n            to += next.size;\n          }\n          if (toOffset == -1)\n            toOffset = this.contentDOM.childNodes.length;\n          break;\n        }\n        offset = end;\n      }\n      return { node: this.contentDOM, from: from4, to, fromOffset, toOffset };\n    }\n    emptyChildAt(side) {\n      if (this.border || !this.contentDOM || !this.children.length)\n        return false;\n      let child = this.children[side < 0 ? 0 : this.children.length - 1];\n      return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n      let { node, offset } = this.domFromPos(pos, 0);\n      if (node.nodeType != 1 || offset == node.childNodes.length)\n        throw new RangeError(\"No node after pos \" + pos);\n      return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, view, force = false) {\n      let from4 = Math.min(anchor, head), to = Math.max(anchor, head);\n      for (let i = 0, offset = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (from4 > offset && to < end)\n          return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n        offset = end;\n      }\n      let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n      let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n      let domSel = view.root.getSelection();\n      let selRange = view.domSelectionRange();\n      let brKludge = false;\n      if ((gecko || safari) && anchor == head) {\n        let { node, offset } = anchorDOM;\n        if (node.nodeType == 3) {\n          brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n          if (brKludge && offset == node.nodeValue.length) {\n            for (let scan = node, after; scan; scan = scan.parentNode) {\n              if (after = scan.nextSibling) {\n                if (after.nodeName == \"BR\")\n                  anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n                break;\n              }\n              let desc = scan.pmViewDesc;\n              if (desc && desc.node && desc.node.isBlock)\n                break;\n            }\n          }\n        } else {\n          let prev = node.childNodes[offset - 1];\n          brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n        }\n      }\n      if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n        let after = selRange.focusNode.childNodes[selRange.focusOffset];\n        if (after && after.contentEditable == \"false\")\n          force = true;\n      }\n      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))\n        return;\n      let domSelExtended = false;\n      if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {\n        domSel.collapse(anchorDOM.node, anchorDOM.offset);\n        try {\n          if (anchor != head)\n            domSel.extend(headDOM.node, headDOM.offset);\n          domSelExtended = true;\n        } catch (_) {\n        }\n      }\n      if (!domSelExtended) {\n        if (anchor > head) {\n          let tmp = anchorDOM;\n          anchorDOM = headDOM;\n          headDOM = tmp;\n        }\n        let range = document.createRange();\n        range.setEnd(headDOM.node, headDOM.offset);\n        range.setStart(anchorDOM.node, anchorDOM.offset);\n        domSel.removeAllRanges();\n        domSel.addRange(range);\n      }\n    }\n    ignoreMutation(mutation) {\n      return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from4, to) {\n      for (let offset = 0, i = 0; i < this.children.length; i++) {\n        let child = this.children[i], end = offset + child.size;\n        if (offset == end ? from4 <= end && to >= offset : from4 < end && to > offset) {\n          let startInside = offset + child.border, endInside = end - child.border;\n          if (from4 >= startInside && to <= endInside) {\n            this.dirty = from4 == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (from4 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))\n              child.dirty = NODE_DIRTY;\n            else\n              child.markDirty(from4 - startInside, to - startInside);\n            return;\n          } else {\n            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;\n          }\n        }\n        offset = end;\n      }\n      this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n      let level = 1;\n      for (let node = this.parent; node; node = node.parent, level++) {\n        let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n        if (node.dirty < dirty)\n          node.dirty = dirty;\n      }\n    }\n    get domAtom() {\n      return false;\n    }\n    get ignoreForCoords() {\n      return false;\n    }\n    get ignoreForSelection() {\n      return false;\n    }\n    isText(text2) {\n      return false;\n    }\n  };\n  var WidgetViewDesc = class extends ViewDesc {\n    constructor(parent, widget, view, pos) {\n      let self, dom = widget.type.toDOM;\n      if (typeof dom == \"function\")\n        dom = dom(view, () => {\n          if (!self)\n            return pos;\n          if (self.parent)\n            return self.parent.posBeforeChild(self);\n        });\n      if (!widget.type.spec.raw) {\n        if (dom.nodeType != 1) {\n          let wrap2 = document.createElement(\"span\");\n          wrap2.appendChild(dom);\n          dom = wrap2;\n        }\n        dom.contentEditable = \"false\";\n        dom.classList.add(\"ProseMirror-widget\");\n      }\n      super(parent, [], dom, null);\n      this.widget = widget;\n      this.widget = widget;\n      self = this;\n    }\n    matchesWidget(widget) {\n      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() {\n      return { ignore: true };\n    }\n    stopEvent(event) {\n      let stop = this.widget.spec.stopEvent;\n      return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n      return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n      this.widget.type.destroy(this.dom);\n      super.destroy();\n    }\n    get domAtom() {\n      return true;\n    }\n    get ignoreForSelection() {\n      return !!this.widget.type.spec.relaxedSide;\n    }\n    get side() {\n      return this.widget.type.side;\n    }\n  };\n  var CompositionViewDesc = class extends ViewDesc {\n    constructor(parent, dom, textDOM, text2) {\n      super(parent, [], dom, null);\n      this.textDOM = textDOM;\n      this.text = text2;\n    }\n    get size() {\n      return this.text.length;\n    }\n    localPosFromDOM(dom, offset) {\n      if (dom != this.textDOM)\n        return this.posAtStart + (offset ? this.size : 0);\n      return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n      return { node: this.textDOM, offset: pos };\n    }\n    ignoreMutation(mut) {\n      return mut.type === \"characterData\" && mut.target.nodeValue == mut.oldValue;\n    }\n  };\n  var MarkViewDesc = class _MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM, spec) {\n      super(parent, [], dom, contentDOM);\n      this.mark = mark;\n      this.spec = spec;\n    }\n    static create(parent, mark, inline, view) {\n      let custom = view.nodeViews[mark.type.name];\n      let spec = custom && custom(mark, view, inline);\n      if (!spec || !spec.dom)\n        spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n      return new _MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n    }\n    parseRule() {\n      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)\n        return null;\n      return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };\n    }\n    matchesMark(mark) {\n      return this.dirty != NODE_DIRTY && this.mark.eq(mark);\n    }\n    markDirty(from4, to) {\n      super.markDirty(from4, to);\n      if (this.dirty != NOT_DIRTY) {\n        let parent = this.parent;\n        while (!parent.node)\n          parent = parent.parent;\n        if (parent.dirty < this.dirty)\n          parent.dirty = this.dirty;\n        this.dirty = NOT_DIRTY;\n      }\n    }\n    slice(from4, to, view) {\n      let copy3 = _MarkViewDesc.create(this.parent, this.mark, true, view);\n      let nodes2 = this.children, size2 = this.size;\n      if (to < size2)\n        nodes2 = replaceNodes(nodes2, to, size2, view);\n      if (from4 > 0)\n        nodes2 = replaceNodes(nodes2, 0, from4, view);\n      for (let i = 0; i < nodes2.length; i++)\n        nodes2[i].parent = copy3;\n      copy3.children = nodes2;\n      return copy3;\n    }\n    ignoreMutation(mutation) {\n      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n    destroy() {\n      if (this.spec.destroy)\n        this.spec.destroy();\n      super.destroy();\n    }\n  };\n  var NodeViewDesc = class _NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n      super(parent, [], dom, contentDOM);\n      this.node = node;\n      this.outerDeco = outerDeco;\n      this.innerDeco = innerDeco;\n      this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n      let custom = view.nodeViews[node.type.name], descObj;\n      let spec = custom && custom(node, view, () => {\n        if (!descObj)\n          return pos;\n        if (descObj.parent)\n          return descObj.parent.posBeforeChild(descObj);\n      }, outerDeco, innerDeco);\n      let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n      if (node.isText) {\n        if (!dom)\n          dom = document.createTextNode(node.text);\n        else if (dom.nodeType != 3)\n          throw new RangeError(\"Text must be rendered as a DOM text node\");\n      } else if (!dom) {\n        let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n        ({ dom, contentDOM } = spec2);\n      }\n      if (!contentDOM && !node.isText && dom.nodeName != \"BR\") {\n        if (!dom.hasAttribute(\"contenteditable\"))\n          dom.contentEditable = \"false\";\n        if (node.type.spec.draggable)\n          dom.draggable = true;\n      }\n      let nodeDOM = dom;\n      dom = applyOuterDeco(dom, outerDeco, node);\n      if (spec)\n        return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n      else if (node.isText)\n        return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n      else\n        return new _NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n      if (this.node.type.spec.reparseInView)\n        return null;\n      let rule = { node: this.node.type.name, attrs: this.node.attrs };\n      if (this.node.type.whitespace == \"pre\")\n        rule.preserveWhitespace = \"full\";\n      if (!this.contentDOM) {\n        rule.getContent = () => this.node.content;\n      } else if (!this.contentLost) {\n        rule.contentElement = this.contentDOM;\n      } else {\n        for (let i = this.children.length - 1; i >= 0; i--) {\n          let child = this.children[i];\n          if (this.dom.contains(child.dom.parentNode)) {\n            rule.contentElement = child.dom.parentNode;\n            break;\n          }\n        }\n        if (!rule.contentElement)\n          rule.getContent = () => Fragment.empty;\n      }\n      return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() {\n      return this.node.nodeSize;\n    }\n    get border() {\n      return this.node.isLeaf ? 0 : 1;\n    }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n      let inline = this.node.inlineContent, off = pos;\n      let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n      let localComposition = composition && composition.pos > -1 ? composition : null;\n      let compositionInChild = composition && composition.pos < 0;\n      let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n      iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n        if (widget.spec.marks)\n          updater.syncToMarks(widget.spec.marks, inline, view);\n        else if (widget.type.side >= 0 && !insideNode)\n          updater.syncToMarks(i == this.node.childCount ? Mark.none : this.node.child(i).marks, inline, view);\n        updater.placeWidget(widget, view, off);\n      }, (child, outerDeco, innerDeco, i) => {\n        updater.syncToMarks(child.marks, inline, view);\n        let compIndex;\n        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n        else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n        else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n        else {\n          updater.addNode(child, outerDeco, innerDeco, view, off);\n        }\n        off += child.nodeSize;\n      });\n      updater.syncToMarks([], inline, view);\n      if (this.node.isTextblock)\n        updater.addTextblockHacks();\n      updater.destroyRest();\n      if (updater.changed || this.dirty == CONTENT_DIRTY) {\n        if (localComposition)\n          this.protectLocalComposition(view, localComposition);\n        renderDescs(this.contentDOM, this.children, view);\n        if (ios)\n          iosHacks(this.dom);\n      }\n    }\n    localCompositionInfo(view, pos) {\n      let { from: from4, to } = view.state.selection;\n      if (!(view.state.selection instanceof TextSelection) || from4 < pos || to > pos + this.node.content.size)\n        return null;\n      let textNode = view.input.compositionNode;\n      if (!textNode || !this.dom.contains(textNode.parentNode))\n        return null;\n      if (this.node.inlineContent) {\n        let text2 = textNode.nodeValue;\n        let textPos = findTextInFragment(this.node.content, text2, from4 - pos, to - pos);\n        return textPos < 0 ? null : { node: textNode, pos: textPos, text: text2 };\n      } else {\n        return { node: textNode, pos: -1, text: \"\" };\n      }\n    }\n    protectLocalComposition(view, { node, pos, text: text2 }) {\n      if (this.getDesc(node))\n        return;\n      let topNode = node;\n      for (; ; topNode = topNode.parentNode) {\n        if (topNode.parentNode == this.contentDOM)\n          break;\n        while (topNode.previousSibling)\n          topNode.parentNode.removeChild(topNode.previousSibling);\n        while (topNode.nextSibling)\n          topNode.parentNode.removeChild(topNode.nextSibling);\n        if (topNode.pmViewDesc)\n          topNode.pmViewDesc = void 0;\n      }\n      let desc = new CompositionViewDesc(this, topNode, node, text2);\n      view.input.compositionNodes.push(desc);\n      this.children = replaceNodes(this.children, pos, pos + text2.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))\n        return false;\n      this.updateInner(node, outerDeco, innerDeco, view);\n      return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n      this.updateOuterDeco(outerDeco);\n      this.node = node;\n      this.innerDeco = innerDeco;\n      if (this.contentDOM)\n        this.updateChildren(view, this.posAtStart);\n      this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n      if (sameOuterDeco(outerDeco, this.outerDeco))\n        return;\n      let needsWrap = this.nodeDOM.nodeType != 1;\n      let oldDOM = this.dom;\n      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n      if (this.dom != oldDOM) {\n        oldDOM.pmViewDesc = void 0;\n        this.dom.pmViewDesc = this;\n      }\n      this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n      if (this.nodeDOM.nodeType == 1) {\n        this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n          this.nodeDOM.draggable = true;\n      }\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n      if (this.nodeDOM.nodeType == 1) {\n        this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n        if (this.contentDOM || !this.node.type.spec.draggable)\n          this.nodeDOM.removeAttribute(\"draggable\");\n      }\n    }\n    get domAtom() {\n      return this.node.isAtom;\n    }\n  };\n  function docViewDesc(doc4, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc4);\n    let docView = new NodeViewDesc(void 0, doc4, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM)\n      docView.updateChildren(view, 0);\n    return docView;\n  }\n  var TextViewDesc = class _TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n      super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n      let skip = this.nodeDOM.parentNode;\n      while (skip && skip != this.dom && !skip.pmIsDeco)\n        skip = skip.parentNode;\n      return { skip: skip || true };\n    }\n    update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))\n        return false;\n      this.updateOuterDeco(outerDeco);\n      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n        this.nodeDOM.nodeValue = node.text;\n        if (view.trackWrites == this.nodeDOM)\n          view.trackWrites = null;\n      }\n      this.node = node;\n      this.dirty = NOT_DIRTY;\n      return true;\n    }\n    inParent() {\n      let parentDOM = this.parent.contentDOM;\n      for (let n = this.nodeDOM; n; n = n.parentNode)\n        if (n == parentDOM)\n          return true;\n      return false;\n    }\n    domFromPos(pos) {\n      return { node: this.nodeDOM, offset: pos };\n    }\n    localPosFromDOM(dom, offset, bias) {\n      if (dom == this.nodeDOM)\n        return this.posAtStart + Math.min(offset, this.node.text.length);\n      return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n      return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from4, to, view) {\n      let node = this.node.cut(from4, to), dom = document.createTextNode(node.text);\n      return new _TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from4, to) {\n      super.markDirty(from4, to);\n      if (this.dom != this.nodeDOM && (from4 == 0 || to == this.nodeDOM.nodeValue.length))\n        this.dirty = NODE_DIRTY;\n    }\n    get domAtom() {\n      return false;\n    }\n    isText(text2) {\n      return this.node.text == text2;\n    }\n  };\n  var TrailingHackViewDesc = class extends ViewDesc {\n    parseRule() {\n      return { ignore: true };\n    }\n    matchesHack(nodeName) {\n      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;\n    }\n    get domAtom() {\n      return true;\n    }\n    get ignoreForCoords() {\n      return this.dom.nodeName == \"IMG\";\n    }\n  };\n  var CustomNodeViewDesc = class extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n      super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n      this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n      if (this.dirty == NODE_DIRTY)\n        return false;\n      if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n        let result = this.spec.update(node, outerDeco, innerDeco);\n        if (result)\n          this.updateInner(node, outerDeco, innerDeco, view);\n        return result;\n      } else if (!this.contentDOM && !node.isLeaf) {\n        return false;\n      } else {\n        return super.update(node, outerDeco, innerDeco, view);\n      }\n    }\n    selectNode() {\n      this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n      this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, view, force) {\n      this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);\n    }\n    destroy() {\n      if (this.spec.destroy)\n        this.spec.destroy();\n      super.destroy();\n    }\n    stopEvent(event) {\n      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n  };\n  function renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for (let i = 0; i < descs.length; i++) {\n      let desc = descs[i], childDOM = desc.dom;\n      if (childDOM.parentNode == parentDOM) {\n        while (childDOM != dom) {\n          dom = rm(dom);\n          written = true;\n        }\n        dom = dom.nextSibling;\n      } else {\n        written = true;\n        parentDOM.insertBefore(childDOM, dom);\n      }\n      if (desc instanceof MarkViewDesc) {\n        let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n        renderDescs(desc.contentDOM, desc.children, view);\n        dom = pos ? pos.nextSibling : parentDOM.firstChild;\n      }\n    }\n    while (dom) {\n      dom = rm(dom);\n      written = true;\n    }\n    if (written && view.trackWrites == parentDOM)\n      view.trackWrites = null;\n  }\n  var OuterDecoLevel = function(nodeName) {\n    if (nodeName)\n      this.nodeName = nodeName;\n  };\n  OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);\n  var noDeco = [new OuterDecoLevel()];\n  function computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0)\n      return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top];\n    for (let i = 0; i < outerDeco.length; i++) {\n      let attrs = outerDeco[i].type.attrs;\n      if (!attrs)\n        continue;\n      if (attrs.nodeName)\n        result.push(top = new OuterDecoLevel(attrs.nodeName));\n      for (let name in attrs) {\n        let val = attrs[name];\n        if (val == null)\n          continue;\n        if (needsWrap && result.length == 1)\n          result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n        if (name == \"class\")\n          top.class = (top.class ? top.class + \" \" : \"\") + val;\n        else if (name == \"style\")\n          top.style = (top.style ? top.style + \";\" : \"\") + val;\n        else if (name != \"nodeName\")\n          top[name] = val;\n      }\n    }\n    return result;\n  }\n  function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    if (prevComputed == noDeco && curComputed == noDeco)\n      return nodeDOM;\n    let curDOM = nodeDOM;\n    for (let i = 0; i < curComputed.length; i++) {\n      let deco = curComputed[i], prev = prevComputed[i];\n      if (i) {\n        let parent;\n        if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n          curDOM = parent;\n        } else {\n          parent = document.createElement(deco.nodeName);\n          parent.pmIsDeco = true;\n          parent.appendChild(curDOM);\n          prev = noDeco[0];\n          curDOM = parent;\n        }\n      }\n      patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n  }\n  function patchAttributes(dom, prev, cur) {\n    for (let name in prev)\n      if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n        dom.removeAttribute(name);\n    for (let name in cur)\n      if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n        dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n      let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n      let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n      for (let i = 0; i < prevList.length; i++)\n        if (curList.indexOf(prevList[i]) == -1)\n          dom.classList.remove(prevList[i]);\n      for (let i = 0; i < curList.length; i++)\n        if (prevList.indexOf(curList[i]) == -1)\n          dom.classList.add(curList[i]);\n      if (dom.classList.length == 0)\n        dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n      if (prev.style) {\n        let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n        while (m = prop.exec(prev.style))\n          dom.style.removeProperty(m[1]);\n      }\n      if (cur.style)\n        dom.style.cssText += cur.style;\n    }\n  }\n  function applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n  }\n  function sameOuterDeco(a, b) {\n    if (a.length != b.length)\n      return false;\n    for (let i = 0; i < a.length; i++)\n      if (!a[i].type.eq(b[i].type))\n        return false;\n    return true;\n  }\n  function rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n  }\n  var ViewTreeUpdater = class {\n    constructor(top, lock, view) {\n      this.lock = lock;\n      this.view = view;\n      this.index = 0;\n      this.stack = [];\n      this.changed = false;\n      this.top = top;\n      this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n      if (start == end)\n        return;\n      for (let i = start; i < end; i++)\n        this.top.children[i].destroy();\n      this.top.children.splice(start, end - start);\n      this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n      this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks2, inline, view) {\n      let keep = 0, depth = this.stack.length >> 1;\n      let maxKeep = Math.min(depth, marks2.length);\n      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks2[keep]) && marks2[keep].type.spec.spanning !== false)\n        keep++;\n      while (keep < depth) {\n        this.destroyRest();\n        this.top.dirty = NOT_DIRTY;\n        this.index = this.stack.pop();\n        this.top = this.stack.pop();\n        depth--;\n      }\n      while (depth < marks2.length) {\n        this.stack.push(this.top, this.index + 1);\n        let found2 = -1;\n        for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n          let next = this.top.children[i];\n          if (next.matchesMark(marks2[depth]) && !this.isLocked(next.dom)) {\n            found2 = i;\n            break;\n          }\n        }\n        if (found2 > -1) {\n          if (found2 > this.index) {\n            this.changed = true;\n            this.destroyBetween(this.index, found2);\n          }\n          this.top = this.top.children[this.index];\n        } else {\n          let markDesc = MarkViewDesc.create(this.top, marks2[depth], inline, view);\n          this.top.children.splice(this.index, 0, markDesc);\n          this.top = markDesc;\n          this.changed = true;\n        }\n        this.index = 0;\n        depth++;\n      }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n      let found2 = -1, targetDesc;\n      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n        found2 = this.top.children.indexOf(targetDesc, this.index);\n      } else {\n        for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n          let child = this.top.children[i];\n          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n            found2 = i;\n            break;\n          }\n        }\n      }\n      if (found2 < 0)\n        return false;\n      this.destroyBetween(this.index, found2);\n      this.index++;\n      return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n      let child = this.top.children[index];\n      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n        child.dirty = CONTENT_DIRTY;\n      if (!child.update(node, outerDeco, innerDeco, view))\n        return false;\n      this.destroyBetween(this.index, index);\n      this.index++;\n      return true;\n    }\n    findIndexWithChild(domNode) {\n      for (; ; ) {\n        let parent = domNode.parentNode;\n        if (!parent)\n          return -1;\n        if (parent == this.top.contentDOM) {\n          let desc = domNode.pmViewDesc;\n          if (desc)\n            for (let i = this.index; i < this.top.children.length; i++) {\n              if (this.top.children[i] == desc)\n                return i;\n            }\n          return -1;\n        }\n        domNode = parent;\n      }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n      for (let i = this.index; i < this.top.children.length; i++) {\n        let next = this.top.children[i];\n        if (next instanceof NodeViewDesc) {\n          let preMatch2 = this.preMatch.matched.get(next);\n          if (preMatch2 != null && preMatch2 != index)\n            return false;\n          let nextDOM = next.dom, updated;\n          let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n          if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n            this.destroyBetween(this.index, i);\n            if (next.dom != nextDOM)\n              this.changed = true;\n            this.index++;\n            return true;\n          } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n            this.destroyBetween(this.index, i);\n            this.top.children[this.index] = updated;\n            if (updated.contentDOM) {\n              updated.dirty = CONTENT_DIRTY;\n              updated.updateChildren(view, pos + 1);\n              updated.dirty = NOT_DIRTY;\n            }\n            this.changed = true;\n            this.index++;\n            return true;\n          }\n          break;\n        }\n      }\n      return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))\n        return null;\n      let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n      if (wrapper.contentDOM) {\n        wrapper.children = next.children;\n        next.children = [];\n        for (let ch of wrapper.children)\n          ch.parent = wrapper;\n      }\n      next.destroy();\n      return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n      let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n      if (desc.contentDOM)\n        desc.updateChildren(view, pos + 1);\n      this.top.children.splice(this.index++, 0, desc);\n      this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n      let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n        this.index++;\n      } else {\n        let desc = new WidgetViewDesc(this.top, widget, view, pos);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n      }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n      let lastChild = this.top.children[this.index - 1], parent = this.top;\n      while (lastChild instanceof MarkViewDesc) {\n        parent = lastChild;\n        lastChild = parent.children[parent.children.length - 1];\n      }\n      if (!lastChild || // Empty textblock\n      !(lastChild instanceof TextViewDesc) || /\\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text)) {\n        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n          this.addHackNode(\"IMG\", parent);\n        this.addHackNode(\"BR\", this.top);\n      }\n    }\n    addHackNode(nodeName, parent) {\n      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n        this.index++;\n      } else {\n        let dom = document.createElement(nodeName);\n        if (nodeName == \"IMG\") {\n          dom.className = \"ProseMirror-separator\";\n          dom.alt = \"\";\n        }\n        if (nodeName == \"BR\")\n          dom.className = \"ProseMirror-trailingBreak\";\n        let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n        if (parent != this.top)\n          parent.children.push(hack);\n        else\n          parent.children.splice(this.index++, 0, hack);\n        this.changed = true;\n      }\n    }\n    isLocked(node) {\n      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n  };\n  function preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];\n    outer: while (fI > 0) {\n      let desc;\n      for (; ; ) {\n        if (descI) {\n          let next = curDesc.children[descI - 1];\n          if (next instanceof MarkViewDesc) {\n            curDesc = next;\n            descI = next.children.length;\n          } else {\n            desc = next;\n            descI--;\n            break;\n          }\n        } else if (curDesc == parentDesc) {\n          break outer;\n        } else {\n          descI = curDesc.parent.children.indexOf(curDesc);\n          curDesc = curDesc.parent;\n        }\n      }\n      let node = desc.node;\n      if (!node)\n        continue;\n      if (node != frag.child(fI - 1))\n        break;\n      --fI;\n      matched.set(desc, fI);\n      matches2.push(desc);\n    }\n    return { index: fI, matched, matches: matches2.reverse() };\n  }\n  function compareSide(a, b) {\n    return a.type.side - b.type.side;\n  }\n  function iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    if (locals.length == 0) {\n      for (let i = 0; i < parent.childCount; i++) {\n        let child = parent.child(i);\n        onNode(child, locals, deco.forChild(offset, child), i);\n        offset += child.nodeSize;\n      }\n      return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for (let parentIndex = 0; ; ) {\n      let widget, widgets;\n      while (decoIndex < locals.length && locals[decoIndex].to == offset) {\n        let next = locals[decoIndex++];\n        if (next.widget) {\n          if (!widget)\n            widget = next;\n          else\n            (widgets || (widgets = [widget])).push(next);\n        }\n      }\n      if (widget) {\n        if (widgets) {\n          widgets.sort(compareSide);\n          for (let i = 0; i < widgets.length; i++)\n            onWidget(widgets[i], parentIndex, !!restNode);\n        } else {\n          onWidget(widget, parentIndex, !!restNode);\n        }\n      }\n      let child, index;\n      if (restNode) {\n        index = -1;\n        child = restNode;\n        restNode = null;\n      } else if (parentIndex < parent.childCount) {\n        index = parentIndex;\n        child = parent.child(parentIndex++);\n      } else {\n        break;\n      }\n      for (let i = 0; i < active.length; i++)\n        if (active[i].to <= offset)\n          active.splice(i--, 1);\n      while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n        active.push(locals[decoIndex++]);\n      let end = offset + child.nodeSize;\n      if (child.isText) {\n        let cutAt = end;\n        if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n          cutAt = locals[decoIndex].from;\n        for (let i = 0; i < active.length; i++)\n          if (active[i].to < cutAt)\n            cutAt = active[i].to;\n        if (cutAt < end) {\n          restNode = child.cut(cutAt - offset);\n          child = child.cut(0, cutAt - offset);\n          end = cutAt;\n          index = -1;\n        }\n      } else {\n        while (decoIndex < locals.length && locals[decoIndex].to < end)\n          decoIndex++;\n      }\n      let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();\n      onNode(child, outerDeco, deco.forChild(offset, child), index);\n      offset = end;\n    }\n  }\n  function iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n      let oldCSS = dom.style.cssText;\n      dom.style.cssText = oldCSS + \"; list-style: square !important\";\n      window.getComputedStyle(dom).listStyle;\n      dom.style.cssText = oldCSS;\n    }\n  }\n  function findTextInFragment(frag, text2, from4, to) {\n    for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {\n      let child = frag.child(i++), childStart = pos;\n      pos += child.nodeSize;\n      if (!child.isText)\n        continue;\n      let str = child.text;\n      while (i < frag.childCount) {\n        let next = frag.child(i++);\n        pos += next.nodeSize;\n        if (!next.isText)\n          break;\n        str += next.text;\n      }\n      if (pos >= from4) {\n        if (pos >= to && str.slice(to - text2.length - childStart, to - childStart) == text2)\n          return to - text2.length;\n        let found2 = childStart < to ? str.lastIndexOf(text2, to - childStart - 1) : -1;\n        if (found2 >= 0 && found2 + text2.length + childStart >= from4)\n          return childStart + found2;\n        if (from4 == to && str.length >= to + text2.length - childStart && str.slice(to - childStart, to - childStart + text2.length) == text2)\n          return to;\n      }\n    }\n    return -1;\n  }\n  function replaceNodes(nodes2, from4, to, view, replacement) {\n    let result = [];\n    for (let i = 0, off = 0; i < nodes2.length; i++) {\n      let child = nodes2[i], start = off, end = off += child.size;\n      if (start >= to || end <= from4) {\n        result.push(child);\n      } else {\n        if (start < from4)\n          result.push(child.slice(0, from4 - start, view));\n        if (replacement) {\n          result.push(replacement);\n          replacement = void 0;\n        }\n        if (end > to)\n          result.push(child.slice(to - start, child.size, view));\n      }\n    }\n    return result;\n  }\n  function selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc4 = view.state.doc;\n    if (!domSel.focusNode)\n      return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0)\n      return null;\n    let $head = doc4.resolve(head), anchor, selection;\n    if (selectionCollapsed(domSel)) {\n      anchor = head;\n      while (nearestDesc && !nearestDesc.node)\n        nearestDesc = nearestDesc.parent;\n      let nearestDescNode = nearestDesc.node;\n      if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n        let pos = nearestDesc.posBefore;\n        selection = new NodeSelection(head == pos ? $head : doc4.resolve(pos));\n      }\n    } else {\n      if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n        let min4 = head, max4 = head;\n        for (let i = 0; i < domSel.rangeCount; i++) {\n          let range = domSel.getRangeAt(i);\n          min4 = Math.min(min4, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n          max4 = Math.max(max4, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n        }\n        if (min4 < 0)\n          return null;\n        [anchor, head] = max4 == view.state.selection.anchor ? [max4, min4] : [min4, max4];\n        $head = doc4.resolve(head);\n      } else {\n        anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n      }\n      if (anchor < 0)\n        return null;\n    }\n    let $anchor = doc4.resolve(anchor);\n    if (!selection) {\n      let bias = origin == \"pointer\" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;\n      selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n  }\n  function editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n  }\n  function selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view))\n      return;\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n      let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n      if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n        view.input.mouseDown.delayedSelectionSync = true;\n        view.domObserver.setCurSelection();\n        return;\n      }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n      selectCursorWrapper(view);\n    } else {\n      let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n      if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {\n        if (!sel.$from.parent.inlineContent)\n          resetEditableFrom = temporarilyEditableNear(view, sel.from);\n        if (!sel.empty && !sel.$from.parent.inlineContent)\n          resetEditableTo = temporarilyEditableNear(view, sel.to);\n      }\n      view.docView.setSelection(anchor, head, view, force);\n      if (brokenSelectBetweenUneditable) {\n        if (resetEditableFrom)\n          resetEditable(resetEditableFrom);\n        if (resetEditableTo)\n          resetEditable(resetEditableTo);\n      }\n      if (sel.visible) {\n        view.dom.classList.remove(\"ProseMirror-hideselection\");\n      } else {\n        view.dom.classList.add(\"ProseMirror-hideselection\");\n        if (\"onselectionchange\" in document)\n          removeClassOnSelectionChange(view);\n      }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n  }\n  var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\n  function temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\")\n      return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") && (!before || before.contentEditable == \"false\")) {\n      if (after)\n        return setEditable(after);\n      else if (before)\n        return setEditable(before);\n    }\n  }\n  function setEditable(element2) {\n    element2.contentEditable = \"true\";\n    if (safari && element2.draggable) {\n      element2.draggable = false;\n      element2.wasDraggable = true;\n    }\n    return element2;\n  }\n  function resetEditable(element2) {\n    element2.contentEditable = \"false\";\n    if (element2.wasDraggable) {\n      element2.draggable = true;\n      element2.wasDraggable = null;\n    }\n  }\n  function removeClassOnSelectionChange(view) {\n    let doc4 = view.dom.ownerDocument;\n    doc4.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc4.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = () => {\n      if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n        doc4.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n        setTimeout(() => {\n          if (!editorOwnsSelection(view) || view.state.selection.visible)\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        }, 20);\n      }\n    });\n  }\n  function selectCursorWrapper(view) {\n    let domSel = view.domSelection();\n    if (!domSel)\n      return;\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img)\n      domSel.collapse(node.parentNode, domIndex(node) + 1);\n    else\n      domSel.collapse(node, 0);\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n      node.disabled = true;\n      node.disabled = false;\n    }\n  }\n  function syncNodeSelection(view, sel) {\n    if (sel instanceof NodeSelection) {\n      let desc = view.docView.descAt(sel.from);\n      if (desc != view.lastSelectedViewDesc) {\n        clearNodeSelection(view);\n        if (desc)\n          desc.selectNode();\n        view.lastSelectedViewDesc = desc;\n      }\n    } else {\n      clearNodeSelection(view);\n    }\n  }\n  function clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n      if (view.lastSelectedViewDesc.parent)\n        view.lastSelectedViewDesc.deselectNode();\n      view.lastSelectedViewDesc = void 0;\n    }\n  }\n  function selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);\n  }\n  function hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus())\n      return false;\n    return hasSelection(view);\n  }\n  function hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode)\n      return false;\n    try {\n      return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    } catch (_) {\n      return false;\n    }\n  }\n  function anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n  }\n  function moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && Selection.findFrom($start, dir);\n  }\n  function apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n  }\n  function selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof TextSelection) {\n      if (mods.indexOf(\"s\") > -1) {\n        let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n        if (!node || node.isText || !node.isLeaf)\n          return false;\n        let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n        return apply(view, new TextSelection(sel.$anchor, $newHead));\n      } else if (!sel.empty) {\n        return false;\n      } else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && next instanceof NodeSelection)\n          return apply(view, next);\n        return false;\n      } else if (!(mac && mods.indexOf(\"m\") > -1)) {\n        let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n        if (!node || node.isText)\n          return false;\n        let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n        if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n          return false;\n        if (NodeSelection.isSelectable(node)) {\n          return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n        } else if (webkit) {\n          return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n        } else {\n          return false;\n        }\n      }\n    } else if (sel instanceof NodeSelection && sel.node.isInline) {\n      return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));\n    } else {\n      let next = moveSelectionBlock(view.state, dir);\n      if (next)\n        return apply(view, next);\n      return false;\n    }\n  }\n  function nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n  }\n  function isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n  }\n  function skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n  }\n  function skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n      return;\n    let moveNode, moveOffset, force = false;\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))\n      force = true;\n    for (; ; ) {\n      if (offset > 0) {\n        if (node.nodeType != 1) {\n          break;\n        } else {\n          let before = node.childNodes[offset - 1];\n          if (isIgnorable(before, -1)) {\n            moveNode = node;\n            moveOffset = --offset;\n          } else if (before.nodeType == 3) {\n            node = before;\n            offset = node.nodeValue.length;\n          } else\n            break;\n        }\n      } else if (isBlockNode(node)) {\n        break;\n      } else {\n        let prev = node.previousSibling;\n        while (prev && isIgnorable(prev, -1)) {\n          moveNode = node.parentNode;\n          moveOffset = domIndex(prev);\n          prev = prev.previousSibling;\n        }\n        if (!prev) {\n          node = node.parentNode;\n          if (node == view.dom)\n            break;\n          offset = 0;\n        } else {\n          node = prev;\n          offset = nodeLen(node);\n        }\n      }\n    }\n    if (force)\n      setSelFocus(view, node, offset);\n    else if (moveNode)\n      setSelFocus(view, moveNode, moveOffset);\n  }\n  function skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n      return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for (; ; ) {\n      if (offset < len) {\n        if (node.nodeType != 1)\n          break;\n        let after = node.childNodes[offset];\n        if (isIgnorable(after, 1)) {\n          moveNode = node;\n          moveOffset = ++offset;\n        } else\n          break;\n      } else if (isBlockNode(node)) {\n        break;\n      } else {\n        let next = node.nextSibling;\n        while (next && isIgnorable(next, 1)) {\n          moveNode = next.parentNode;\n          moveOffset = domIndex(next) + 1;\n          next = next.nextSibling;\n        }\n        if (!next) {\n          node = node.parentNode;\n          if (node == view.dom)\n            break;\n          offset = len = 0;\n        } else {\n          node = next;\n          offset = 0;\n          len = nodeLen(node);\n        }\n      }\n    }\n    if (moveNode)\n      setSelFocus(view, moveNode, moveOffset);\n  }\n  function isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n  }\n  function textNodeAfter(node, offset) {\n    while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {\n      offset = domIndex(node) + 1;\n      node = node.parentNode;\n    }\n    while (node && offset < node.childNodes.length) {\n      let next = node.childNodes[offset];\n      if (next.nodeType == 3)\n        return next;\n      if (next.nodeType == 1 && next.contentEditable == \"false\")\n        break;\n      node = next;\n      offset = 0;\n    }\n  }\n  function textNodeBefore(node, offset) {\n    while (node && !offset && !hasBlockDesc(node)) {\n      offset = domIndex(node);\n      node = node.parentNode;\n    }\n    while (node && offset) {\n      let next = node.childNodes[offset - 1];\n      if (next.nodeType == 3)\n        return next;\n      if (next.nodeType == 1 && next.contentEditable == \"false\")\n        break;\n      node = next;\n      offset = node.childNodes.length;\n    }\n  }\n  function setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n      let before, after;\n      if (after = textNodeAfter(node, offset)) {\n        node = after;\n        offset = 0;\n      } else if (before = textNodeBefore(node, offset)) {\n        node = before;\n        offset = before.nodeValue.length;\n      }\n    }\n    let sel = view.domSelection();\n    if (!sel)\n      return;\n    if (selectionCollapsed(sel)) {\n      let range = document.createRange();\n      range.setEnd(node, offset);\n      range.setStart(node, offset);\n      sel.removeAllRanges();\n      sel.addRange(range);\n    } else if (sel.extend) {\n      sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    setTimeout(() => {\n      if (view.state == state)\n        selectionToDOM(view);\n    }, 50);\n  }\n  function findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n      let coords = view.coordsAtPos(pos);\n      if (pos > $pos.start()) {\n        let before = view.coordsAtPos(pos - 1);\n        let mid = (before.top + before.bottom) / 2;\n        if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)\n          return before.left < coords.left ? \"ltr\" : \"rtl\";\n      }\n      if (pos < $pos.end()) {\n        let after = view.coordsAtPos(pos + 1);\n        let mid = (after.top + after.bottom) / 2;\n        if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)\n          return after.left > coords.left ? \"ltr\" : \"rtl\";\n      }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n  }\n  function selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof TextSelection && !sel.empty || mods.indexOf(\"s\") > -1)\n      return false;\n    if (mac && mods.indexOf(\"m\") > -1)\n      return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n      let next = moveSelectionBlock(view.state, dir);\n      if (next && next instanceof NodeSelection)\n        return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n      let side = dir < 0 ? $from : $to;\n      let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);\n      return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n  }\n  function stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof TextSelection))\n      return true;\n    let { $head, $anchor, empty: empty2 } = view.state.selection;\n    if (!$head.sameParent($anchor))\n      return true;\n    if (!empty2)\n      return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\"))\n      return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n      let tr = view.state.tr;\n      if (dir < 0)\n        tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n      else\n        tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n      view.dispatch(tr);\n      return true;\n    }\n    return false;\n  }\n  function switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n  }\n  function safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0)\n      return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n      let child = focusNode.firstChild;\n      switchEditable(view, child, \"true\");\n      setTimeout(() => switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n  }\n  function getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey)\n      result += \"c\";\n    if (event.metaKey)\n      result += \"m\";\n    if (event.altKey)\n      result += \"a\";\n    if (event.shiftKey)\n      result += \"s\";\n    return result;\n  }\n  function captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || mac && code == 72 && mods == \"c\") {\n      return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == \"c\") {\n      return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    } else if (code == 13 || code == 27) {\n      return true;\n    } else if (code == 37 || mac && code == 66 && mods == \"c\") {\n      let dir = code == 37 ? findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1 : -1;\n      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 39 || mac && code == 70 && mods == \"c\") {\n      let dir = code == 39 ? findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1 : 1;\n      return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    } else if (code == 38 || mac && code == 80 && mods == \"c\") {\n      return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    } else if (code == 40 || mac && code == 78 && mods == \"c\") {\n      return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    } else if (mods == (mac ? \"m\" : \"c\") && (code == 66 || code == 73 || code == 89 || code == 90)) {\n      return true;\n    }\n    return false;\n  }\n  function serializeForClipboard(view, slice2) {\n    view.someProp(\"transformCopied\", (f) => {\n      slice2 = f(slice2, view);\n    });\n    let context = [], { content, openStart, openEnd } = slice2;\n    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n      openStart--;\n      openEnd--;\n      let node = content.firstChild;\n      context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n      content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || DOMSerializer.fromSchema(view.state.schema);\n    let doc4 = detachedDoc(), wrap2 = doc4.createElement(\"div\");\n    wrap2.appendChild(serializer.serializeFragment(content, { document: doc4 }));\n    let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;\n    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n      for (let i = needsWrap.length - 1; i >= 0; i--) {\n        let wrapper = doc4.createElement(needsWrap[i]);\n        while (wrap2.firstChild)\n          wrapper.appendChild(wrap2.firstChild);\n        wrap2.appendChild(wrapper);\n        wrappers++;\n      }\n      firstChild = wrap2.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1)\n      firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text2 = view.someProp(\"clipboardTextSerializer\", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, \"\\n\\n\");\n    return { dom: wrap2, text: text2, slice: slice2 };\n  }\n  function parseFromClipboard(view, text2, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice2;\n    if (!html && !text2)\n      return null;\n    let asText = !!text2 && (plainText || inCode || !html);\n    if (asText) {\n      view.someProp(\"transformPastedText\", (f) => {\n        text2 = f(text2, inCode || plainText, view);\n      });\n      if (inCode) {\n        slice2 = new Slice(Fragment.from(view.state.schema.text(text2.replace(/\\r\\n?/g, \"\\n\"))), 0, 0);\n        view.someProp(\"transformPasted\", (f) => {\n          slice2 = f(slice2, view, true);\n        });\n        return slice2;\n      }\n      let parsed = view.someProp(\"clipboardTextParser\", (f) => f(text2, $context, plainText, view));\n      if (parsed) {\n        slice2 = parsed;\n      } else {\n        let marks2 = $context.marks();\n        let { schema: schema2 } = view.state, serializer = DOMSerializer.fromSchema(schema2);\n        dom = document.createElement(\"div\");\n        text2.split(/(?:\\r\\n?|\\n)+/).forEach((block) => {\n          let p = dom.appendChild(document.createElement(\"p\"));\n          if (block)\n            p.appendChild(serializer.serializeNode(schema2.text(block, marks2)));\n        });\n      }\n    } else {\n      view.someProp(\"transformPastedHTML\", (f) => {\n        html = f(html, view);\n      });\n      dom = readHTML(html);\n      if (webkit)\n        restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3])\n      for (let i = +sliceData[3]; i > 0; i--) {\n        let child = dom.firstChild;\n        while (child && child.nodeType != 1)\n          child = child.nextSibling;\n        if (!child)\n          break;\n        dom = child;\n      }\n    if (!slice2) {\n      let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || DOMParser2.fromSchema(view.state.schema);\n      slice2 = parser.parseSlice(dom, {\n        preserveWhitespace: !!(asText || sliceData),\n        context: $context,\n        ruleFromNode(dom2) {\n          if (dom2.nodeName == \"BR\" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))\n            return { ignore: true };\n          return null;\n        }\n      });\n    }\n    if (sliceData) {\n      slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);\n    } else {\n      slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);\n      if (slice2.openStart || slice2.openEnd) {\n        let openStart = 0, openEnd = 0;\n        for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {\n        }\n        for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {\n        }\n        slice2 = closeSlice(slice2, openStart, openEnd);\n      }\n    }\n    view.someProp(\"transformPasted\", (f) => {\n      slice2 = f(slice2, view, asText);\n    });\n    return slice2;\n  }\n  var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n  function normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2)\n      return fragment;\n    for (let d = $context.depth; d >= 0; d--) {\n      let parent = $context.node(d);\n      let match = parent.contentMatchAt($context.index(d));\n      let lastWrap, result = [];\n      fragment.forEach((node) => {\n        if (!result)\n          return;\n        let wrap2 = match.findWrapping(node.type), inLast;\n        if (!wrap2)\n          return result = null;\n        if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node, result[result.length - 1], 0)) {\n          result[result.length - 1] = inLast;\n        } else {\n          if (result.length)\n            result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n          let wrapped = withWrappers(node, wrap2);\n          result.push(wrapped);\n          match = match.matchType(wrapped.type);\n          lastWrap = wrap2;\n        }\n      });\n      if (result)\n        return Fragment.from(result);\n    }\n    return fragment;\n  }\n  function withWrappers(node, wrap2, from4 = 0) {\n    for (let i = wrap2.length - 1; i >= from4; i--)\n      node = wrap2[i].create(null, Fragment.from(node));\n    return node;\n  }\n  function addToSibling(wrap2, lastWrap, node, sibling, depth) {\n    if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {\n      let inner = addToSibling(wrap2, lastWrap, node, sibling.lastChild, depth + 1);\n      if (inner)\n        return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n      let match = sibling.contentMatchAt(sibling.childCount);\n      if (match.matchType(depth == wrap2.length - 1 ? node.type : wrap2[depth + 1]))\n        return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap2, depth + 1))));\n    }\n  }\n  function closeRight(node, depth) {\n    if (depth == 0)\n      return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n  }\n  function closeRange(fragment, side, from4, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1)\n      openEnd = 0;\n    if (depth < to - 1)\n      inner = closeRange(inner, side, from4, to, depth + 1, openEnd);\n    if (depth >= from4)\n      inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n  }\n  function closeSlice(slice2, openStart, openEnd) {\n    if (openStart < slice2.openStart)\n      slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);\n    if (openEnd < slice2.openEnd)\n      slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);\n    return slice2;\n  }\n  var wrapMap = {\n    thead: [\"table\"],\n    tbody: [\"table\"],\n    tfoot: [\"table\"],\n    caption: [\"table\"],\n    colgroup: [\"table\"],\n    col: [\"table\", \"colgroup\"],\n    tr: [\"table\", \"tbody\"],\n    td: [\"table\", \"tbody\", \"tr\"],\n    th: [\"table\", \"tbody\", \"tr\"]\n  };\n  var _detachedDoc = null;\n  function detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n  }\n  var _policy = null;\n  function maybeWrapTrusted(html) {\n    let trustedTypes = window.trustedTypes;\n    if (!trustedTypes)\n      return html;\n    if (!_policy)\n      _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy(\"ProseMirrorClipboard\", { createHTML: (s) => s });\n    return _policy.createHTML(html);\n  }\n  function readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas)\n      html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap2;\n    if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])\n      html = wrap2.map((n) => \"<\" + n + \">\").join(\"\") + html + wrap2.map((n) => \"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = maybeWrapTrusted(html);\n    if (wrap2)\n      for (let i = 0; i < wrap2.length; i++)\n        elt = elt.querySelector(wrap2[i]) || elt;\n    return elt;\n  }\n  function restoreReplacedSpaces(dom) {\n    let nodes2 = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for (let i = 0; i < nodes2.length; i++) {\n      let node = nodes2[i];\n      if (node.childNodes.length == 1 && node.textContent == \"\\xA0\" && node.parentNode)\n        node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n  }\n  function addContext(slice2, context) {\n    if (!slice2.size)\n      return slice2;\n    let schema2 = slice2.content.firstChild.type.schema, array;\n    try {\n      array = JSON.parse(context);\n    } catch (e) {\n      return slice2;\n    }\n    let { content, openStart, openEnd } = slice2;\n    for (let i = array.length - 2; i >= 0; i -= 2) {\n      let type = schema2.nodes[array[i]];\n      if (!type || type.hasRequiredAttrs())\n        break;\n      content = Fragment.from(type.create(array[i + 1], content));\n      openStart++;\n      openEnd++;\n    }\n    return new Slice(content, openStart, openEnd);\n  }\n  var handlers = {};\n  var editHandlers = {};\n  var passiveHandlers = { touchstart: true, touchmove: true };\n  var InputState = class {\n    constructor() {\n      this.shiftKey = false;\n      this.mouseDown = null;\n      this.lastKeyCode = null;\n      this.lastKeyCodeTime = 0;\n      this.lastClick = { time: 0, x: 0, y: 0, type: \"\", button: 0 };\n      this.lastSelectionOrigin = null;\n      this.lastSelectionTime = 0;\n      this.lastIOSEnter = 0;\n      this.lastIOSEnterFallbackTimeout = -1;\n      this.lastFocus = 0;\n      this.lastTouch = 0;\n      this.lastChromeDelete = 0;\n      this.composing = false;\n      this.compositionNode = null;\n      this.composingTimeout = -1;\n      this.compositionNodes = [];\n      this.compositionEndedAt = -2e8;\n      this.compositionID = 1;\n      this.compositionPendingChanges = 0;\n      this.domChangeCount = 0;\n      this.eventHandlers = /* @__PURE__ */ Object.create(null);\n      this.hideSelectionGuard = null;\n    }\n  };\n  function initInput(view) {\n    for (let event in handlers) {\n      let handler = handlers[event];\n      view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {\n        if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))\n          handler(view, event2);\n      }, passiveHandlers[event] ? { passive: true } : void 0);\n    }\n    if (safari)\n      view.dom.addEventListener(\"input\", () => null);\n    ensureListeners(view);\n  }\n  function setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n  }\n  function destroyInput(view) {\n    view.domObserver.stop();\n    for (let type in view.input.eventHandlers)\n      view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n  }\n  function ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", (currentHandlers) => {\n      for (let type in currentHandlers)\n        if (!view.input.eventHandlers[type])\n          view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));\n    });\n  }\n  function runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", (handlers2) => {\n      let handler = handlers2[event.type];\n      return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n  }\n  function eventBelongsToView(view, event) {\n    if (!event.bubbles)\n      return true;\n    if (event.defaultPrevented)\n      return false;\n    for (let node = event.target; node != view.dom; node = node.parentNode)\n      if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))\n        return false;\n    return true;\n  }\n  function dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))\n      handlers[event.type](view, event);\n  }\n  editHandlers.keydown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event))\n      return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    if (android && chrome && event.keyCode == 13)\n      return;\n    if (event.keyCode != 229)\n      view.domObserver.forceFlush();\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n      let now = Date.now();\n      view.input.lastIOSEnter = now;\n      view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n        if (view.input.lastIOSEnter == now) {\n          view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")));\n          view.input.lastIOSEnter = 0;\n        }\n      }, 200);\n    } else if (view.someProp(\"handleKeyDown\", (f) => f(view, event)) || captureKeyDown(view, event)) {\n      event.preventDefault();\n    } else {\n      setSelectionOrigin(view, \"key\");\n    }\n  };\n  editHandlers.keyup = (view, event) => {\n    if (event.keyCode == 16)\n      view.input.shiftKey = false;\n  };\n  editHandlers.keypress = (view, _event) => {\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey)\n      return;\n    if (view.someProp(\"handleKeyPress\", (f) => f(view, event))) {\n      event.preventDefault();\n      return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {\n      let text2 = String.fromCharCode(event.charCode);\n      let deflt = () => view.state.tr.insertText(text2).scrollIntoView();\n      if (!/[\\r\\n]/.test(text2) && !view.someProp(\"handleTextInput\", (f) => f(view, sel.$from.pos, sel.$to.pos, text2, deflt)))\n        view.dispatch(deflt());\n      event.preventDefault();\n    }\n  };\n  function eventCoords(event) {\n    return { left: event.clientX, top: event.clientY };\n  }\n  function isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n  }\n  function runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1)\n      return false;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n      if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n        return true;\n    }\n    return false;\n  }\n  function updateSelection(view, selection, origin) {\n    if (!view.focused)\n      view.focus();\n    if (view.state.selection.eq(selection))\n      return;\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\")\n      tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n  }\n  function selectClickedLeaf(view, inside) {\n    if (inside == -1)\n      return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && NodeSelection.isSelectable(node)) {\n      updateSelection(view, new NodeSelection($pos), \"pointer\");\n      return true;\n    }\n    return false;\n  }\n  function selectClickedNode(view, inside) {\n    if (inside == -1)\n      return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof NodeSelection)\n      selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n      if (NodeSelection.isSelectable(node)) {\n        if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n          selectAt = $pos.before(sel.$from.depth);\n        else\n          selectAt = $pos.before(i);\n        break;\n      }\n    }\n    if (selectAt != null) {\n      updateSelection(view, NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n      return true;\n    } else {\n      return false;\n    }\n  }\n  function handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) || view.someProp(\"handleClick\", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n  }\n  function handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) || view.someProp(\"handleDoubleClick\", (f) => f(view, pos, event));\n  }\n  function handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) || view.someProp(\"handleTripleClick\", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);\n  }\n  function defaultTripleClick(view, inside, event) {\n    if (event.button != 0)\n      return false;\n    let doc4 = view.state.doc;\n    if (inside == -1) {\n      if (doc4.inlineContent) {\n        updateSelection(view, TextSelection.create(doc4, 0, doc4.content.size), \"pointer\");\n        return true;\n      }\n      return false;\n    }\n    let $pos = doc4.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n      let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n      let nodePos = $pos.before(i);\n      if (node.inlineContent)\n        updateSelection(view, TextSelection.create(doc4, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n      else if (NodeSelection.isSelectable(node))\n        updateSelection(view, NodeSelection.create(doc4, nodePos), \"pointer\");\n      else\n        continue;\n      return true;\n    }\n  }\n  function forceDOMFlush(view) {\n    return endComposition(view);\n  }\n  var selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\n  handlers.mousedown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {\n      if (view.input.lastClick.type == \"singleClick\")\n        type = \"doubleClick\";\n      else if (view.input.lastClick.type == \"doubleClick\")\n        type = \"tripleClick\";\n    }\n    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos)\n      return;\n    if (type == \"singleClick\") {\n      if (view.input.mouseDown)\n        view.input.mouseDown.done();\n      view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    } else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n      event.preventDefault();\n    } else {\n      setSelectionOrigin(view, \"pointer\");\n    }\n  };\n  var MouseDown = class {\n    constructor(view, pos, event, flushed) {\n      this.view = view;\n      this.pos = pos;\n      this.event = event;\n      this.flushed = flushed;\n      this.delayedSelectionSync = false;\n      this.mightDrag = null;\n      this.startDoc = view.state.doc;\n      this.selectNode = !!event[selectNodeModifier];\n      this.allowDefault = event.shiftKey;\n      let targetNode, targetPos;\n      if (pos.inside > -1) {\n        targetNode = view.state.doc.nodeAt(pos.inside);\n        targetPos = pos.inside;\n      } else {\n        let $pos = view.state.doc.resolve(pos.pos);\n        targetNode = $pos.parent;\n        targetPos = $pos.depth ? $pos.before() : 0;\n      }\n      const target = flushed ? null : event.target;\n      const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n      this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;\n      let { selection } = view.state;\n      if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n        this.mightDrag = {\n          node: targetNode,\n          pos: targetPos,\n          addAttr: !!(this.target && !this.target.draggable),\n          setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n        };\n      if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n        this.view.domObserver.stop();\n        if (this.mightDrag.addAttr)\n          this.target.draggable = true;\n        if (this.mightDrag.setUneditable)\n          setTimeout(() => {\n            if (this.view.input.mouseDown == this)\n              this.target.setAttribute(\"contentEditable\", \"false\");\n          }, 20);\n        this.view.domObserver.start();\n      }\n      view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n      view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n      setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n      this.view.root.removeEventListener(\"mouseup\", this.up);\n      this.view.root.removeEventListener(\"mousemove\", this.move);\n      if (this.mightDrag && this.target) {\n        this.view.domObserver.stop();\n        if (this.mightDrag.addAttr)\n          this.target.removeAttribute(\"draggable\");\n        if (this.mightDrag.setUneditable)\n          this.target.removeAttribute(\"contentEditable\");\n        this.view.domObserver.start();\n      }\n      if (this.delayedSelectionSync)\n        setTimeout(() => selectionToDOM(this.view));\n      this.view.input.mouseDown = null;\n    }\n    up(event) {\n      this.done();\n      if (!this.view.dom.contains(event.target))\n        return;\n      let pos = this.pos;\n      if (this.view.state.doc != this.startDoc)\n        pos = this.view.posAtCoords(eventCoords(event));\n      this.updateAllowDefault(event);\n      if (this.allowDefault || !pos) {\n        setSelectionOrigin(this.view, \"pointer\");\n      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n        event.preventDefault();\n      } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements\n      safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a\n      // cursor, but still report that the node is selected\n      // when asked through getSelection. You'll then get a\n      // situation where clicking at the point where that\n      // (hidden) cursor is doesn't change the selection, and\n      // thus doesn't get a reaction from ProseMirror. This\n      // works around that.\n      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {\n        updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n        event.preventDefault();\n      } else {\n        setSelectionOrigin(this.view, \"pointer\");\n      }\n    }\n    move(event) {\n      this.updateAllowDefault(event);\n      setSelectionOrigin(this.view, \"pointer\");\n      if (event.buttons == 0)\n        this.done();\n    }\n    updateAllowDefault(event) {\n      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))\n        this.allowDefault = true;\n    }\n  };\n  handlers.touchstart = (view) => {\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n  };\n  handlers.touchmove = (view) => {\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n  };\n  handlers.contextmenu = (view) => forceDOMFlush(view);\n  function inOrNearComposition(view, event) {\n    if (view.composing)\n      return true;\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n      view.input.compositionEndedAt = -2e8;\n      return true;\n    }\n    return false;\n  }\n  var timeoutComposition = android ? 5e3 : -1;\n  editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {\n    if (!view.composing) {\n      view.domObserver.flush();\n      let { state } = view, $pos = state.selection.$to;\n      if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {\n        view.markCursor = view.state.storedMarks || $pos.marks();\n        endComposition(view, true);\n        view.markCursor = null;\n      } else {\n        endComposition(view, !state.selection.empty);\n        if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n          let sel = view.domSelectionRange();\n          for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0; ) {\n            let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n            if (!before)\n              break;\n            if (before.nodeType == 3) {\n              let sel2 = view.domSelection();\n              if (sel2)\n                sel2.collapse(before, before.nodeValue.length);\n              break;\n            } else {\n              node = before;\n              offset = -1;\n            }\n          }\n        }\n      }\n      view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n  };\n  editHandlers.compositionend = (view, event) => {\n    if (view.composing) {\n      view.input.composing = false;\n      view.input.compositionEndedAt = event.timeStamp;\n      view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n      view.input.compositionNode = null;\n      if (view.input.compositionPendingChanges)\n        Promise.resolve().then(() => view.domObserver.flush());\n      view.input.compositionID++;\n      scheduleComposeEnd(view, 20);\n    }\n  };\n  function scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1)\n      view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n  }\n  function clearComposition(view) {\n    if (view.composing) {\n      view.input.composing = false;\n      view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while (view.input.compositionNodes.length > 0)\n      view.input.compositionNodes.pop().markParentsDirty();\n  }\n  function findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode)\n      return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n      let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n      if (textBefore == lastChanged || textAfter == lastChanged)\n        return lastChanged;\n      if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n        return textAfter;\n      } else if (view.input.compositionNode == textAfter) {\n        let descBefore = textBefore.pmViewDesc;\n        if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))\n          return textAfter;\n      }\n    }\n    return textBefore || textAfter;\n  }\n  function timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n  }\n  function endComposition(view, restarting = false) {\n    if (android && view.domObserver.flushingSoon >= 0)\n      return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (restarting || view.docView && view.docView.dirty) {\n      let sel = selectionFromDOM(view), cur = view.state.selection;\n      if (sel && !sel.eq(cur))\n        view.dispatch(view.state.tr.setSelection(sel));\n      else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)\n        view.dispatch(view.state.tr.deleteSelection());\n      else\n        view.updateState(view.state);\n      return true;\n    }\n    return false;\n  }\n  function captureCopy(view, dom) {\n    if (!view.dom.parentNode)\n      return;\n    let wrap2 = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap2.appendChild(dom);\n    wrap2.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(() => {\n      if (wrap2.parentNode)\n        wrap2.parentNode.removeChild(wrap2);\n      view.focus();\n    }, 50);\n  }\n  var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;\n  handlers.copy = editHandlers.cut = (view, _event) => {\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty)\n      return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice2 = sel.content(), { dom, text: text2 } = serializeForClipboard(view, slice2);\n    if (data) {\n      event.preventDefault();\n      data.clearData();\n      data.setData(\"text/html\", dom.innerHTML);\n      data.setData(\"text/plain\", text2);\n    } else {\n      captureCopy(view, dom);\n    }\n    if (cut)\n      view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n  };\n  function sliceSingleNode(slice2) {\n    return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;\n  }\n  function capturePaste(view, event) {\n    if (!view.dom.parentNode)\n      return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText)\n      target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(() => {\n      view.focus();\n      if (target.parentNode)\n        target.parentNode.removeChild(target);\n      if (plainText)\n        doPaste(view, target.value, null, plain, event);\n      else\n        doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n  }\n  function doPaste(view, text2, html, preferPlain, event) {\n    let slice2 = parseFromClipboard(view, text2, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", (f) => f(view, event, slice2 || Slice.empty)))\n      return true;\n    if (!slice2)\n      return false;\n    let singleNode = sliceSingleNode(slice2);\n    let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n  }\n  function getText(clipboardData) {\n    let text2 = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text2)\n      return text2;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n  }\n  editHandlers.paste = (view, _event) => {\n    let event = _event;\n    if (view.composing && !android)\n      return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event))\n      event.preventDefault();\n    else\n      capturePaste(view, event);\n  };\n  var Dragging = class {\n    constructor(slice2, move, node) {\n      this.slice = slice2;\n      this.move = move;\n      this.node = node;\n    }\n  };\n  var dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\n  function dragMoves(view, event) {\n    let moves = view.someProp(\"dragCopies\", (test) => !test(event));\n    return moves != null ? moves : !event[dragCopyModifier];\n  }\n  handlers.dragstart = (view, _event) => {\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown)\n      mouseDown.done();\n    if (!event.dataTransfer)\n      return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n      node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    } else if (event.target && event.target.nodeType == 1) {\n      let desc = view.docView.nearestDesc(event.target, true);\n      if (desc && desc.node.type.spec.draggable && desc != view.docView)\n        node = NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text: text2, slice: slice2 } = serializeForClipboard(view, draggedSlice);\n    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)\n      event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI)\n      event.dataTransfer.setData(\"text/plain\", text2);\n    view.dragging = new Dragging(slice2, dragMoves(view, event), node);\n  };\n  handlers.dragend = (view) => {\n    let dragging = view.dragging;\n    window.setTimeout(() => {\n      if (view.dragging == dragging)\n        view.dragging = null;\n    }, 50);\n  };\n  editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\n  editHandlers.drop = (view, _event) => {\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer)\n      return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos)\n      return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice2 = dragging && dragging.slice;\n    if (slice2) {\n      view.someProp(\"transformPasted\", (f) => {\n        slice2 = f(slice2, view, false);\n      });\n    } else {\n      slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && dragMoves(view, event));\n    if (view.someProp(\"handleDrop\", (f) => f(view, event, slice2 || Slice.empty, move))) {\n      event.preventDefault();\n      return;\n    }\n    if (!slice2)\n      return;\n    event.preventDefault();\n    let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;\n    if (insertPos == null)\n      insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n      let { node } = dragging;\n      if (node)\n        node.replace(tr);\n      else\n        tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode2)\n      tr.replaceRangeWith(pos, pos, slice2.content.firstChild);\n    else\n      tr.replaceRange(pos, pos, slice2);\n    if (tr.doc.eq(beforeInsert))\n      return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {\n      tr.setSelection(new NodeSelection($pos));\n    } else {\n      let end = tr.mapping.map(insertPos);\n      tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n      tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n  };\n  handlers.focus = (view) => {\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n      view.domObserver.stop();\n      view.dom.classList.add(\"ProseMirror-focused\");\n      view.domObserver.start();\n      view.focused = true;\n      setTimeout(() => {\n        if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n          selectionToDOM(view);\n      }, 20);\n    }\n  };\n  handlers.blur = (view, _event) => {\n    let event = _event;\n    if (view.focused) {\n      view.domObserver.stop();\n      view.dom.classList.remove(\"ProseMirror-focused\");\n      view.domObserver.start();\n      if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n        view.domObserver.currentSelection.clear();\n      view.focused = false;\n    }\n  };\n  handlers.beforeinput = (view, _event) => {\n    let event = _event;\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n      view.domObserver.flushSoon();\n      let { domChangeCount } = view.input;\n      setTimeout(() => {\n        if (view.input.domChangeCount != domChangeCount)\n          return;\n        view.dom.blur();\n        view.focus();\n        if (view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\"))))\n          return;\n        let { $cursor } = view.state.selection;\n        if ($cursor && $cursor.pos > 0)\n          view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n      }, 50);\n    }\n  };\n  for (let prop in editHandlers)\n    handlers[prop] = editHandlers[prop];\n  function compareObjs(a, b) {\n    if (a == b)\n      return true;\n    for (let p in a)\n      if (a[p] !== b[p])\n        return false;\n    for (let p in b)\n      if (!(p in a))\n        return false;\n    return true;\n  }\n  var WidgetType = class _WidgetType {\n    constructor(toDOM, spec) {\n      this.toDOM = toDOM;\n      this.spec = spec || noSpec;\n      this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n      let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n      return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() {\n      return true;\n    }\n    eq(other) {\n      return this == other || other instanceof _WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));\n    }\n    destroy(node) {\n      if (this.spec.destroy)\n        this.spec.destroy(node);\n    }\n  };\n  var InlineType = class _InlineType {\n    constructor(attrs, spec) {\n      this.attrs = attrs;\n      this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n      let from4 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n      let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n      return from4 >= to ? null : new Decoration(from4, to, this);\n    }\n    valid(_, span) {\n      return span.from < span.to;\n    }\n    eq(other) {\n      return this == other || other instanceof _InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    static is(span) {\n      return span.type instanceof _InlineType;\n    }\n    destroy() {\n    }\n  };\n  var NodeType2 = class _NodeType {\n    constructor(attrs, spec) {\n      this.attrs = attrs;\n      this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n      let from4 = mapping.mapResult(span.from + oldOffset, 1);\n      if (from4.deleted)\n        return null;\n      let to = mapping.mapResult(span.to + oldOffset, -1);\n      if (to.deleted || to.pos <= from4.pos)\n        return null;\n      return new Decoration(from4.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n      let { index, offset } = node.content.findIndex(span.from), child;\n      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n      return this == other || other instanceof _NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);\n    }\n    destroy() {\n    }\n  };\n  var Decoration = class _Decoration {\n    /**\n    @internal\n    */\n    constructor(from4, to, type) {\n      this.from = from4;\n      this.to = to;\n      this.type = type;\n    }\n    /**\n    @internal\n    */\n    copy(from4, to) {\n      return new _Decoration(from4, to, this.type);\n    }\n    /**\n    @internal\n    */\n    eq(other, offset = 0) {\n      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */\n    map(mapping, offset, oldOffset) {\n      return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */\n    static widget(pos, toDOM, spec) {\n      return new _Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */\n    static inline(from4, to, attrs, spec) {\n      return new _Decoration(from4, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */\n    static node(from4, to, attrs, spec) {\n      return new _Decoration(from4, to, new NodeType2(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */\n    get spec() {\n      return this.type.spec;\n    }\n    /**\n    @internal\n    */\n    get inline() {\n      return this.type instanceof InlineType;\n    }\n    /**\n    @internal\n    */\n    get widget() {\n      return this.type instanceof WidgetType;\n    }\n  };\n  var none = [];\n  var noSpec = {};\n  var DecorationSet = class _DecorationSet {\n    /**\n    @internal\n    */\n    constructor(local, children) {\n      this.local = local.length ? local : none;\n      this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */\n    static create(doc4, decorations) {\n      return decorations.length ? buildTree(decorations, doc4, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */\n    find(start, end, predicate) {\n      let result = [];\n      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n      return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n      for (let i = 0; i < this.local.length; i++) {\n        let span = this.local[i];\n        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n          result.push(span.copy(span.from + offset, span.to + offset));\n      }\n      for (let i = 0; i < this.children.length; i += 3) {\n        if (this.children[i] < end && this.children[i + 1] > start) {\n          let childOff = this.children[i] + 1;\n          this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n        }\n      }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */\n    map(mapping, doc4, options) {\n      if (this == empty || mapping.maps.length == 0)\n        return this;\n      return this.mapInner(mapping, doc4, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */\n    mapInner(mapping, node, offset, oldOffset, options) {\n      let newLocal;\n      for (let i = 0; i < this.local.length; i++) {\n        let mapped = this.local[i].map(mapping, offset, oldOffset);\n        if (mapped && mapped.type.valid(node, mapped))\n          (newLocal || (newLocal = [])).push(mapped);\n        else if (options.onRemove)\n          options.onRemove(this.local[i].spec);\n      }\n      if (this.children.length)\n        return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n      else\n        return newLocal ? new _DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */\n    add(doc4, decorations) {\n      if (!decorations.length)\n        return this;\n      if (this == empty)\n        return _DecorationSet.create(doc4, decorations);\n      return this.addInner(doc4, decorations, 0);\n    }\n    addInner(doc4, decorations, offset) {\n      let children, childIndex = 0;\n      doc4.forEach((childNode, childOffset) => {\n        let baseOffset = childOffset + offset, found2;\n        if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))\n          return;\n        if (!children)\n          children = this.children.slice();\n        while (childIndex < children.length && children[childIndex] < childOffset)\n          childIndex += 3;\n        if (children[childIndex] == childOffset)\n          children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);\n        else\n          children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));\n        childIndex += 3;\n      });\n      let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n      for (let i = 0; i < local.length; i++)\n        if (!local[i].type.valid(doc4, local[i]))\n          local.splice(i--, 1);\n      return new _DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */\n    remove(decorations) {\n      if (decorations.length == 0 || this == empty)\n        return this;\n      return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n      let children = this.children, local = this.local;\n      for (let i = 0; i < children.length; i += 3) {\n        let found2;\n        let from4 = children[i] + offset, to = children[i + 1] + offset;\n        for (let j = 0, span; j < decorations.length; j++)\n          if (span = decorations[j]) {\n            if (span.from > from4 && span.to < to) {\n              decorations[j] = null;\n              (found2 || (found2 = [])).push(span);\n            }\n          }\n        if (!found2)\n          continue;\n        if (children == this.children)\n          children = this.children.slice();\n        let removed = children[i + 2].removeInner(found2, from4 + 1);\n        if (removed != empty) {\n          children[i + 2] = removed;\n        } else {\n          children.splice(i, 3);\n          i -= 3;\n        }\n      }\n      if (local.length) {\n        for (let i = 0, span; i < decorations.length; i++)\n          if (span = decorations[i]) {\n            for (let j = 0; j < local.length; j++)\n              if (local[j].eq(span, offset)) {\n                if (local == this.local)\n                  local = this.local.slice();\n                local.splice(j--, 1);\n              }\n          }\n      }\n      if (children == this.children && local == this.local)\n        return this;\n      return local.length || children.length ? new _DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n      if (this == empty)\n        return this;\n      if (node.isLeaf)\n        return _DecorationSet.empty;\n      let child, local;\n      for (let i = 0; i < this.children.length; i += 3)\n        if (this.children[i] >= offset) {\n          if (this.children[i] == offset)\n            child = this.children[i + 2];\n          break;\n        }\n      let start = offset + 1, end = start + node.content.size;\n      for (let i = 0; i < this.local.length; i++) {\n        let dec = this.local[i];\n        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {\n          let from4 = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n          if (from4 < to)\n            (local || (local = [])).push(dec.copy(from4, to));\n        }\n      }\n      if (local) {\n        let localSet = new _DecorationSet(local.sort(byPos), none);\n        return child ? new DecorationGroup([localSet, child]) : localSet;\n      }\n      return child || empty;\n    }\n    /**\n    @internal\n    */\n    eq(other) {\n      if (this == other)\n        return true;\n      if (!(other instanceof _DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)\n        return false;\n      for (let i = 0; i < this.local.length; i++)\n        if (!this.local[i].eq(other.local[i]))\n          return false;\n      for (let i = 0; i < this.children.length; i += 3)\n        if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))\n          return false;\n      return true;\n    }\n    /**\n    @internal\n    */\n    locals(node) {\n      return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */\n    localsInner(node) {\n      if (this == empty)\n        return none;\n      if (node.inlineContent || !this.local.some(InlineType.is))\n        return this.local;\n      let result = [];\n      for (let i = 0; i < this.local.length; i++) {\n        if (!(this.local[i].type instanceof InlineType))\n          result.push(this.local[i]);\n      }\n      return result;\n    }\n    forEachSet(f) {\n      f(this);\n    }\n  };\n  DecorationSet.empty = new DecorationSet([], []);\n  DecorationSet.removeOverlap = removeOverlap;\n  var empty = DecorationSet.empty;\n  var DecorationGroup = class _DecorationGroup {\n    constructor(members) {\n      this.members = members;\n    }\n    map(mapping, doc4) {\n      const mappedDecos = this.members.map((member) => member.map(mapping, doc4, noSpec));\n      return _DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n      if (child.isLeaf)\n        return DecorationSet.empty;\n      let found2 = [];\n      for (let i = 0; i < this.members.length; i++) {\n        let result = this.members[i].forChild(offset, child);\n        if (result == empty)\n          continue;\n        if (result instanceof _DecorationGroup)\n          found2 = found2.concat(result.members);\n        else\n          found2.push(result);\n      }\n      return _DecorationGroup.from(found2);\n    }\n    eq(other) {\n      if (!(other instanceof _DecorationGroup) || other.members.length != this.members.length)\n        return false;\n      for (let i = 0; i < this.members.length; i++)\n        if (!this.members[i].eq(other.members[i]))\n          return false;\n      return true;\n    }\n    locals(node) {\n      let result, sorted = true;\n      for (let i = 0; i < this.members.length; i++) {\n        let locals = this.members[i].localsInner(node);\n        if (!locals.length)\n          continue;\n        if (!result) {\n          result = locals;\n        } else {\n          if (sorted) {\n            result = result.slice();\n            sorted = false;\n          }\n          for (let j = 0; j < locals.length; j++)\n            result.push(locals[j]);\n        }\n      }\n      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n      switch (members.length) {\n        case 0:\n          return empty;\n        case 1:\n          return members[0];\n        default:\n          return new _DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));\n      }\n    }\n    forEachSet(f) {\n      for (let i = 0; i < this.members.length; i++)\n        this.members[i].forEachSet(f);\n    }\n  };\n  function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n      let moved = 0;\n      mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n        let dSize = newEnd - newStart - (oldEnd - oldStart);\n        for (let i2 = 0; i2 < children.length; i2 += 3) {\n          let end = children[i2 + 1];\n          if (end < 0 || oldStart > end + baseOffset - moved)\n            continue;\n          let start = children[i2] + baseOffset - moved;\n          if (oldEnd >= start) {\n            children[i2 + 1] = oldStart <= start ? -2 : -1;\n          } else if (oldStart >= baseOffset && dSize) {\n            children[i2] += dSize;\n            children[i2 + 1] += dSize;\n          }\n        }\n        moved += dSize;\n      });\n      baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    let mustRebuild = false;\n    for (let i = 0; i < children.length; i += 3)\n      if (children[i + 1] < 0) {\n        if (children[i + 1] == -2) {\n          mustRebuild = true;\n          children[i + 1] = -1;\n          continue;\n        }\n        let from4 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from4 - offset;\n        if (fromLocal < 0 || fromLocal >= node.content.size) {\n          mustRebuild = true;\n          continue;\n        }\n        let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n        let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n        let childNode = node.maybeChild(index);\n        if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n          let mapped = children[i + 2].mapInner(mapping, childNode, from4 + 1, oldChildren[i] + oldOffset + 1, options);\n          if (mapped != empty) {\n            children[i] = fromLocal;\n            children[i + 1] = toLocal;\n            children[i + 2] = mapped;\n          } else {\n            children[i + 1] = -2;\n            mustRebuild = true;\n          }\n        } else {\n          mustRebuild = true;\n        }\n      }\n    if (mustRebuild) {\n      let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n      let built = buildTree(decorations, node, 0, options);\n      newLocal = built.local;\n      for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] < 0) {\n          children.splice(i, 3);\n          i -= 3;\n        }\n      for (let i = 0, j = 0; i < built.children.length; i += 3) {\n        let from4 = built.children[i];\n        while (j < children.length && children[j] < from4)\n          j += 3;\n        children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n      }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n  }\n  function moveSpans(spans, offset) {\n    if (!offset || !spans.length)\n      return spans;\n    let result = [];\n    for (let i = 0; i < spans.length; i++) {\n      let span = spans[i];\n      result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n  }\n  function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    function gather(set, oldOffset2) {\n      for (let i = 0; i < set.local.length; i++) {\n        let mapped = set.local[i].map(mapping, offset, oldOffset2);\n        if (mapped)\n          decorations.push(mapped);\n        else if (options.onRemove)\n          options.onRemove(set.local[i].spec);\n      }\n      for (let i = 0; i < set.children.length; i += 3)\n        gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);\n    }\n    for (let i = 0; i < children.length; i += 3)\n      if (children[i + 1] == -1)\n        gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n  }\n  function takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf)\n      return null;\n    let end = offset + node.nodeSize, found2 = null;\n    for (let i = 0, span; i < spans.length; i++) {\n      if ((span = spans[i]) && span.from > offset && span.to < end) {\n        (found2 || (found2 = [])).push(span);\n        spans[i] = null;\n      }\n    }\n    return found2;\n  }\n  function withoutNulls(array) {\n    let result = [];\n    for (let i = 0; i < array.length; i++)\n      if (array[i] != null)\n        result.push(array[i]);\n    return result;\n  }\n  function buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart) => {\n      let found2 = takeSpansForNode(spans, childNode, localStart + offset);\n      if (found2) {\n        hasNulls = true;\n        let subtree = buildTree(found2, childNode, offset + localStart + 1, options);\n        if (subtree != empty)\n          children.push(localStart, localStart + childNode.nodeSize, subtree);\n      }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for (let i = 0; i < locals.length; i++)\n      if (!locals[i].type.valid(node, locals[i])) {\n        if (options.onRemove)\n          options.onRemove(locals[i].spec);\n        locals.splice(i--, 1);\n      }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n  }\n  function byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n  }\n  function removeOverlap(spans) {\n    let working = spans;\n    for (let i = 0; i < working.length - 1; i++) {\n      let span = working[i];\n      if (span.from != span.to)\n        for (let j = i + 1; j < working.length; j++) {\n          let next = working[j];\n          if (next.from == span.from) {\n            if (next.to != span.to) {\n              if (working == spans)\n                working = spans.slice();\n              working[j] = next.copy(next.from, span.to);\n              insertAhead(working, j + 1, next.copy(span.to, next.to));\n            }\n            continue;\n          } else {\n            if (next.from < span.to) {\n              if (working == spans)\n                working = spans.slice();\n              working[i] = span.copy(span.from, next.from);\n              insertAhead(working, j, span.copy(next.from, span.to));\n            }\n            break;\n          }\n        }\n    }\n    return working;\n  }\n  function insertAhead(array, i, deco) {\n    while (i < array.length && byPos(deco, array[i]) > 0)\n      i++;\n    array.splice(i, 0, deco);\n  }\n  function viewDecorations(view) {\n    let found2 = [];\n    view.someProp(\"decorations\", (f) => {\n      let result = f(view.state);\n      if (result && result != empty)\n        found2.push(result);\n    });\n    if (view.cursorWrapper)\n      found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n    return DecorationGroup.from(found2);\n  }\n  var observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n  };\n  var useCharData = ie && ie_version <= 11;\n  var SelectionState = class {\n    constructor() {\n      this.anchorNode = null;\n      this.anchorOffset = 0;\n      this.focusNode = null;\n      this.focusOffset = 0;\n    }\n    set(sel) {\n      this.anchorNode = sel.anchorNode;\n      this.anchorOffset = sel.anchorOffset;\n      this.focusNode = sel.focusNode;\n      this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n      this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n  };\n  var DOMObserver = class {\n    constructor(view, handleDOMChange) {\n      this.view = view;\n      this.handleDOMChange = handleDOMChange;\n      this.queue = [];\n      this.flushingSoon = -1;\n      this.observer = null;\n      this.currentSelection = new SelectionState();\n      this.onCharData = null;\n      this.suppressingSelectionUpdates = false;\n      this.lastChangedTextNode = null;\n      this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {\n        for (let i = 0; i < mutations.length; i++)\n          this.queue.push(mutations[i]);\n        if (ie && ie_version <= 11 && mutations.some((m) => m.type == \"childList\" && m.removedNodes.length || m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n          this.flushSoon();\n        else\n          this.flush();\n      });\n      if (useCharData) {\n        this.onCharData = (e) => {\n          this.queue.push({ target: e.target, type: \"characterData\", oldValue: e.prevValue });\n          this.flushSoon();\n        };\n      }\n      this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n      if (this.flushingSoon < 0)\n        this.flushingSoon = window.setTimeout(() => {\n          this.flushingSoon = -1;\n          this.flush();\n        }, 20);\n    }\n    forceFlush() {\n      if (this.flushingSoon > -1) {\n        window.clearTimeout(this.flushingSoon);\n        this.flushingSoon = -1;\n        this.flush();\n      }\n    }\n    start() {\n      if (this.observer) {\n        this.observer.takeRecords();\n        this.observer.observe(this.view.dom, observeOptions);\n      }\n      if (this.onCharData)\n        this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n      this.connectSelection();\n    }\n    stop() {\n      if (this.observer) {\n        let take = this.observer.takeRecords();\n        if (take.length) {\n          for (let i = 0; i < take.length; i++)\n            this.queue.push(take[i]);\n          window.setTimeout(() => this.flush(), 20);\n        }\n        this.observer.disconnect();\n      }\n      if (this.onCharData)\n        this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n      this.disconnectSelection();\n    }\n    connectSelection() {\n      this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n      this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n      this.suppressingSelectionUpdates = true;\n      setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n      if (!hasFocusAndSelection(this.view))\n        return;\n      if (this.suppressingSelectionUpdates)\n        return selectionToDOM(this.view);\n      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n        let sel = this.view.domSelectionRange();\n        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n          return this.flushSoon();\n      }\n      this.flush();\n    }\n    setCurSelection() {\n      this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n      if (!sel.focusNode)\n        return true;\n      let ancestors = /* @__PURE__ */ new Set(), container;\n      for (let scan = sel.focusNode; scan; scan = parentNode(scan))\n        ancestors.add(scan);\n      for (let scan = sel.anchorNode; scan; scan = parentNode(scan))\n        if (ancestors.has(scan)) {\n          container = scan;\n          break;\n        }\n      let desc = container && this.view.docView.nearestDesc(container);\n      if (desc && desc.ignoreMutation({\n        type: \"selection\",\n        target: container.nodeType == 3 ? container.parentNode : container\n      })) {\n        this.setCurSelection();\n        return true;\n      }\n    }\n    pendingRecords() {\n      if (this.observer)\n        for (let mut of this.observer.takeRecords())\n          this.queue.push(mut);\n      return this.queue;\n    }\n    flush() {\n      let { view } = this;\n      if (!view.docView || this.flushingSoon > -1)\n        return;\n      let mutations = this.pendingRecords();\n      if (mutations.length)\n        this.queue = [];\n      let sel = view.domSelectionRange();\n      let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n      let from4 = -1, to = -1, typeOver = false, added = [];\n      if (view.editable) {\n        for (let i = 0; i < mutations.length; i++) {\n          let result = this.registerMutation(mutations[i], added);\n          if (result) {\n            from4 = from4 < 0 ? result.from : Math.min(result.from, from4);\n            to = to < 0 ? result.to : Math.max(result.to, to);\n            if (result.typeOver)\n              typeOver = true;\n          }\n        }\n      }\n      if (gecko && added.length) {\n        let brs = added.filter((n) => n.nodeName == \"BR\");\n        if (brs.length == 2) {\n          let [a, b] = brs;\n          if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n            b.remove();\n          else\n            a.remove();\n        } else {\n          let { focusNode } = this.currentSelection;\n          for (let br of brs) {\n            let parent = br.parentNode;\n            if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent))\n              br.remove();\n          }\n        }\n      }\n      let readSel = null;\n      if (from4 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {\n        view.input.lastFocus = 0;\n        selectionToDOM(view);\n        this.currentSelection.set(sel);\n        view.scrollToSelection();\n      } else if (from4 > -1 || newSel) {\n        if (from4 > -1) {\n          view.docView.markDirty(from4, to);\n          checkCSS(view);\n        }\n        this.handleDOMChange(from4, to, typeOver, added);\n        if (view.docView && view.docView.dirty)\n          view.updateState(view.state);\n        else if (!this.currentSelection.eq(sel))\n          selectionToDOM(view);\n        this.currentSelection.set(sel);\n      }\n    }\n    registerMutation(mut, added) {\n      if (added.indexOf(mut.target) > -1)\n        return null;\n      let desc = this.view.docView.nearestDesc(mut.target);\n      if (mut.type == \"attributes\" && (desc == this.view.docView || mut.attributeName == \"contenteditable\" || // Firefox sometimes fires spurious events for null/empty styles\n      mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\")))\n        return null;\n      if (!desc || desc.ignoreMutation(mut))\n        return null;\n      if (mut.type == \"childList\") {\n        for (let i = 0; i < mut.addedNodes.length; i++) {\n          let node = mut.addedNodes[i];\n          added.push(node);\n          if (node.nodeType == 3)\n            this.lastChangedTextNode = node;\n        }\n        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n          return { from: desc.posBefore, to: desc.posAfter };\n        let prev = mut.previousSibling, next = mut.nextSibling;\n        if (ie && ie_version <= 11 && mut.addedNodes.length) {\n          for (let i = 0; i < mut.addedNodes.length; i++) {\n            let { previousSibling, nextSibling } = mut.addedNodes[i];\n            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n              prev = previousSibling;\n            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n              next = nextSibling;\n          }\n        }\n        let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;\n        let from4 = desc.localPosFromDOM(mut.target, fromOffset, -1);\n        let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;\n        let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n        return { from: from4, to };\n      } else if (mut.type == \"attributes\") {\n        return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n      } else {\n        this.lastChangedTextNode = mut.target;\n        return {\n          from: desc.posAtStart,\n          to: desc.posAtEnd,\n          // An event was generated for a text change that didn't change\n          // any text. Mark the dom change to fall back to assuming the\n          // selection was typed over with an identical value if it can't\n          // find another change.\n          typeOver: mut.target.nodeValue == mut.oldValue\n        };\n      }\n    }\n  };\n  var cssChecked = /* @__PURE__ */ new WeakMap();\n  var cssCheckWarned = false;\n  function checkCSS(view) {\n    if (cssChecked.has(view))\n      return;\n    cssChecked.set(view, null);\n    if ([\"normal\", \"nowrap\", \"pre-line\"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n      view.requiresGeckoHackNode = gecko;\n      if (cssCheckWarned)\n        return;\n      console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n      cssCheckWarned = true;\n    }\n  }\n  function rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n      [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n  }\n  function safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n      let range = selection.getComposedRanges(view.root)[0];\n      if (range)\n        return rangeToSelectionRange(view, range);\n    }\n    let found2;\n    function read(event) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      found2 = event.getTargetRanges()[0];\n    }\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found2 ? rangeToSelectionRange(view, found2) : null;\n  }\n  function blockParent(view, node) {\n    for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {\n      let desc = view.docView.nearestDesc(p, true);\n      if (desc && desc.node.isBlock)\n        return p;\n    }\n    return null;\n  }\n  function parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from: from4, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find2;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n      find2 = [{ node: anchor, offset: domSel.anchorOffset }];\n      if (!selectionCollapsed(domSel))\n        find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n    }\n    if (chrome && view.input.lastKeyCode === 8) {\n      for (let off = toOffset; off > fromOffset; off--) {\n        let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n        if (node.nodeName == \"BR\" && !desc) {\n          toOffset = off;\n          break;\n        }\n        if (!desc || desc.size)\n          break;\n      }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || DOMParser2.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from4);\n    let sel = null, doc4 = parser.parse(parent, {\n      topNode: $from.parent,\n      topMatch: $from.parent.contentMatchAt($from.index()),\n      topOpen: true,\n      from: fromOffset,\n      to: toOffset,\n      preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n      findPositions: find2,\n      ruleFromNode,\n      context: $from\n    });\n    if (find2 && find2[0].pos != null) {\n      let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;\n      if (head == null)\n        head = anchor2;\n      sel = { anchor: anchor2 + from4, head: head + from4 };\n    }\n    return { doc: doc4, sel, from: from4, to };\n  }\n  function ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n      return desc.parseRule();\n    } else if (dom.nodeName == \"BR\" && dom.parentNode) {\n      if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n        let skip = document.createElement(\"div\");\n        skip.appendChild(document.createElement(\"li\"));\n        return { skip };\n      } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n        return { ignore: true };\n      }\n    } else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n      return { ignore: true };\n    }\n    return null;\n  }\n  var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\n  function readDOMChange(view, from4, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from4 < 0) {\n      let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n      let newSel = selectionFromDOM(view, origin);\n      if (newSel && !view.state.selection.eq(newSel)) {\n        if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\"))))\n          return;\n        let tr = view.state.tr.setSelection(newSel);\n        if (origin == \"pointer\")\n          tr.setMeta(\"pointer\", true);\n        else if (origin == \"key\")\n          tr.scrollIntoView();\n        if (compositionID)\n          tr.setMeta(\"composition\", compositionID);\n        view.dispatch(tr);\n      }\n      return;\n    }\n    let $before = view.state.doc.resolve(from4);\n    let shared = $before.sharedDepth(to);\n    from4 = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from4, to);\n    let doc4 = view.state.doc, compare = doc4.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n      preferredPos = view.state.selection.to;\n      preferredSide = \"end\";\n    } else {\n      preferredPos = view.state.selection.from;\n      preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if (change)\n      view.input.domChangeCount++;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n      view.input.lastIOSEnter = 0;\n      return;\n    }\n    if (!change) {\n      if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n        change = { start: sel.from, endA: sel.to, endB: sel.to };\n      } else {\n        if (parse.sel) {\n          let sel2 = resolveSelection(view, view.state.doc, parse.sel);\n          if (sel2 && !sel2.eq(view.state.selection)) {\n            let tr = view.state.tr.setSelection(sel2);\n            if (compositionID)\n              tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n          }\n        }\n        return;\n      }\n    }\n    if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {\n      if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {\n        change.start = view.state.selection.from;\n      } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {\n        change.endB += view.state.selection.to - change.endA;\n        change.endA = view.state.selection.to;\n      }\n    }\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\xA0\") {\n      change.start--;\n      change.endA--;\n      change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc4.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == \"DIV\" || n.nodeName == \"P\")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\\S/.test(parse.doc.textBetween($from.pos, $to.pos, \"\", \"\"))) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(13, \"Enter\")))) {\n      view.input.lastIOSEnter = 0;\n      return;\n    }\n    if (view.state.selection.anchor > change.start && looksLikeBackspace(doc4, change.start, change.endA, $from, $to) && view.someProp(\"handleKeyDown\", (f) => f(view, keyEvent(8, \"Backspace\")))) {\n      if (android && chrome)\n        view.domObserver.suppressSelectionUpdates();\n      return;\n    }\n    if (chrome && change.endB == change.start)\n      view.input.lastChromeDelete = Date.now();\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n      change.endB -= 2;\n      $to = parse.doc.resolveNoCache(change.endB - parse.from);\n      setTimeout(() => {\n        view.someProp(\"handleKeyDown\", function(f) {\n          return f(view, keyEvent(13, \"Enter\"));\n        });\n      }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let mkTr = (base2) => {\n      let tr = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n      if (parse.sel) {\n        let sel2 = resolveSelection(view, tr.doc, parse.sel);\n        if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie && sel2.empty && sel2.head == chFrom))\n          tr.setSelection(sel2);\n      }\n      if (compositionID)\n        tr.setMeta(\"composition\", compositionID);\n      return tr.scrollIntoView();\n    };\n    let markChange;\n    if (inlineChange) {\n      if ($from.pos == $to.pos) {\n        if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n          view.domObserver.suppressSelectionUpdates();\n          setTimeout(() => selectionToDOM(view), 20);\n        }\n        let tr = mkTr(view.state.tr.delete(chFrom, chTo));\n        let marks2 = doc4.resolve(change.start).marksAcross(doc4.resolve(change.endA));\n        if (marks2)\n          tr.ensureMarks(marks2);\n        view.dispatch(tr);\n      } else if (\n        // Adding or removing a mark\n        change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))\n      ) {\n        let tr = mkTr(view.state.tr);\n        if (markChange.type == \"add\")\n          tr.addMark(chFrom, chTo, markChange.mark);\n        else\n          tr.removeMark(chFrom, chTo, markChange.mark);\n        view.dispatch(tr);\n      } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n        let text2 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n        let deflt = () => mkTr(view.state.tr.insertText(text2, chFrom, chTo));\n        if (!view.someProp(\"handleTextInput\", (f) => f(view, chFrom, chTo, text2, deflt)))\n          view.dispatch(deflt());\n      } else {\n        view.dispatch(mkTr());\n      }\n    } else {\n      view.dispatch(mkTr());\n    }\n  }\n  function resolveSelection(view, doc4, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc4.content.size)\n      return null;\n    return selectionBetween(view, doc4.resolve(parsedSel.anchor), doc4.resolve(parsedSel.head));\n  }\n  function isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for (let i = 0; i < prevMarks.length; i++)\n      added = prevMarks[i].removeFromSet(added);\n    for (let i = 0; i < curMarks.length; i++)\n      removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n      mark = added[0];\n      type = \"add\";\n      update = (node) => node.mark(mark.addToSet(node.marks));\n    } else if (added.length == 0 && removed.length == 1) {\n      mark = removed[0];\n      type = \"remove\";\n      update = (node) => node.mark(mark.removeFromSet(node.marks));\n    } else {\n      return null;\n    }\n    let updated = [];\n    for (let i = 0; i < prev.childCount; i++)\n      updated.push(update(prev.child(i)));\n    if (Fragment.from(updated).eq(cur))\n      return { mark, type };\n  }\n  function looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if (\n      // The content must have shrunk\n      end - start <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into\n      skipClosingAndOpening($newStart, true, false) < $newEnd.pos\n    )\n      return false;\n    let $start = old.resolve(start);\n    if (!$newStart.parent.isTextblock) {\n      let after = $start.nodeAfter;\n      return after != null && end == start + after.nodeSize;\n    }\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n      return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end)\n      return false;\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n  }\n  function skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n      depth--;\n      end++;\n      fromEnd = false;\n    }\n    if (mayOpen) {\n      let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n      while (next && !next.isLeaf) {\n        next = next.firstChild;\n        end++;\n      }\n    }\n    return end;\n  }\n  function findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null)\n      return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n      let adjust = Math.max(0, start - Math.min(endA, endB));\n      preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n      let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n      start -= move;\n      if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))\n        start += move ? 1 : -1;\n      endB = start + (endB - endA);\n      endA = start;\n    } else if (endB < start) {\n      let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n      start -= move;\n      if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))\n        start += move ? 1 : -1;\n      endA = start + (endA - endB);\n      endB = start;\n    }\n    return { start, endA, endB };\n  }\n  function isSurrogatePair(str) {\n    if (str.length != 2)\n      return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;\n  }\n  var EditorView = class {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */\n    constructor(place, props) {\n      this._root = null;\n      this.focused = false;\n      this.trackWrites = null;\n      this.mounted = false;\n      this.markCursor = null;\n      this.cursorWrapper = null;\n      this.lastSelectedViewDesc = void 0;\n      this.input = new InputState();\n      this.prevDirectPlugins = [];\n      this.pluginViews = [];\n      this.requiresGeckoHackNode = false;\n      this.dragging = null;\n      this._props = props;\n      this.state = props.state;\n      this.directPlugins = props.plugins || [];\n      this.directPlugins.forEach(checkStateComponent);\n      this.dispatch = this.dispatch.bind(this);\n      this.dom = place && place.mount || document.createElement(\"div\");\n      if (place) {\n        if (place.appendChild)\n          place.appendChild(this.dom);\n        else if (typeof place == \"function\")\n          place(this.dom);\n        else if (place.mount)\n          this.mounted = true;\n      }\n      this.editable = getEditable(this);\n      updateCursorWrapper(this);\n      this.nodeViews = buildNodeViews(this);\n      this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n      this.domObserver = new DOMObserver(this, (from4, to, typeOver, added) => readDOMChange(this, from4, to, typeOver, added));\n      this.domObserver.start();\n      initInput(this);\n      this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */\n    get composing() {\n      return this.input.composing;\n    }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */\n    get props() {\n      if (this._props.state != this.state) {\n        let prev = this._props;\n        this._props = {};\n        for (let name in prev)\n          this._props[name] = prev[name];\n        this._props.state = this.state;\n      }\n      return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */\n    update(props) {\n      if (props.handleDOMEvents != this._props.handleDOMEvents)\n        ensureListeners(this);\n      let prevProps = this._props;\n      this._props = props;\n      if (props.plugins) {\n        props.plugins.forEach(checkStateComponent);\n        this.directPlugins = props.plugins;\n      }\n      this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */\n    setProps(props) {\n      let updated = {};\n      for (let name in this._props)\n        updated[name] = this._props[name];\n      updated.state = this.state;\n      for (let name in props)\n        updated[name] = props[name];\n      this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */\n    updateState(state) {\n      this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n      var _a;\n      let prev = this.state, redraw = false, updateSel = false;\n      if (state.storedMarks && this.composing) {\n        clearComposition(this);\n        updateSel = true;\n      }\n      this.state = state;\n      let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n        let nodeViews = buildNodeViews(this);\n        if (changedNodeViews(nodeViews, this.nodeViews)) {\n          this.nodeViews = nodeViews;\n          redraw = true;\n        }\n      }\n      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n        ensureListeners(this);\n      }\n      this.editable = getEditable(this);\n      updateCursorWrapper(this);\n      let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n      let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\" : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n      let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n      if (updateDoc || !state.selection.eq(prev.selection))\n        updateSel = true;\n      let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n      if (updateSel) {\n        this.domObserver.stop();\n        let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n        if (updateDoc) {\n          let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;\n          if (this.composing)\n            this.input.compositionNode = findCompositionNode(this);\n          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n            this.docView.updateOuterDeco(outerDeco);\n            this.docView.destroy();\n            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n          }\n          if (chromeKludge && !this.trackWrites)\n            forceSelUpdate = true;\n        }\n        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {\n          selectionToDOM(this, forceSelUpdate);\n        } else {\n          syncNodeSelection(this, state.selection);\n          this.domObserver.setCurSelection();\n        }\n        this.domObserver.start();\n      }\n      this.updatePluginViews(prev);\n      if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))\n        this.updateDraggedNode(this.dragging, prev);\n      if (scroll == \"reset\") {\n        this.dom.scrollTop = 0;\n      } else if (scroll == \"to selection\") {\n        this.scrollToSelection();\n      } else if (oldScrollPos) {\n        resetScrollPos(oldScrollPos);\n      }\n    }\n    /**\n    @internal\n    */\n    scrollToSelection() {\n      let startDOM = this.domSelectionRange().focusNode;\n      if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;\n      else if (this.someProp(\"handleScrollToSelection\", (f) => f(this))) ;\n      else if (this.state.selection instanceof NodeSelection) {\n        let target = this.docView.domAfterPos(this.state.selection.from);\n        if (target.nodeType == 1)\n          scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n      } else {\n        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n      }\n    }\n    destroyPluginViews() {\n      let view;\n      while (view = this.pluginViews.pop())\n        if (view.destroy)\n          view.destroy();\n    }\n    updatePluginViews(prevState) {\n      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n        this.prevDirectPlugins = this.directPlugins;\n        this.destroyPluginViews();\n        for (let i = 0; i < this.directPlugins.length; i++) {\n          let plugin = this.directPlugins[i];\n          if (plugin.spec.view)\n            this.pluginViews.push(plugin.spec.view(this));\n        }\n        for (let i = 0; i < this.state.plugins.length; i++) {\n          let plugin = this.state.plugins[i];\n          if (plugin.spec.view)\n            this.pluginViews.push(plugin.spec.view(this));\n        }\n      } else {\n        for (let i = 0; i < this.pluginViews.length; i++) {\n          let pluginView = this.pluginViews[i];\n          if (pluginView.update)\n            pluginView.update(this, prevState);\n        }\n      }\n    }\n    updateDraggedNode(dragging, prev) {\n      let sel = dragging.node, found2 = -1;\n      if (this.state.doc.nodeAt(sel.from) == sel.node) {\n        found2 = sel.from;\n      } else {\n        let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n        let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n        if (moved == sel.node)\n          found2 = movedPos;\n      }\n      this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));\n    }\n    someProp(propName, f) {\n      let prop = this._props && this._props[propName], value;\n      if (prop != null && (value = f ? f(prop) : prop))\n        return value;\n      for (let i = 0; i < this.directPlugins.length; i++) {\n        let prop2 = this.directPlugins[i].props[propName];\n        if (prop2 != null && (value = f ? f(prop2) : prop2))\n          return value;\n      }\n      let plugins = this.state.plugins;\n      if (plugins)\n        for (let i = 0; i < plugins.length; i++) {\n          let prop2 = plugins[i].props[propName];\n          if (prop2 != null && (value = f ? f(prop2) : prop2))\n            return value;\n        }\n    }\n    /**\n    Query whether the view has focus.\n    */\n    hasFocus() {\n      if (ie) {\n        let node = this.root.activeElement;\n        if (node == this.dom)\n          return true;\n        if (!node || !this.dom.contains(node))\n          return false;\n        while (node && this.dom != node && this.dom.contains(node)) {\n          if (node.contentEditable == \"false\")\n            return false;\n          node = node.parentElement;\n        }\n        return true;\n      }\n      return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */\n    focus() {\n      this.domObserver.stop();\n      if (this.editable)\n        focusPreventScroll(this.dom);\n      selectionToDOM(this);\n      this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */\n    get root() {\n      let cached = this._root;\n      if (cached == null)\n        for (let search = this.dom.parentNode; search; search = search.parentNode) {\n          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {\n            if (!search.getSelection)\n              Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n            return this._root = search;\n          }\n        }\n      return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */\n    updateRoot() {\n      this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */\n    posAtCoords(coords) {\n      return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */\n    coordsAtPos(pos, side = 1) {\n      return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */\n    domAtPos(pos, side = 0) {\n      return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */\n    nodeDOM(pos) {\n      let desc = this.docView.descAt(pos);\n      return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimes—for example when interpreting an event\n    target—you don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */\n    posAtDOM(node, offset, bias = -1) {\n      let pos = this.docView.posFromDOM(node, offset, bias);\n      if (pos == null)\n        throw new RangeError(\"DOM position not inside the editor\");\n      return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */\n    endOfTextblock(dir, state) {\n      return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */\n    pasteHTML(html, event) {\n      return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */\n    pasteText(text2, event) {\n      return doPaste(this, text2, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Serialize the given slice as it would be if it was copied from\n    this editor. Returns a DOM element that contains a\n    representation of the slice as its children, a textual\n    representation, and the transformed slice (which can be\n    different from the given input due to hooks like\n    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).\n    */\n    serializeForClipboard(slice2) {\n      return serializeForClipboard(this, slice2);\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */\n    destroy() {\n      if (!this.docView)\n        return;\n      destroyInput(this);\n      this.destroyPluginViews();\n      if (this.mounted) {\n        this.docView.update(this.state.doc, [], viewDecorations(this), this);\n        this.dom.textContent = \"\";\n      } else if (this.dom.parentNode) {\n        this.dom.parentNode.removeChild(this.dom);\n      }\n      this.docView.destroy();\n      this.docView = null;\n      clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */\n    get isDestroyed() {\n      return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */\n    dispatchEvent(event) {\n      return dispatchEvent(this, event);\n    }\n    /**\n    @internal\n    */\n    domSelectionRange() {\n      let sel = this.domSelection();\n      if (!sel)\n        return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };\n      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */\n    domSelection() {\n      return this.root.getSelection();\n    }\n  };\n  EditorView.prototype.dispatch = function(tr) {\n    let dispatchTransaction = this._props.dispatchTransaction;\n    if (dispatchTransaction)\n      dispatchTransaction.call(this, tr);\n    else\n      this.updateState(this.state.apply(tr));\n  };\n  function computeDocDeco(view) {\n    let attrs = /* @__PURE__ */ Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", (value) => {\n      if (typeof value == \"function\")\n        value = value(view.state);\n      if (value)\n        for (let attr in value) {\n          if (attr == \"class\")\n            attrs.class += \" \" + value[attr];\n          else if (attr == \"style\")\n            attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n          else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n            attrs[attr] = String(value[attr]);\n        }\n    });\n    if (!attrs.translate)\n      attrs.translate = \"no\";\n    return [Decoration.node(0, view.state.doc.content.size, attrs)];\n  }\n  function updateCursorWrapper(view) {\n    if (view.markCursor) {\n      let dom = document.createElement(\"img\");\n      dom.className = \"ProseMirror-separator\";\n      dom.setAttribute(\"mark-placeholder\", \"true\");\n      dom.setAttribute(\"alt\", \"\");\n      view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };\n    } else {\n      view.cursorWrapper = null;\n    }\n  }\n  function getEditable(view) {\n    return !view.someProp(\"editable\", (value) => value(view.state) === false);\n  }\n  function selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n  }\n  function buildNodeViews(view) {\n    let result = /* @__PURE__ */ Object.create(null);\n    function add2(obj) {\n      for (let prop in obj)\n        if (!Object.prototype.hasOwnProperty.call(result, prop))\n          result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add2);\n    view.someProp(\"markViews\", add2);\n    return result;\n  }\n  function changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for (let prop in a) {\n      if (a[prop] != b[prop])\n        return true;\n      nA++;\n    }\n    for (let _ in b)\n      nB++;\n    return nA != nB;\n  }\n  function checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n      throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n  }\n\n  // node_modules/prosemirror-schema-basic/dist/index.js\n  var pDOM = [\"p\", 0];\n  var blockquoteDOM = [\"blockquote\", 0];\n  var hrDOM = [\"hr\"];\n  var preDOM = [\"pre\", [\"code\", 0]];\n  var brDOM = [\"br\"];\n  var nodes = {\n    /**\n    NodeSpec The top level document node.\n    */\n    doc: {\n      content: \"block+\"\n    },\n    /**\n    A plain paragraph textblock. Represented in the DOM\n    as a `<p>` element.\n    */\n    paragraph: {\n      content: \"inline*\",\n      group: \"block\",\n      parseDOM: [{ tag: \"p\" }],\n      toDOM() {\n        return pDOM;\n      }\n    },\n    /**\n    A blockquote (`<blockquote>`) wrapping one or more blocks.\n    */\n    blockquote: {\n      content: \"block+\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [{ tag: \"blockquote\" }],\n      toDOM() {\n        return blockquoteDOM;\n      }\n    },\n    /**\n    A horizontal rule (`<hr>`).\n    */\n    horizontal_rule: {\n      group: \"block\",\n      parseDOM: [{ tag: \"hr\" }],\n      toDOM() {\n        return hrDOM;\n      }\n    },\n    /**\n    A heading textblock, with a `level` attribute that\n    should hold the number 1 to 6. Parsed and serialized as `<h1>` to\n    `<h6>` elements.\n    */\n    heading: {\n      attrs: { level: { default: 1, validate: \"number\" } },\n      content: \"inline*\",\n      group: \"block\",\n      defining: true,\n      parseDOM: [\n        { tag: \"h1\", attrs: { level: 1 } },\n        { tag: \"h2\", attrs: { level: 2 } },\n        { tag: \"h3\", attrs: { level: 3 } },\n        { tag: \"h4\", attrs: { level: 4 } },\n        { tag: \"h5\", attrs: { level: 5 } },\n        { tag: \"h6\", attrs: { level: 6 } }\n      ],\n      toDOM(node) {\n        return [\"h\" + node.attrs.level, 0];\n      }\n    },\n    /**\n    A code listing. Disallows marks or non-text inline\n    nodes by default. Represented as a `<pre>` element with a\n    `<code>` element inside of it.\n    */\n    code_block: {\n      content: \"text*\",\n      marks: \"\",\n      group: \"block\",\n      code: true,\n      defining: true,\n      parseDOM: [{ tag: \"pre\", preserveWhitespace: \"full\" }],\n      toDOM() {\n        return preDOM;\n      }\n    },\n    /**\n    The text node.\n    */\n    text: {\n      group: \"inline\"\n    },\n    /**\n    An inline image (`<img>`) node. Supports `src`,\n    `alt`, and `href` attributes. The latter two default to the empty\n    string.\n    */\n    image: {\n      inline: true,\n      attrs: {\n        src: { validate: \"string\" },\n        alt: { default: null, validate: \"string|null\" },\n        title: { default: null, validate: \"string|null\" }\n      },\n      group: \"inline\",\n      draggable: true,\n      parseDOM: [{ tag: \"img[src]\", getAttrs(dom) {\n        return {\n          src: dom.getAttribute(\"src\"),\n          title: dom.getAttribute(\"title\"),\n          alt: dom.getAttribute(\"alt\")\n        };\n      } }],\n      toDOM(node) {\n        let { src, alt, title } = node.attrs;\n        return [\"img\", { src, alt, title }];\n      }\n    },\n    /**\n    A hard line break, represented in the DOM as `<br>`.\n    */\n    hard_break: {\n      inline: true,\n      group: \"inline\",\n      selectable: false,\n      parseDOM: [{ tag: \"br\" }],\n      toDOM() {\n        return brDOM;\n      }\n    }\n  };\n  var emDOM = [\"em\", 0];\n  var strongDOM = [\"strong\", 0];\n  var codeDOM = [\"code\", 0];\n  var marks = {\n    /**\n    A link. Has `href` and `title` attributes. `title`\n    defaults to the empty string. Rendered and parsed as an `<a>`\n    element.\n    */\n    link: {\n      attrs: {\n        href: { validate: \"string\" },\n        title: { default: null, validate: \"string|null\" }\n      },\n      inclusive: false,\n      parseDOM: [{ tag: \"a[href]\", getAttrs(dom) {\n        return { href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\") };\n      } }],\n      toDOM(node) {\n        let { href, title } = node.attrs;\n        return [\"a\", { href, title }, 0];\n      }\n    },\n    /**\n    An emphasis mark. Rendered as an `<em>` element. Has parse rules\n    that also match `<i>` and `font-style: italic`.\n    */\n    em: {\n      parseDOM: [\n        { tag: \"i\" },\n        { tag: \"em\" },\n        { style: \"font-style=italic\" },\n        { style: \"font-style=normal\", clearMark: (m) => m.type.name == \"em\" }\n      ],\n      toDOM() {\n        return emDOM;\n      }\n    },\n    /**\n    A strong mark. Rendered as `<strong>`, parse rules also match\n    `<b>` and `font-weight: bold`.\n    */\n    strong: {\n      parseDOM: [\n        { tag: \"strong\" },\n        // This works around a Google Docs misbehavior where\n        // pasted content will be inexplicably wrapped in `<b>`\n        // tags with a font-weight normal.\n        { tag: \"b\", getAttrs: (node) => node.style.fontWeight != \"normal\" && null },\n        { style: \"font-weight=400\", clearMark: (m) => m.type.name == \"strong\" },\n        { style: \"font-weight\", getAttrs: (value) => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null }\n      ],\n      toDOM() {\n        return strongDOM;\n      }\n    },\n    /**\n    Code font mark. Represented as a `<code>` element.\n    */\n    code: {\n      code: true,\n      parseDOM: [{ tag: \"code\" }],\n      toDOM() {\n        return codeDOM;\n      }\n    }\n  };\n  var schema = new Schema({ nodes, marks });\n\n  // node_modules/prosemirror-schema-list/dist/index.js\n  var olDOM = [\"ol\", 0];\n  var ulDOM = [\"ul\", 0];\n  var liDOM = [\"li\", 0];\n  var orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n      return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n    } }],\n    toDOM(node) {\n      return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n  };\n  var bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() {\n      return ulDOM;\n    }\n  };\n  var listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() {\n      return liDOM;\n    },\n    defining: true\n  };\n  function add(obj, props) {\n    let copy3 = {};\n    for (let prop in obj)\n      copy3[prop] = obj[prop];\n    for (let prop in props)\n      copy3[prop] = props[prop];\n    return copy3;\n  }\n  function addListNodes(nodes2, itemContent, listGroup) {\n    return nodes2.append({\n      ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n      bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n      list_item: add(listItem, { content: itemContent })\n    });\n  }\n\n  // node_modules/w3c-keyname/index.js\n  var base = {\n    8: \"Backspace\",\n    9: \"Tab\",\n    10: \"Enter\",\n    12: \"NumLock\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Control\",\n    18: \"Alt\",\n    20: \"CapsLock\",\n    27: \"Escape\",\n    32: \" \",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"ArrowLeft\",\n    38: \"ArrowUp\",\n    39: \"ArrowRight\",\n    40: \"ArrowDown\",\n    44: \"PrintScreen\",\n    45: \"Insert\",\n    46: \"Delete\",\n    59: \";\",\n    61: \"=\",\n    91: \"Meta\",\n    92: \"Meta\",\n    106: \"*\",\n    107: \"+\",\n    108: \",\",\n    109: \"-\",\n    110: \".\",\n    111: \"/\",\n    144: \"NumLock\",\n    145: \"ScrollLock\",\n    160: \"Shift\",\n    161: \"Shift\",\n    162: \"Control\",\n    163: \"Control\",\n    164: \"Alt\",\n    165: \"Alt\",\n    173: \"-\",\n    186: \";\",\n    187: \"=\",\n    188: \",\",\n    189: \"-\",\n    190: \".\",\n    191: \"/\",\n    192: \"`\",\n    219: \"[\",\n    220: \"\\\\\",\n    221: \"]\",\n    222: \"'\"\n  };\n  var shift = {\n    48: \")\",\n    49: \"!\",\n    50: \"@\",\n    51: \"#\",\n    52: \"$\",\n    53: \"%\",\n    54: \"^\",\n    55: \"&\",\n    56: \"*\",\n    57: \"(\",\n    59: \":\",\n    61: \"+\",\n    173: \"_\",\n    186: \":\",\n    187: \"+\",\n    188: \"<\",\n    189: \"_\",\n    190: \">\",\n    191: \"?\",\n    192: \"~\",\n    219: \"{\",\n    220: \"|\",\n    221: \"}\",\n    222: '\"'\n  };\n  var mac2 = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform);\n  var ie2 = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\n  for (i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);\n  var i;\n  for (i = 1; i <= 24; i++) base[i + 111] = \"F\" + i;\n  var i;\n  for (i = 65; i <= 90; i++) {\n    base[i] = String.fromCharCode(i + 32);\n    shift[i] = String.fromCharCode(i);\n  }\n  var i;\n  for (code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];\n  var code;\n  function keyName(event) {\n    var ignoreKey = mac2 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie2 && event.shiftKey && event.key && event.key.length == 1 || event.key == \"Unidentified\";\n    var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || \"Unidentified\";\n    if (name == \"Esc\") name = \"Escape\";\n    if (name == \"Del\") name = \"Delete\";\n    if (name == \"Left\") name = \"ArrowLeft\";\n    if (name == \"Up\") name = \"ArrowUp\";\n    if (name == \"Right\") name = \"ArrowRight\";\n    if (name == \"Down\") name = \"ArrowDown\";\n    return name;\n  }\n\n  // node_modules/prosemirror-keymap/dist/index.js\n  var mac3 = typeof navigator != \"undefined\" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);\n  var windows2 = typeof navigator != \"undefined\" && /Win/.test(navigator.platform);\n  function normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n      result = \" \";\n    let alt, ctrl, shift2, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n      let mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod))\n        meta = true;\n      else if (/^a(lt)?$/i.test(mod))\n        alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod))\n        ctrl = true;\n      else if (/^s(hift)?$/i.test(mod))\n        shift2 = true;\n      else if (/^mod$/i.test(mod)) {\n        if (mac3)\n          meta = true;\n        else\n          ctrl = true;\n      } else\n        throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n      result = \"Alt-\" + result;\n    if (ctrl)\n      result = \"Ctrl-\" + result;\n    if (meta)\n      result = \"Meta-\" + result;\n    if (shift2)\n      result = \"Shift-\" + result;\n    return result;\n  }\n  function normalize(map3) {\n    let copy3 = /* @__PURE__ */ Object.create(null);\n    for (let prop in map3)\n      copy3[normalizeKeyName(prop)] = map3[prop];\n    return copy3;\n  }\n  function modifiers(name, event, shift2 = true) {\n    if (event.altKey)\n      name = \"Alt-\" + name;\n    if (event.ctrlKey)\n      name = \"Ctrl-\" + name;\n    if (event.metaKey)\n      name = \"Meta-\" + name;\n    if (shift2 && event.shiftKey)\n      name = \"Shift-\" + name;\n    return name;\n  }\n  function keymap(bindings) {\n    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n  }\n  function keydownHandler(bindings) {\n    let map3 = normalize(bindings);\n    return function(view, event) {\n      let name = keyName(event), baseName, direct = map3[modifiers(name, event)];\n      if (direct && direct(view.state, view.dispatch, view))\n        return true;\n      if (name.length == 1 && name != \" \") {\n        if (event.shiftKey) {\n          let noShift = map3[modifiers(name, event, false)];\n          if (noShift && noShift(view.state, view.dispatch, view))\n            return true;\n        }\n        if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n        !(windows2 && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {\n          let fromCode = map3[modifiers(baseName, event)];\n          if (fromCode && fromCode(view.state, view.dispatch, view))\n            return true;\n        }\n      }\n      return false;\n    };\n  }\n\n  // node_modules/rope-sequence/dist/index.js\n  var GOOD_LEAF_SIZE = 200;\n  var RopeSequence = function RopeSequence2() {\n  };\n  RopeSequence.prototype.append = function append(other) {\n    if (!other.length) {\n      return this;\n    }\n    other = RopeSequence.from(other);\n    return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);\n  };\n  RopeSequence.prototype.prepend = function prepend(other) {\n    if (!other.length) {\n      return this;\n    }\n    return RopeSequence.from(other).append(this);\n  };\n  RopeSequence.prototype.appendInner = function appendInner(other) {\n    return new Append(this, other);\n  };\n  RopeSequence.prototype.slice = function slice(from4, to) {\n    if (from4 === void 0) from4 = 0;\n    if (to === void 0) to = this.length;\n    if (from4 >= to) {\n      return RopeSequence.empty;\n    }\n    return this.sliceInner(Math.max(0, from4), Math.min(this.length, to));\n  };\n  RopeSequence.prototype.get = function get(i) {\n    if (i < 0 || i >= this.length) {\n      return void 0;\n    }\n    return this.getInner(i);\n  };\n  RopeSequence.prototype.forEach = function forEach(f, from4, to) {\n    if (from4 === void 0) from4 = 0;\n    if (to === void 0) to = this.length;\n    if (from4 <= to) {\n      this.forEachInner(f, from4, to, 0);\n    } else {\n      this.forEachInvertedInner(f, from4, to, 0);\n    }\n  };\n  RopeSequence.prototype.map = function map(f, from4, to) {\n    if (from4 === void 0) from4 = 0;\n    if (to === void 0) to = this.length;\n    var result = [];\n    this.forEach(function(elt, i) {\n      return result.push(f(elt, i));\n    }, from4, to);\n    return result;\n  };\n  RopeSequence.from = function from(values) {\n    if (values instanceof RopeSequence) {\n      return values;\n    }\n    return values && values.length ? new Leaf(values) : RopeSequence.empty;\n  };\n  var Leaf = /* @__PURE__ */ (function(RopeSequence3) {\n    function Leaf2(values) {\n      RopeSequence3.call(this);\n      this.values = values;\n    }\n    if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;\n    Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n    Leaf2.prototype.constructor = Leaf2;\n    var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };\n    Leaf2.prototype.flatten = function flatten() {\n      return this.values;\n    };\n    Leaf2.prototype.sliceInner = function sliceInner(from4, to) {\n      if (from4 == 0 && to == this.length) {\n        return this;\n      }\n      return new Leaf2(this.values.slice(from4, to));\n    };\n    Leaf2.prototype.getInner = function getInner(i) {\n      return this.values[i];\n    };\n    Leaf2.prototype.forEachInner = function forEachInner(f, from4, to, start) {\n      for (var i = from4; i < to; i++) {\n        if (f(this.values[i], start + i) === false) {\n          return false;\n        }\n      }\n    };\n    Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from4, to, start) {\n      for (var i = from4 - 1; i >= to; i--) {\n        if (f(this.values[i], start + i) === false) {\n          return false;\n        }\n      }\n    };\n    Leaf2.prototype.leafAppend = function leafAppend(other) {\n      if (this.length + other.length <= GOOD_LEAF_SIZE) {\n        return new Leaf2(this.values.concat(other.flatten()));\n      }\n    };\n    Leaf2.prototype.leafPrepend = function leafPrepend(other) {\n      if (this.length + other.length <= GOOD_LEAF_SIZE) {\n        return new Leaf2(other.flatten().concat(this.values));\n      }\n    };\n    prototypeAccessors.length.get = function() {\n      return this.values.length;\n    };\n    prototypeAccessors.depth.get = function() {\n      return 0;\n    };\n    Object.defineProperties(Leaf2.prototype, prototypeAccessors);\n    return Leaf2;\n  })(RopeSequence);\n  RopeSequence.empty = new Leaf([]);\n  var Append = /* @__PURE__ */ (function(RopeSequence3) {\n    function Append2(left, right) {\n      RopeSequence3.call(this);\n      this.left = left;\n      this.right = right;\n      this.length = left.length + right.length;\n      this.depth = Math.max(left.depth, right.depth) + 1;\n    }\n    if (RopeSequence3) Append2.__proto__ = RopeSequence3;\n    Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);\n    Append2.prototype.constructor = Append2;\n    Append2.prototype.flatten = function flatten() {\n      return this.left.flatten().concat(this.right.flatten());\n    };\n    Append2.prototype.getInner = function getInner(i) {\n      return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);\n    };\n    Append2.prototype.forEachInner = function forEachInner(f, from4, to, start) {\n      var leftLen = this.left.length;\n      if (from4 < leftLen && this.left.forEachInner(f, from4, Math.min(to, leftLen), start) === false) {\n        return false;\n      }\n      if (to > leftLen && this.right.forEachInner(f, Math.max(from4 - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {\n        return false;\n      }\n    };\n    Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from4, to, start) {\n      var leftLen = this.left.length;\n      if (from4 > leftLen && this.right.forEachInvertedInner(f, from4 - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {\n        return false;\n      }\n      if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from4, leftLen), to, start) === false) {\n        return false;\n      }\n    };\n    Append2.prototype.sliceInner = function sliceInner(from4, to) {\n      if (from4 == 0 && to == this.length) {\n        return this;\n      }\n      var leftLen = this.left.length;\n      if (to <= leftLen) {\n        return this.left.slice(from4, to);\n      }\n      if (from4 >= leftLen) {\n        return this.right.slice(from4 - leftLen, to - leftLen);\n      }\n      return this.left.slice(from4, leftLen).append(this.right.slice(0, to - leftLen));\n    };\n    Append2.prototype.leafAppend = function leafAppend(other) {\n      var inner = this.right.leafAppend(other);\n      if (inner) {\n        return new Append2(this.left, inner);\n      }\n    };\n    Append2.prototype.leafPrepend = function leafPrepend(other) {\n      var inner = this.left.leafPrepend(other);\n      if (inner) {\n        return new Append2(inner, this.right);\n      }\n    };\n    Append2.prototype.appendInner = function appendInner2(other) {\n      if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {\n        return new Append2(this.left, new Append2(this.right, other));\n      }\n      return new Append2(this, other);\n    };\n    return Append2;\n  })(RopeSequence);\n  var dist_default2 = RopeSequence;\n\n  // node_modules/prosemirror-history/dist/index.js\n  var max_empty_items = 500;\n  var Branch = class _Branch {\n    constructor(items, eventCount) {\n      this.items = items;\n      this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n      if (this.eventCount == 0)\n        return null;\n      let end = this.items.length;\n      for (; ; end--) {\n        let next = this.items.get(end - 1);\n        if (next.selection) {\n          --end;\n          break;\n        }\n      }\n      let remap, mapFrom;\n      if (preserveItems) {\n        remap = this.remapping(end, this.items.length);\n        mapFrom = remap.maps.length;\n      }\n      let transform = state.tr;\n      let selection, remaining;\n      let addAfter = [], addBefore = [];\n      this.items.forEach((item, i) => {\n        if (!item.step) {\n          if (!remap) {\n            remap = this.remapping(end, i + 1);\n            mapFrom = remap.maps.length;\n          }\n          mapFrom--;\n          addBefore.push(item);\n          return;\n        }\n        if (remap) {\n          addBefore.push(new Item(item.map));\n          let step = item.step.map(remap.slice(mapFrom)), map3;\n          if (step && transform.maybeStep(step).doc) {\n            map3 = transform.mapping.maps[transform.mapping.maps.length - 1];\n            addAfter.push(new Item(map3, void 0, void 0, addAfter.length + addBefore.length));\n          }\n          mapFrom--;\n          if (map3)\n            remap.appendMap(map3, mapFrom);\n        } else {\n          transform.maybeStep(item.step);\n        }\n        if (item.selection) {\n          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n          remaining = new _Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n          return false;\n        }\n      }, this.items.length, 0);\n      return { remaining, transform, selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n      let newItems = [], eventCount = this.eventCount;\n      let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n      for (let i = 0; i < transform.steps.length; i++) {\n        let step = transform.steps[i].invert(transform.docs[i]);\n        let item = new Item(transform.mapping.maps[i], step, selection), merged;\n        if (merged = lastItem && lastItem.merge(item)) {\n          item = merged;\n          if (i)\n            newItems.pop();\n          else\n            oldItems = oldItems.slice(0, oldItems.length - 1);\n        }\n        newItems.push(item);\n        if (selection) {\n          eventCount++;\n          selection = void 0;\n        }\n        if (!preserveItems)\n          lastItem = item;\n      }\n      let overflow = eventCount - histOptions.depth;\n      if (overflow > DEPTH_OVERFLOW) {\n        oldItems = cutOffEvents(oldItems, overflow);\n        eventCount -= overflow;\n      }\n      return new _Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from4, to) {\n      let maps = new Mapping();\n      this.items.forEach((item, i) => {\n        let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from4 ? maps.maps.length - item.mirrorOffset : void 0;\n        maps.appendMap(item.map, mirrorPos);\n      }, from4, to);\n      return maps;\n    }\n    addMaps(array) {\n      if (this.eventCount == 0)\n        return this;\n      return new _Branch(this.items.append(array.map((map3) => new Item(map3))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n      if (!this.eventCount)\n        return this;\n      let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n      let mapping = rebasedTransform.mapping;\n      let newUntil = rebasedTransform.steps.length;\n      let eventCount = this.eventCount;\n      this.items.forEach((item) => {\n        if (item.selection)\n          eventCount--;\n      }, start);\n      let iRebased = rebasedCount;\n      this.items.forEach((item) => {\n        let pos = mapping.getMirror(--iRebased);\n        if (pos == null)\n          return;\n        newUntil = Math.min(newUntil, pos);\n        let map3 = mapping.maps[pos];\n        if (item.step) {\n          let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n          let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n          if (selection)\n            eventCount++;\n          rebasedItems.push(new Item(map3, step, selection));\n        } else {\n          rebasedItems.push(new Item(map3));\n        }\n      }, start);\n      let newMaps = [];\n      for (let i = rebasedCount; i < newUntil; i++)\n        newMaps.push(new Item(mapping.maps[i]));\n      let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n      let branch = new _Branch(items, eventCount);\n      if (branch.emptyItemCount() > max_empty_items)\n        branch = branch.compress(this.items.length - rebasedItems.length);\n      return branch;\n    }\n    emptyItemCount() {\n      let count = 0;\n      this.items.forEach((item) => {\n        if (!item.step)\n          count++;\n      });\n      return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n      let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n      let items = [], events = 0;\n      this.items.forEach((item, i) => {\n        if (i >= upto) {\n          items.push(item);\n          if (item.selection)\n            events++;\n        } else if (item.step) {\n          let step = item.step.map(remap.slice(mapFrom)), map3 = step && step.getMap();\n          mapFrom--;\n          if (map3)\n            remap.appendMap(map3, mapFrom);\n          if (step) {\n            let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n            if (selection)\n              events++;\n            let newItem = new Item(map3.invert(), step, selection), merged, last2 = items.length - 1;\n            if (merged = items.length && items[last2].merge(newItem))\n              items[last2] = merged;\n            else\n              items.push(newItem);\n          }\n        } else if (item.map) {\n          mapFrom--;\n        }\n      }, this.items.length, 0);\n      return new _Branch(dist_default2.from(items.reverse()), events);\n    }\n  };\n  Branch.empty = new Branch(dist_default2.empty, 0);\n  function cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n      if (item.selection && n-- == 0) {\n        cutPoint = i;\n        return false;\n      }\n    });\n    return items.slice(cutPoint);\n  }\n  var Item = class _Item {\n    constructor(map3, step, selection, mirrorOffset) {\n      this.map = map3;\n      this.step = step;\n      this.selection = selection;\n      this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n      if (this.step && other.step && !other.selection) {\n        let step = other.step.merge(this.step);\n        if (step)\n          return new _Item(step.getMap().invert(), step, this.selection);\n      }\n    }\n  };\n  var HistoryState = class {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n      this.done = done;\n      this.undone = undone;\n      this.prevRanges = prevRanges;\n      this.prevTime = prevTime;\n      this.prevComposition = prevComposition;\n    }\n  };\n  var DEPTH_OVERFLOW = 20;\n  function applyTransaction(history2, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n      return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n      history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n      return history2;\n    } else if (appended && appended.getMeta(historyKey)) {\n      if (appended.getMeta(historyKey).redo)\n        return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);\n      else\n        return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);\n    } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n      let composition = tr.getMeta(\"composition\");\n      let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));\n      let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n      return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);\n    } else if (rebased = tr.getMeta(\"rebased\")) {\n      return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);\n    } else {\n      return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);\n    }\n  }\n  function isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n      return false;\n    if (!transform.docChanged)\n      return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n      for (let i = 0; i < prevRanges.length; i += 2)\n        if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n          adjacent = true;\n    });\n    return adjacent;\n  }\n  function rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n      maps[i].forEach((_from, _to, from4, to) => result.push(from4, to));\n    return result;\n  }\n  function mapRanges(ranges, mapping) {\n    if (!ranges)\n      return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n      let from4 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n      if (from4 <= to)\n        result.push(from4, to);\n    }\n    return result;\n  }\n  function histTransaction(history2, state, redo2) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);\n    if (!pop)\n      return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });\n  }\n  var cachedPreserveItems = false;\n  var cachedPreserveItemsPlugins = null;\n  function mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n      cachedPreserveItems = false;\n      cachedPreserveItemsPlugins = plugins;\n      for (let i = 0; i < plugins.length; i++)\n        if (plugins[i].spec.historyPreserveItems) {\n          cachedPreserveItems = true;\n          break;\n        }\n    }\n    return cachedPreserveItems;\n  }\n  var historyKey = new PluginKey(\"history\");\n  var closeHistoryKey = new PluginKey(\"closeHistory\");\n  function history(config = {}) {\n    config = {\n      depth: config.depth || 100,\n      newGroupDelay: config.newGroupDelay || 500\n    };\n    return new Plugin({\n      key: historyKey,\n      state: {\n        init() {\n          return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n        },\n        apply(tr, hist, state) {\n          return applyTransaction(hist, state, tr, config);\n        }\n      },\n      config,\n      props: {\n        handleDOMEvents: {\n          beforeinput(view, e) {\n            let inputType = e.inputType;\n            let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n            if (!command)\n              return false;\n            e.preventDefault();\n            return command(view.state, view.dispatch);\n          }\n        }\n      }\n    });\n  }\n  function buildCommand(redo2, scroll) {\n    return (state, dispatch) => {\n      let hist = historyKey.getState(state);\n      if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)\n        return false;\n      if (dispatch) {\n        let tr = histTransaction(hist, state, redo2);\n        if (tr)\n          dispatch(scroll ? tr.scrollIntoView() : tr);\n      }\n      return true;\n    };\n  }\n  var undo = buildCommand(false, true);\n  var redo = buildCommand(true, true);\n  var undoNoScroll = buildCommand(false, false);\n  var redoNoScroll = buildCommand(true, false);\n\n  // node_modules/prosemirror-commands/dist/index.js\n  var deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n  };\n  function atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0))\n      return null;\n    return $cursor;\n  }\n  var joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n      return false;\n    let $cut = findCutBefore($cursor);\n    if (!$cut) {\n      let range = $cursor.blockRange(), target = range && liftTarget(range);\n      if (target == null)\n        return false;\n      if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n      return true;\n    }\n    let before = $cut.nodeBefore;\n    if (deleteBarrier(state, $cut, dispatch, -1))\n      return true;\n    if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n      for (let depth = $cursor.depth; ; depth--) {\n        let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n          if (dispatch) {\n            let tr = state.tr.step(delStep);\n            tr.setSelection(textblockAt(before, \"end\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n            dispatch(tr.scrollIntoView());\n          }\n          return true;\n        }\n        if (depth == 1 || $cursor.node(depth - 1).childCount > 1)\n          break;\n      }\n    }\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n      if (dispatch)\n        dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n      return true;\n    }\n    return false;\n  };\n  function textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild) {\n      if (scan.isTextblock)\n        return true;\n      if (only && scan.childCount != 1)\n        return false;\n    }\n    return false;\n  }\n  var selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty: empty2 } = state.selection, $cut = $head;\n    if (!empty2)\n      return false;\n    if ($head.parent.isTextblock) {\n      if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n        return false;\n      $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !NodeSelection.isSelectable(node))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n  };\n  function findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n      for (let i = $pos.depth - 1; i >= 0; i--) {\n        if ($pos.index(i) > 0)\n          return $pos.doc.resolve($pos.before(i + 1));\n        if ($pos.node(i).type.spec.isolating)\n          break;\n      }\n    return null;\n  }\n  function atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size))\n      return null;\n    return $cursor;\n  }\n  var joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n      return false;\n    let $cut = findCutAfter($cursor);\n    if (!$cut)\n      return false;\n    let after = $cut.nodeAfter;\n    if (deleteBarrier(state, $cut, dispatch, 1))\n      return true;\n    if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n      let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n      if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n        if (dispatch) {\n          let tr = state.tr.step(delStep);\n          tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n          dispatch(tr.scrollIntoView());\n        }\n        return true;\n      }\n    }\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n      if (dispatch)\n        dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n      return true;\n    }\n    return false;\n  };\n  var selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty: empty2 } = state.selection, $cut = $head;\n    if (!empty2)\n      return false;\n    if ($head.parent.isTextblock) {\n      if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n        return false;\n      $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !NodeSelection.isSelectable(node))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n  };\n  function findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n      for (let i = $pos.depth - 1; i >= 0; i--) {\n        let parent = $pos.node(i);\n        if ($pos.index(i) + 1 < parent.childCount)\n          return $pos.doc.resolve($pos.after(i + 1));\n        if (parent.type.spec.isolating)\n          break;\n      }\n    return null;\n  }\n  var newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n  };\n  function defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n      let { type } = match.edge(i);\n      if (type.isTextblock && !type.hasRequiredAttrs())\n        return type;\n    }\n    return null;\n  }\n  var exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n      return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n      return false;\n    if (dispatch) {\n      let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n      tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  };\n  var createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n      return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n      return false;\n    if (dispatch) {\n      let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n      let tr = state.tr.insert(side, type.createAndFill());\n      tr.setSelection(TextSelection.create(tr.doc, side + 1));\n      dispatch(tr.scrollIntoView());\n    }\n    return true;\n  };\n  var liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n      return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n      let before = $cursor.before();\n      if (canSplit(state.doc, before)) {\n        if (dispatch)\n          dispatch(state.tr.split(before).scrollIntoView());\n        return true;\n      }\n    }\n    let range = $cursor.blockRange(), target = range && liftTarget(range);\n    if (target == null)\n      return false;\n    if (dispatch)\n      dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n  };\n  function splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n      let { $from, $to } = state.selection;\n      if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n        if (!$from.parentOffset || !canSplit(state.doc, $from.pos))\n          return false;\n        if (dispatch)\n          dispatch(state.tr.split($from.pos).scrollIntoView());\n        return true;\n      }\n      if (!$from.depth)\n        return false;\n      let types = [];\n      let splitDepth, deflt, atEnd = false, atStart = false;\n      for (let d = $from.depth; ; d--) {\n        let node = $from.node(d);\n        if (node.isBlock) {\n          atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n          atStart = $from.start(d) == $from.pos - ($from.depth - d);\n          deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n          let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n          types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));\n          splitDepth = d;\n          break;\n        } else {\n          if (d == 1)\n            return false;\n          types.unshift(null);\n        }\n      }\n      let tr = state.tr;\n      if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)\n        tr.deleteSelection();\n      let splitPos = tr.mapping.map($from.pos);\n      let can = canSplit(tr.doc, splitPos, types.length, types);\n      if (!can) {\n        types[0] = deflt ? { type: deflt } : null;\n        can = canSplit(tr.doc, splitPos, types.length, types);\n      }\n      if (!can)\n        return false;\n      tr.split(splitPos, types.length, types);\n      if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n        let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);\n        if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n          tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n      }\n      if (dispatch)\n        dispatch(tr.scrollIntoView());\n      return true;\n    };\n  }\n  var splitBlock = splitBlockAs();\n  var selectAll = (state, dispatch) => {\n    if (dispatch)\n      dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n    return true;\n  };\n  function joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n      return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n      if (dispatch)\n        dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n      return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n      return false;\n    if (dispatch)\n      dispatch(state.tr.join($pos.pos).scrollIntoView());\n    return true;\n  }\n  function deleteBarrier(state, $cut, dispatch, dir) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    let isolated = before.type.spec.isolating || after.type.spec.isolating;\n    if (!isolated && joinMaybeClear(state, $cut, dispatch))\n      return true;\n    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n      if (dispatch) {\n        let end = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;\n        for (let i = conn.length - 1; i >= 0; i--)\n          wrap2 = Fragment.from(conn[i].create(null, wrap2));\n        wrap2 = Fragment.from(before.copy(wrap2));\n        let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap2, 1, 0), conn.length, true));\n        let $joinAt = tr.doc.resolve(end + 2 * conn.length);\n        if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))\n          tr.join($joinAt.pos);\n        dispatch(tr.scrollIntoView());\n      }\n      return true;\n    }\n    let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);\n    if (target != null && target >= $cut.depth) {\n      if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n      return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n      let at = before, wrap2 = [];\n      for (; ; ) {\n        wrap2.push(at);\n        if (at.isTextblock)\n          break;\n        at = at.lastChild;\n      }\n      let afterText = after, afterDepth = 1;\n      for (; !afterText.isTextblock; afterText = afterText.firstChild)\n        afterDepth++;\n      if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n        if (dispatch) {\n          let end = Fragment.empty;\n          for (let i = wrap2.length - 1; i >= 0; i--)\n            end = Fragment.from(wrap2[i].copy(end));\n          let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap2.length, 0), 0, true));\n          dispatch(tr.scrollIntoView());\n        }\n        return true;\n      }\n    }\n    return false;\n  }\n  function selectTextblockSide(side) {\n    return function(state, dispatch) {\n      let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n      let depth = $pos.depth;\n      while ($pos.node(depth).isInline) {\n        if (!depth)\n          return false;\n        depth--;\n      }\n      if (!$pos.node(depth).isTextblock)\n        return false;\n      if (dispatch)\n        dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n      return true;\n    };\n  }\n  var selectTextblockStart = selectTextblockSide(-1);\n  var selectTextblockEnd = selectTextblockSide(1);\n  function chainCommands(...commands) {\n    return function(state, dispatch, view) {\n      for (let i = 0; i < commands.length; i++)\n        if (commands[i](state, dispatch, view))\n          return true;\n      return false;\n    };\n  }\n  var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\n  var del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n  var pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n  };\n  var macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n  };\n  for (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\n  var mac4 = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n  var baseKeymap = mac4 ? macBaseKeymap : pcBaseKeymap;\n\n  // node_modules/yjs/dist/yjs.mjs\n  var yjs_exports = {};\n  __export(yjs_exports, {\n    AbsolutePosition: () => AbsolutePosition,\n    AbstractConnector: () => AbstractConnector,\n    AbstractStruct: () => AbstractStruct,\n    AbstractType: () => AbstractType,\n    Array: () => YArray,\n    ContentAny: () => ContentAny,\n    ContentBinary: () => ContentBinary,\n    ContentDeleted: () => ContentDeleted,\n    ContentDoc: () => ContentDoc,\n    ContentEmbed: () => ContentEmbed,\n    ContentFormat: () => ContentFormat,\n    ContentJSON: () => ContentJSON,\n    ContentString: () => ContentString,\n    ContentType: () => ContentType,\n    Doc: () => Doc,\n    GC: () => GC,\n    ID: () => ID,\n    Item: () => Item2,\n    Map: () => YMap,\n    PermanentUserData: () => PermanentUserData,\n    RelativePosition: () => RelativePosition,\n    Skip: () => Skip,\n    Snapshot: () => Snapshot,\n    Text: () => YText,\n    Transaction: () => Transaction2,\n    UndoManager: () => UndoManager,\n    UpdateDecoderV1: () => UpdateDecoderV1,\n    UpdateDecoderV2: () => UpdateDecoderV2,\n    UpdateEncoderV1: () => UpdateEncoderV1,\n    UpdateEncoderV2: () => UpdateEncoderV2,\n    XmlElement: () => YXmlElement,\n    XmlFragment: () => YXmlFragment,\n    XmlHook: () => YXmlHook,\n    XmlText: () => YXmlText,\n    YArrayEvent: () => YArrayEvent,\n    YEvent: () => YEvent,\n    YMapEvent: () => YMapEvent,\n    YTextEvent: () => YTextEvent,\n    YXmlEvent: () => YXmlEvent,\n    applyUpdate: () => applyUpdate,\n    applyUpdateV2: () => applyUpdateV2,\n    cleanupYTextFormatting: () => cleanupYTextFormatting,\n    compareIDs: () => compareIDs,\n    compareRelativePositions: () => compareRelativePositions,\n    convertUpdateFormatV1ToV2: () => convertUpdateFormatV1ToV2,\n    convertUpdateFormatV2ToV1: () => convertUpdateFormatV2ToV1,\n    createAbsolutePositionFromRelativePosition: () => createAbsolutePositionFromRelativePosition,\n    createDeleteSet: () => createDeleteSet,\n    createDeleteSetFromStructStore: () => createDeleteSetFromStructStore,\n    createDocFromSnapshot: () => createDocFromSnapshot,\n    createID: () => createID,\n    createRelativePositionFromJSON: () => createRelativePositionFromJSON,\n    createRelativePositionFromTypeIndex: () => createRelativePositionFromTypeIndex,\n    createSnapshot: () => createSnapshot,\n    decodeRelativePosition: () => decodeRelativePosition,\n    decodeSnapshot: () => decodeSnapshot,\n    decodeSnapshotV2: () => decodeSnapshotV2,\n    decodeStateVector: () => decodeStateVector,\n    decodeUpdate: () => decodeUpdate,\n    decodeUpdateV2: () => decodeUpdateV2,\n    diffUpdate: () => diffUpdate,\n    diffUpdateV2: () => diffUpdateV2,\n    emptySnapshot: () => emptySnapshot,\n    encodeRelativePosition: () => encodeRelativePosition,\n    encodeSnapshot: () => encodeSnapshot,\n    encodeSnapshotV2: () => encodeSnapshotV2,\n    encodeStateAsUpdate: () => encodeStateAsUpdate,\n    encodeStateAsUpdateV2: () => encodeStateAsUpdateV2,\n    encodeStateVector: () => encodeStateVector,\n    encodeStateVectorFromUpdate: () => encodeStateVectorFromUpdate,\n    encodeStateVectorFromUpdateV2: () => encodeStateVectorFromUpdateV2,\n    equalDeleteSets: () => equalDeleteSets,\n    equalSnapshots: () => equalSnapshots,\n    findIndexSS: () => findIndexSS,\n    findRootTypeKey: () => findRootTypeKey,\n    getItem: () => getItem,\n    getItemCleanEnd: () => getItemCleanEnd,\n    getItemCleanStart: () => getItemCleanStart,\n    getState: () => getState,\n    getTypeChildren: () => getTypeChildren,\n    isDeleted: () => isDeleted,\n    isParentOf: () => isParentOf,\n    iterateDeletedStructs: () => iterateDeletedStructs,\n    logType: () => logType,\n    logUpdate: () => logUpdate,\n    logUpdateV2: () => logUpdateV2,\n    mergeDeleteSets: () => mergeDeleteSets,\n    mergeUpdates: () => mergeUpdates,\n    mergeUpdatesV2: () => mergeUpdatesV2,\n    obfuscateUpdate: () => obfuscateUpdate,\n    obfuscateUpdateV2: () => obfuscateUpdateV2,\n    parseUpdateMeta: () => parseUpdateMeta,\n    parseUpdateMetaV2: () => parseUpdateMetaV2,\n    readUpdate: () => readUpdate,\n    readUpdateV2: () => readUpdateV2,\n    relativePositionToJSON: () => relativePositionToJSON,\n    snapshot: () => snapshot,\n    snapshotContainsUpdate: () => snapshotContainsUpdate,\n    transact: () => transact,\n    tryGc: () => tryGc,\n    typeListToArraySnapshot: () => typeListToArraySnapshot,\n    typeMapGetAllSnapshot: () => typeMapGetAllSnapshot,\n    typeMapGetSnapshot: () => typeMapGetSnapshot\n  });\n\n  // node_modules/lib0/map.js\n  var create = () => /* @__PURE__ */ new Map();\n  var copy2 = (m) => {\n    const r = create();\n    m.forEach((v, k) => {\n      r.set(k, v);\n    });\n    return r;\n  };\n  var setIfUndefined = (map3, key, createT) => {\n    let set = map3.get(key);\n    if (set === void 0) {\n      map3.set(key, set = createT());\n    }\n    return set;\n  };\n  var map2 = (m, f) => {\n    const res = [];\n    for (const [key, value] of m) {\n      res.push(f(value, key));\n    }\n    return res;\n  };\n  var any = (m, f) => {\n    for (const [key, value] of m) {\n      if (f(value, key)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // node_modules/lib0/set.js\n  var create2 = () => /* @__PURE__ */ new Set();\n\n  // node_modules/lib0/array.js\n  var last = (arr) => arr[arr.length - 1];\n  var appendTo = (dest, src) => {\n    for (let i = 0; i < src.length; i++) {\n      dest.push(src[i]);\n    }\n  };\n  var from2 = Array.from;\n  var some = (arr, f) => {\n    for (let i = 0; i < arr.length; i++) {\n      if (f(arr[i], i, arr)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  var unfold = (len, f) => {\n    const array = new Array(len);\n    for (let i = 0; i < len; i++) {\n      array[i] = f(i, array);\n    }\n    return array;\n  };\n  var isArray = Array.isArray;\n\n  // node_modules/lib0/observable.js\n  var ObservableV2 = class {\n    constructor() {\n      this._observers = create();\n    }\n    /**\n     * @template {keyof EVENTS & string} NAME\n     * @param {NAME} name\n     * @param {EVENTS[NAME]} f\n     */\n    on(name, f) {\n      setIfUndefined(\n        this._observers,\n        /** @type {string} */\n        name,\n        create2\n      ).add(f);\n      return f;\n    }\n    /**\n     * @template {keyof EVENTS & string} NAME\n     * @param {NAME} name\n     * @param {EVENTS[NAME]} f\n     */\n    once(name, f) {\n      const _f = (...args2) => {\n        this.off(\n          name,\n          /** @type {any} */\n          _f\n        );\n        f(...args2);\n      };\n      this.on(\n        name,\n        /** @type {any} */\n        _f\n      );\n    }\n    /**\n     * @template {keyof EVENTS & string} NAME\n     * @param {NAME} name\n     * @param {EVENTS[NAME]} f\n     */\n    off(name, f) {\n      const observers = this._observers.get(name);\n      if (observers !== void 0) {\n        observers.delete(f);\n        if (observers.size === 0) {\n          this._observers.delete(name);\n        }\n      }\n    }\n    /**\n     * Emit a named event. All registered event listeners that listen to the\n     * specified name will receive the event.\n     *\n     * @todo This should catch exceptions\n     *\n     * @template {keyof EVENTS & string} NAME\n     * @param {NAME} name The event name.\n     * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.\n     */\n    emit(name, args2) {\n      return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));\n    }\n    destroy() {\n      this._observers = create();\n    }\n  };\n  var Observable = class {\n    constructor() {\n      this._observers = create();\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n    on(name, f) {\n      setIfUndefined(this._observers, name, create2).add(f);\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n    once(name, f) {\n      const _f = (...args2) => {\n        this.off(name, _f);\n        f(...args2);\n      };\n      this.on(name, _f);\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n    off(name, f) {\n      const observers = this._observers.get(name);\n      if (observers !== void 0) {\n        observers.delete(f);\n        if (observers.size === 0) {\n          this._observers.delete(name);\n        }\n      }\n    }\n    /**\n     * Emit a named event. All registered event listeners that listen to the\n     * specified name will receive the event.\n     *\n     * @todo This should catch exceptions\n     *\n     * @param {N} name The event name.\n     * @param {Array<any>} args The arguments that are applied to the event listener.\n     */\n    emit(name, args2) {\n      return from2((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));\n    }\n    destroy() {\n      this._observers = create();\n    }\n  };\n\n  // node_modules/lib0/math.js\n  var floor = Math.floor;\n  var abs = Math.abs;\n  var min = (a, b) => a < b ? a : b;\n  var max = (a, b) => a > b ? a : b;\n  var isNaN = Number.isNaN;\n  var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;\n\n  // node_modules/lib0/binary.js\n  var BIT1 = 1;\n  var BIT2 = 2;\n  var BIT3 = 4;\n  var BIT4 = 8;\n  var BIT6 = 32;\n  var BIT7 = 64;\n  var BIT8 = 128;\n  var BIT18 = 1 << 17;\n  var BIT19 = 1 << 18;\n  var BIT20 = 1 << 19;\n  var BIT21 = 1 << 20;\n  var BIT22 = 1 << 21;\n  var BIT23 = 1 << 22;\n  var BIT24 = 1 << 23;\n  var BIT25 = 1 << 24;\n  var BIT26 = 1 << 25;\n  var BIT27 = 1 << 26;\n  var BIT28 = 1 << 27;\n  var BIT29 = 1 << 28;\n  var BIT30 = 1 << 29;\n  var BIT31 = 1 << 30;\n  var BIT32 = 1 << 31;\n  var BITS5 = 31;\n  var BITS6 = 63;\n  var BITS7 = 127;\n  var BITS17 = BIT18 - 1;\n  var BITS18 = BIT19 - 1;\n  var BITS19 = BIT20 - 1;\n  var BITS20 = BIT21 - 1;\n  var BITS21 = BIT22 - 1;\n  var BITS22 = BIT23 - 1;\n  var BITS23 = BIT24 - 1;\n  var BITS24 = BIT25 - 1;\n  var BITS25 = BIT26 - 1;\n  var BITS26 = BIT27 - 1;\n  var BITS27 = BIT28 - 1;\n  var BITS28 = BIT29 - 1;\n  var BITS29 = BIT30 - 1;\n  var BITS30 = BIT31 - 1;\n  var BITS31 = 2147483647;\n\n  // node_modules/lib0/number.js\n  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;\n  var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;\n  var LOWEST_INT32 = 1 << 31;\n  var isInteger = Number.isInteger || ((num) => typeof num === \"number\" && isFinite(num) && floor(num) === num);\n  var isNaN2 = Number.isNaN;\n  var parseInt2 = Number.parseInt;\n\n  // node_modules/lib0/string.js\n  var fromCharCode = String.fromCharCode;\n  var fromCodePoint = String.fromCodePoint;\n  var MAX_UTF16_CHARACTER = fromCharCode(65535);\n  var toLowerCase = (s) => s.toLowerCase();\n  var trimLeftRegex = /^\\s*/g;\n  var trimLeft = (s) => s.replace(trimLeftRegex, \"\");\n  var fromCamelCaseRegex = /([A-Z])/g;\n  var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));\n  var _encodeUtf8Polyfill = (str) => {\n    const encodedString = unescape(encodeURIComponent(str));\n    const len = encodedString.length;\n    const buf = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      buf[i] = /** @type {number} */\n      encodedString.codePointAt(i);\n    }\n    return buf;\n  };\n  var utf8TextEncoder = (\n    /** @type {TextEncoder} */\n    typeof TextEncoder !== \"undefined\" ? new TextEncoder() : null\n  );\n  var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);\n  var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;\n  var utf8TextDecoder = typeof TextDecoder === \"undefined\" ? null : new TextDecoder(\"utf-8\", { fatal: true, ignoreBOM: true });\n  if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n    utf8TextDecoder = null;\n  }\n  var repeat = (source, n) => unfold(n, () => source).join(\"\");\n\n  // node_modules/lib0/encoding.js\n  var Encoder = class {\n    constructor() {\n      this.cpos = 0;\n      this.cbuf = new Uint8Array(100);\n      this.bufs = [];\n    }\n  };\n  var createEncoder = () => new Encoder();\n  var encode = (f) => {\n    const encoder = createEncoder();\n    f(encoder);\n    return toUint8Array(encoder);\n  };\n  var length = (encoder) => {\n    let len = encoder.cpos;\n    for (let i = 0; i < encoder.bufs.length; i++) {\n      len += encoder.bufs[i].length;\n    }\n    return len;\n  };\n  var toUint8Array = (encoder) => {\n    const uint8arr = new Uint8Array(length(encoder));\n    let curPos = 0;\n    for (let i = 0; i < encoder.bufs.length; i++) {\n      const d = encoder.bufs[i];\n      uint8arr.set(d, curPos);\n      curPos += d.length;\n    }\n    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n    return uint8arr;\n  };\n  var verifyLen = (encoder, len) => {\n    const bufferLen = encoder.cbuf.length;\n    if (bufferLen - encoder.cpos < len) {\n      encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));\n      encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);\n      encoder.cpos = 0;\n    }\n  };\n  var write = (encoder, num) => {\n    const bufferLen = encoder.cbuf.length;\n    if (encoder.cpos === bufferLen) {\n      encoder.bufs.push(encoder.cbuf);\n      encoder.cbuf = new Uint8Array(bufferLen * 2);\n      encoder.cpos = 0;\n    }\n    encoder.cbuf[encoder.cpos++] = num;\n  };\n  var writeUint8 = write;\n  var writeVarUint = (encoder, num) => {\n    while (num > BITS7) {\n      write(encoder, BIT8 | BITS7 & num);\n      num = floor(num / 128);\n    }\n    write(encoder, BITS7 & num);\n  };\n  var writeVarInt = (encoder, num) => {\n    const isNegative = isNegativeZero(num);\n    if (isNegative) {\n      num = -num;\n    }\n    write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);\n    num = floor(num / 64);\n    while (num > 0) {\n      write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);\n      num = floor(num / 128);\n    }\n  };\n  var _strBuffer = new Uint8Array(3e4);\n  var _maxStrBSize = _strBuffer.length / 3;\n  var _writeVarStringNative = (encoder, str) => {\n    if (str.length < _maxStrBSize) {\n      const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;\n      writeVarUint(encoder, written);\n      for (let i = 0; i < written; i++) {\n        write(encoder, _strBuffer[i]);\n      }\n    } else {\n      writeVarUint8Array(encoder, encodeUtf8(str));\n    }\n  };\n  var _writeVarStringPolyfill = (encoder, str) => {\n    const encodedString = unescape(encodeURIComponent(str));\n    const len = encodedString.length;\n    writeVarUint(encoder, len);\n    for (let i = 0; i < len; i++) {\n      write(\n        encoder,\n        /** @type {number} */\n        encodedString.codePointAt(i)\n      );\n    }\n  };\n  var writeVarString = utf8TextEncoder && /** @type {any} */\n  utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;\n  var writeBinaryEncoder = (encoder, append3) => writeUint8Array(encoder, toUint8Array(append3));\n  var writeUint8Array = (encoder, uint8Array) => {\n    const bufferLen = encoder.cbuf.length;\n    const cpos = encoder.cpos;\n    const leftCopyLen = min(bufferLen - cpos, uint8Array.length);\n    const rightCopyLen = uint8Array.length - leftCopyLen;\n    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n    encoder.cpos += leftCopyLen;\n    if (rightCopyLen > 0) {\n      encoder.bufs.push(encoder.cbuf);\n      encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));\n      encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n      encoder.cpos = rightCopyLen;\n    }\n  };\n  var writeVarUint8Array = (encoder, uint8Array) => {\n    writeVarUint(encoder, uint8Array.byteLength);\n    writeUint8Array(encoder, uint8Array);\n  };\n  var writeOnDataView = (encoder, len) => {\n    verifyLen(encoder, len);\n    const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);\n    encoder.cpos += len;\n    return dview;\n  };\n  var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);\n  var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);\n  var writeBigInt64 = (encoder, num) => (\n    /** @type {any} */\n    writeOnDataView(encoder, 8).setBigInt64(0, num, false)\n  );\n  var floatTestBed = new DataView(new ArrayBuffer(4));\n  var isFloat32 = (num) => {\n    floatTestBed.setFloat32(0, num);\n    return floatTestBed.getFloat32(0) === num;\n  };\n  var writeAny = (encoder, data) => {\n    switch (typeof data) {\n      case \"string\":\n        write(encoder, 119);\n        writeVarString(encoder, data);\n        break;\n      case \"number\":\n        if (isInteger(data) && abs(data) <= BITS31) {\n          write(encoder, 125);\n          writeVarInt(encoder, data);\n        } else if (isFloat32(data)) {\n          write(encoder, 124);\n          writeFloat32(encoder, data);\n        } else {\n          write(encoder, 123);\n          writeFloat64(encoder, data);\n        }\n        break;\n      case \"bigint\":\n        write(encoder, 122);\n        writeBigInt64(encoder, data);\n        break;\n      case \"object\":\n        if (data === null) {\n          write(encoder, 126);\n        } else if (isArray(data)) {\n          write(encoder, 117);\n          writeVarUint(encoder, data.length);\n          for (let i = 0; i < data.length; i++) {\n            writeAny(encoder, data[i]);\n          }\n        } else if (data instanceof Uint8Array) {\n          write(encoder, 116);\n          writeVarUint8Array(encoder, data);\n        } else {\n          write(encoder, 118);\n          const keys4 = Object.keys(data);\n          writeVarUint(encoder, keys4.length);\n          for (let i = 0; i < keys4.length; i++) {\n            const key = keys4[i];\n            writeVarString(encoder, key);\n            writeAny(encoder, data[key]);\n          }\n        }\n        break;\n      case \"boolean\":\n        write(encoder, data ? 120 : 121);\n        break;\n      default:\n        write(encoder, 127);\n    }\n  };\n  var RleEncoder = class extends Encoder {\n    /**\n     * @param {function(Encoder, T):void} writer\n     */\n    constructor(writer) {\n      super();\n      this.w = writer;\n      this.s = null;\n      this.count = 0;\n    }\n    /**\n     * @param {T} v\n     */\n    write(v) {\n      if (this.s === v) {\n        this.count++;\n      } else {\n        if (this.count > 0) {\n          writeVarUint(this, this.count - 1);\n        }\n        this.count = 1;\n        this.w(this, v);\n        this.s = v;\n      }\n    }\n  };\n  var flushUintOptRleEncoder = (encoder) => {\n    if (encoder.count > 0) {\n      writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);\n      if (encoder.count > 1) {\n        writeVarUint(encoder.encoder, encoder.count - 2);\n      }\n    }\n  };\n  var UintOptRleEncoder = class {\n    constructor() {\n      this.encoder = new Encoder();\n      this.s = 0;\n      this.count = 0;\n    }\n    /**\n     * @param {number} v\n     */\n    write(v) {\n      if (this.s === v) {\n        this.count++;\n      } else {\n        flushUintOptRleEncoder(this);\n        this.count = 1;\n        this.s = v;\n      }\n    }\n    /**\n     * Flush the encoded state and transform this to a Uint8Array.\n     *\n     * Note that this should only be called once.\n     */\n    toUint8Array() {\n      flushUintOptRleEncoder(this);\n      return toUint8Array(this.encoder);\n    }\n  };\n  var flushIntDiffOptRleEncoder = (encoder) => {\n    if (encoder.count > 0) {\n      const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);\n      writeVarInt(encoder.encoder, encodedDiff);\n      if (encoder.count > 1) {\n        writeVarUint(encoder.encoder, encoder.count - 2);\n      }\n    }\n  };\n  var IntDiffOptRleEncoder = class {\n    constructor() {\n      this.encoder = new Encoder();\n      this.s = 0;\n      this.count = 0;\n      this.diff = 0;\n    }\n    /**\n     * @param {number} v\n     */\n    write(v) {\n      if (this.diff === v - this.s) {\n        this.s = v;\n        this.count++;\n      } else {\n        flushIntDiffOptRleEncoder(this);\n        this.count = 1;\n        this.diff = v - this.s;\n        this.s = v;\n      }\n    }\n    /**\n     * Flush the encoded state and transform this to a Uint8Array.\n     *\n     * Note that this should only be called once.\n     */\n    toUint8Array() {\n      flushIntDiffOptRleEncoder(this);\n      return toUint8Array(this.encoder);\n    }\n  };\n  var StringEncoder = class {\n    constructor() {\n      this.sarr = [];\n      this.s = \"\";\n      this.lensE = new UintOptRleEncoder();\n    }\n    /**\n     * @param {string} string\n     */\n    write(string) {\n      this.s += string;\n      if (this.s.length > 19) {\n        this.sarr.push(this.s);\n        this.s = \"\";\n      }\n      this.lensE.write(string.length);\n    }\n    toUint8Array() {\n      const encoder = new Encoder();\n      this.sarr.push(this.s);\n      this.s = \"\";\n      writeVarString(encoder, this.sarr.join(\"\"));\n      writeUint8Array(encoder, this.lensE.toUint8Array());\n      return toUint8Array(encoder);\n    }\n  };\n\n  // node_modules/lib0/error.js\n  var create3 = (s) => new Error(s);\n  var methodUnimplemented = () => {\n    throw create3(\"Method unimplemented\");\n  };\n  var unexpectedCase = () => {\n    throw create3(\"Unexpected case\");\n  };\n\n  // node_modules/lib0/decoding.js\n  var errorUnexpectedEndOfArray = create3(\"Unexpected end of array\");\n  var errorIntegerOutOfRange = create3(\"Integer out of Range\");\n  var Decoder = class {\n    /**\n     * @param {Uint8Array} uint8Array Binary data to decode\n     */\n    constructor(uint8Array) {\n      this.arr = uint8Array;\n      this.pos = 0;\n    }\n  };\n  var createDecoder = (uint8Array) => new Decoder(uint8Array);\n  var hasContent = (decoder) => decoder.pos !== decoder.arr.length;\n  var readUint8Array = (decoder, len) => {\n    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n    decoder.pos += len;\n    return view;\n  };\n  var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));\n  var readUint8 = (decoder) => decoder.arr[decoder.pos++];\n  var readVarUint = (decoder) => {\n    let num = 0;\n    let mult = 1;\n    const len = decoder.arr.length;\n    while (decoder.pos < len) {\n      const r = decoder.arr[decoder.pos++];\n      num = num + (r & BITS7) * mult;\n      mult *= 128;\n      if (r < BIT8) {\n        return num;\n      }\n      if (num > MAX_SAFE_INTEGER) {\n        throw errorIntegerOutOfRange;\n      }\n    }\n    throw errorUnexpectedEndOfArray;\n  };\n  var readVarInt = (decoder) => {\n    let r = decoder.arr[decoder.pos++];\n    let num = r & BITS6;\n    let mult = 64;\n    const sign = (r & BIT7) > 0 ? -1 : 1;\n    if ((r & BIT8) === 0) {\n      return sign * num;\n    }\n    const len = decoder.arr.length;\n    while (decoder.pos < len) {\n      r = decoder.arr[decoder.pos++];\n      num = num + (r & BITS7) * mult;\n      mult *= 128;\n      if (r < BIT8) {\n        return sign * num;\n      }\n      if (num > MAX_SAFE_INTEGER) {\n        throw errorIntegerOutOfRange;\n      }\n    }\n    throw errorUnexpectedEndOfArray;\n  };\n  var _readVarStringPolyfill = (decoder) => {\n    let remainingLen = readVarUint(decoder);\n    if (remainingLen === 0) {\n      return \"\";\n    } else {\n      let encodedString = String.fromCodePoint(readUint8(decoder));\n      if (--remainingLen < 100) {\n        while (remainingLen--) {\n          encodedString += String.fromCodePoint(readUint8(decoder));\n        }\n      } else {\n        while (remainingLen > 0) {\n          const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;\n          const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n          decoder.pos += nextLen;\n          encodedString += String.fromCodePoint.apply(\n            null,\n            /** @type {any} */\n            bytes\n          );\n          remainingLen -= nextLen;\n        }\n      }\n      return decodeURIComponent(escape(encodedString));\n    }\n  };\n  var _readVarStringNative = (decoder) => (\n    /** @type any */\n    utf8TextDecoder.decode(readVarUint8Array(decoder))\n  );\n  var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;\n  var readFromDataView = (decoder, len) => {\n    const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);\n    decoder.pos += len;\n    return dv;\n  };\n  var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);\n  var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);\n  var readBigInt64 = (decoder) => (\n    /** @type {any} */\n    readFromDataView(decoder, 8).getBigInt64(0, false)\n  );\n  var readAnyLookupTable = [\n    (decoder) => void 0,\n    // CASE 127: undefined\n    (decoder) => null,\n    // CASE 126: null\n    readVarInt,\n    // CASE 125: integer\n    readFloat32,\n    // CASE 124: float32\n    readFloat64,\n    // CASE 123: float64\n    readBigInt64,\n    // CASE 122: bigint\n    (decoder) => false,\n    // CASE 121: boolean (false)\n    (decoder) => true,\n    // CASE 120: boolean (true)\n    readVarString,\n    // CASE 119: string\n    (decoder) => {\n      const len = readVarUint(decoder);\n      const obj = {};\n      for (let i = 0; i < len; i++) {\n        const key = readVarString(decoder);\n        obj[key] = readAny(decoder);\n      }\n      return obj;\n    },\n    (decoder) => {\n      const len = readVarUint(decoder);\n      const arr = [];\n      for (let i = 0; i < len; i++) {\n        arr.push(readAny(decoder));\n      }\n      return arr;\n    },\n    readVarUint8Array\n    // CASE 116: Uint8Array\n  ];\n  var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);\n  var RleDecoder = class extends Decoder {\n    /**\n     * @param {Uint8Array} uint8Array\n     * @param {function(Decoder):T} reader\n     */\n    constructor(uint8Array, reader) {\n      super(uint8Array);\n      this.reader = reader;\n      this.s = null;\n      this.count = 0;\n    }\n    read() {\n      if (this.count === 0) {\n        this.s = this.reader(this);\n        if (hasContent(this)) {\n          this.count = readVarUint(this) + 1;\n        } else {\n          this.count = -1;\n        }\n      }\n      this.count--;\n      return (\n        /** @type {T} */\n        this.s\n      );\n    }\n  };\n  var UintOptRleDecoder = class extends Decoder {\n    /**\n     * @param {Uint8Array} uint8Array\n     */\n    constructor(uint8Array) {\n      super(uint8Array);\n      this.s = 0;\n      this.count = 0;\n    }\n    read() {\n      if (this.count === 0) {\n        this.s = readVarInt(this);\n        const isNegative = isNegativeZero(this.s);\n        this.count = 1;\n        if (isNegative) {\n          this.s = -this.s;\n          this.count = readVarUint(this) + 2;\n        }\n      }\n      this.count--;\n      return (\n        /** @type {number} */\n        this.s\n      );\n    }\n  };\n  var IntDiffOptRleDecoder = class extends Decoder {\n    /**\n     * @param {Uint8Array} uint8Array\n     */\n    constructor(uint8Array) {\n      super(uint8Array);\n      this.s = 0;\n      this.count = 0;\n      this.diff = 0;\n    }\n    /**\n     * @return {number}\n     */\n    read() {\n      if (this.count === 0) {\n        const diff = readVarInt(this);\n        const hasCount = diff & 1;\n        this.diff = floor(diff / 2);\n        this.count = 1;\n        if (hasCount) {\n          this.count = readVarUint(this) + 2;\n        }\n      }\n      this.s += this.diff;\n      this.count--;\n      return this.s;\n    }\n  };\n  var StringDecoder = class {\n    /**\n     * @param {Uint8Array} uint8Array\n     */\n    constructor(uint8Array) {\n      this.decoder = new UintOptRleDecoder(uint8Array);\n      this.str = readVarString(this.decoder);\n      this.spos = 0;\n    }\n    /**\n     * @return {string}\n     */\n    read() {\n      const end = this.spos + this.decoder.read();\n      const res = this.str.slice(this.spos, end);\n      this.spos = end;\n      return res;\n    }\n  };\n\n  // node_modules/lib0/webcrypto.js\n  var subtle = crypto.subtle;\n  var getRandomValues = crypto.getRandomValues.bind(crypto);\n\n  // node_modules/lib0/random.js\n  var rand = Math.random;\n  var uint32 = () => getRandomValues(new Uint32Array(1))[0];\n  var oneOf = (arr) => arr[floor(rand() * arr.length)];\n  var uuidv4Template = \"10000000-1000-4000-8000\" + -1e11;\n  var uuidv4 = () => uuidv4Template.replace(\n    /[018]/g,\n    /** @param {number} c */\n    (c) => (c ^ uint32() & 15 >> c / 4).toString(16)\n  );\n\n  // node_modules/lib0/time.js\n  var getUnixTime = Date.now;\n\n  // node_modules/lib0/promise.js\n  var create4 = (f) => (\n    /** @type {Promise<T>} */\n    new Promise(f)\n  );\n  var all = Promise.all.bind(Promise);\n\n  // node_modules/lib0/conditions.js\n  var undefinedToNull = (v) => v === void 0 ? null : v;\n\n  // node_modules/lib0/storage.js\n  var VarStoragePolyfill = class {\n    constructor() {\n      this.map = /* @__PURE__ */ new Map();\n    }\n    /**\n     * @param {string} key\n     * @param {any} newValue\n     */\n    setItem(key, newValue) {\n      this.map.set(key, newValue);\n    }\n    /**\n     * @param {string} key\n     */\n    getItem(key) {\n      return this.map.get(key);\n    }\n  };\n  var _localStorage = new VarStoragePolyfill();\n  var usePolyfill = true;\n  try {\n    if (typeof localStorage !== \"undefined\" && localStorage) {\n      _localStorage = localStorage;\n      usePolyfill = false;\n    }\n  } catch (e) {\n  }\n  var varStorage = _localStorage;\n\n  // node_modules/lib0/object.js\n  var assign = Object.assign;\n  var keys2 = Object.keys;\n  var forEach2 = (obj, f) => {\n    for (const key in obj) {\n      f(obj[key], key);\n    }\n  };\n  var length2 = (obj) => keys2(obj).length;\n  var size = (obj) => keys2(obj).length;\n  var isEmpty = (obj) => {\n    for (const _k in obj) {\n      return false;\n    }\n    return true;\n  };\n  var every = (obj, f) => {\n    for (const key in obj) {\n      if (!f(obj[key], key)) {\n        return false;\n      }\n    }\n    return true;\n  };\n  var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n  var equalFlat = (a, b) => a === b || size(a) === size(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);\n  var freeze = Object.freeze;\n  var deepFreeze = (o) => {\n    for (const key in o) {\n      const c = o[key];\n      if (typeof c === \"object\" || typeof c === \"function\") {\n        deepFreeze(o[key]);\n      }\n    }\n    return freeze(o);\n  };\n\n  // node_modules/lib0/traits.js\n  var EqualityTraitSymbol = Symbol(\"Equality\");\n\n  // node_modules/lib0/function.js\n  var callAll = (fs, args2, i = 0) => {\n    try {\n      for (; i < fs.length; i++) {\n        fs[i](...args2);\n      }\n    } finally {\n      if (i < fs.length) {\n        callAll(fs, args2, i + 1);\n      }\n    }\n  };\n  var id = (a) => a;\n  var equalityDeep = (a, b) => {\n    if (a === b) {\n      return true;\n    }\n    if (a == null || b == null || a.constructor !== b.constructor) {\n      return false;\n    }\n    if (a[EqualityTraitSymbol] != null) {\n      return a[EqualityTraitSymbol](b);\n    }\n    switch (a.constructor) {\n      case ArrayBuffer:\n        a = new Uint8Array(a);\n        b = new Uint8Array(b);\n      // eslint-disable-next-line no-fallthrough\n      case Uint8Array: {\n        if (a.byteLength !== b.byteLength) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          if (a[i] !== b[i]) {\n            return false;\n          }\n        }\n        break;\n      }\n      case Set: {\n        if (a.size !== b.size) {\n          return false;\n        }\n        for (const value of a) {\n          if (!b.has(value)) {\n            return false;\n          }\n        }\n        break;\n      }\n      case Map: {\n        if (a.size !== b.size) {\n          return false;\n        }\n        for (const key of a.keys()) {\n          if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n            return false;\n          }\n        }\n        break;\n      }\n      case Object:\n        if (length2(a) !== length2(b)) {\n          return false;\n        }\n        for (const key in a) {\n          if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n            return false;\n          }\n        }\n        break;\n      case Array:\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          if (!equalityDeep(a[i], b[i])) {\n            return false;\n          }\n        }\n        break;\n      default:\n        return false;\n    }\n    return true;\n  };\n  var isOneOf = (value, options) => options.includes(value);\n\n  // node_modules/lib0/environment.js\n  var isNode = typeof process !== \"undefined\" && process.release && /node|io\\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== \"undefined\" ? process : 0) === \"[object process]\";\n  var isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\" && !isNode;\n  var isMac = typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n  var params;\n  var args = [];\n  var computeParams = () => {\n    if (params === void 0) {\n      if (isNode) {\n        params = create();\n        const pargs = process.argv;\n        let currParamName = null;\n        for (let i = 0; i < pargs.length; i++) {\n          const parg = pargs[i];\n          if (parg[0] === \"-\") {\n            if (currParamName !== null) {\n              params.set(currParamName, \"\");\n            }\n            currParamName = parg;\n          } else {\n            if (currParamName !== null) {\n              params.set(currParamName, parg);\n              currParamName = null;\n            } else {\n              args.push(parg);\n            }\n          }\n        }\n        if (currParamName !== null) {\n          params.set(currParamName, \"\");\n        }\n      } else if (typeof location === \"object\") {\n        params = create();\n        (location.search || \"?\").slice(1).split(\"&\").forEach((kv) => {\n          if (kv.length !== 0) {\n            const [key, value] = kv.split(\"=\");\n            params.set(`--${fromCamelCase(key, \"-\")}`, value);\n            params.set(`-${fromCamelCase(key, \"-\")}`, value);\n          }\n        });\n      } else {\n        params = create();\n      }\n    }\n    return params;\n  };\n  var hasParam = (name) => computeParams().has(name);\n  var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll(\"-\", \"_\")]) : undefinedToNull(varStorage.getItem(name));\n  var hasConf = (name) => hasParam(\"--\" + name) || getVariable(name) !== null;\n  var production = hasConf(\"production\");\n  var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, [\"true\", \"1\", \"2\"]);\n  var supportsColor = forceColor || !hasParam(\"--no-colors\") && // @todo deprecate --no-colors\n  !hasConf(\"no-color\") && (!isNode || process.stdout.isTTY) && (!isNode || hasParam(\"--color\") || getVariable(\"COLORTERM\") !== null || (getVariable(\"TERM\") || \"\").includes(\"color\"));\n\n  // node_modules/lib0/buffer.js\n  var createUint8ArrayFromLen = (len) => new Uint8Array(len);\n  var toBase64Browser = (bytes) => {\n    let s = \"\";\n    for (let i = 0; i < bytes.byteLength; i++) {\n      s += fromCharCode(bytes[i]);\n    }\n    return btoa(s);\n  };\n  var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString(\"base64\");\n  var toBase64 = isBrowser ? toBase64Browser : toBase64Node;\n  var copyUint8Array = (uint8Array) => {\n    const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);\n    newBuf.set(uint8Array);\n    return newBuf;\n  };\n  var encodeAny = (data) => encode((encoder) => writeAny(encoder, data));\n\n  // node_modules/lib0/pair.js\n  var Pair = class {\n    /**\n     * @param {L} left\n     * @param {R} right\n     */\n    constructor(left, right) {\n      this.left = left;\n      this.right = right;\n    }\n  };\n  var create5 = (left, right) => new Pair(left, right);\n\n  // node_modules/lib0/dom.js\n  var doc3 = (\n    /** @type {Document} */\n    typeof document !== \"undefined\" ? document : {}\n  );\n  var domParser = (\n    /** @type {DOMParser} */\n    typeof DOMParser !== \"undefined\" ? new DOMParser() : null\n  );\n  var mapToStyleString = (m) => map2(m, (value, key) => `${key}:${value};`).join(\"\");\n  var ELEMENT_NODE = doc3.ELEMENT_NODE;\n  var TEXT_NODE = doc3.TEXT_NODE;\n  var CDATA_SECTION_NODE = doc3.CDATA_SECTION_NODE;\n  var COMMENT_NODE = doc3.COMMENT_NODE;\n  var DOCUMENT_NODE = doc3.DOCUMENT_NODE;\n  var DOCUMENT_TYPE_NODE = doc3.DOCUMENT_TYPE_NODE;\n  var DOCUMENT_FRAGMENT_NODE = doc3.DOCUMENT_FRAGMENT_NODE;\n\n  // node_modules/lib0/eventloop.js\n  var createTimeoutClass = (clearFunction) => class TT {\n    /**\n     * @param {number} timeoutId\n     */\n    constructor(timeoutId) {\n      this._ = timeoutId;\n    }\n    destroy() {\n      clearFunction(this._);\n    }\n  };\n  var Timeout = createTimeoutClass(clearTimeout);\n  var timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));\n  var Interval = createTimeoutClass(clearInterval);\n  var Animation = createTimeoutClass((arg) => typeof requestAnimationFrame !== \"undefined\" && cancelAnimationFrame(arg));\n  var Idle = createTimeoutClass((arg) => typeof cancelIdleCallback !== \"undefined\" && cancelIdleCallback(arg));\n\n  // node_modules/lib0/symbol.js\n  var create6 = Symbol;\n\n  // node_modules/lib0/logging.common.js\n  var BOLD = create6();\n  var UNBOLD = create6();\n  var BLUE = create6();\n  var GREY = create6();\n  var GREEN = create6();\n  var RED = create6();\n  var PURPLE = create6();\n  var ORANGE = create6();\n  var UNCOLOR = create6();\n  var computeNoColorLoggingArgs = (args2) => {\n    if (args2.length === 1 && args2[0]?.constructor === Function) {\n      args2 = /** @type {Array<string|Symbol|Object|number>} */\n      /** @type {[function]} */\n      args2[0]();\n    }\n    const strBuilder = [];\n    const logArgs = [];\n    let i = 0;\n    for (; i < args2.length; i++) {\n      const arg = args2[i];\n      if (arg === void 0) {\n        break;\n      } else if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg);\n      } else if (arg.constructor === Object) {\n        break;\n      }\n    }\n    if (i > 0) {\n      logArgs.push(strBuilder.join(\"\"));\n    }\n    for (; i < args2.length; i++) {\n      const arg = args2[i];\n      if (!(arg instanceof Symbol)) {\n        logArgs.push(arg);\n      }\n    }\n    return logArgs;\n  };\n  var lastLoggingTime = getUnixTime();\n\n  // node_modules/lib0/logging.js\n  var _browserStyleMap = {\n    [BOLD]: create5(\"font-weight\", \"bold\"),\n    [UNBOLD]: create5(\"font-weight\", \"normal\"),\n    [BLUE]: create5(\"color\", \"blue\"),\n    [GREEN]: create5(\"color\", \"green\"),\n    [GREY]: create5(\"color\", \"grey\"),\n    [RED]: create5(\"color\", \"red\"),\n    [PURPLE]: create5(\"color\", \"purple\"),\n    [ORANGE]: create5(\"color\", \"orange\"),\n    // not well supported in chrome when debugging node with inspector - TODO: deprecate\n    [UNCOLOR]: create5(\"color\", \"black\")\n  };\n  var computeBrowserLoggingArgs = (args2) => {\n    if (args2.length === 1 && args2[0]?.constructor === Function) {\n      args2 = /** @type {Array<string|Symbol|Object|number>} */\n      /** @type {[function]} */\n      args2[0]();\n    }\n    const strBuilder = [];\n    const styles = [];\n    const currentStyle = create();\n    let logArgs = [];\n    let i = 0;\n    for (; i < args2.length; i++) {\n      const arg = args2[i];\n      const style = _browserStyleMap[arg];\n      if (style !== void 0) {\n        currentStyle.set(style.left, style.right);\n      } else {\n        if (arg === void 0) {\n          break;\n        }\n        if (arg.constructor === String || arg.constructor === Number) {\n          const style2 = mapToStyleString(currentStyle);\n          if (i > 0 || style2.length > 0) {\n            strBuilder.push(\"%c\" + arg);\n            styles.push(style2);\n          } else {\n            strBuilder.push(arg);\n          }\n        } else {\n          break;\n        }\n      }\n    }\n    if (i > 0) {\n      logArgs = styles;\n      logArgs.unshift(strBuilder.join(\"\"));\n    }\n    for (; i < args2.length; i++) {\n      const arg = args2[i];\n      if (!(arg instanceof Symbol)) {\n        logArgs.push(arg);\n      }\n    }\n    return logArgs;\n  };\n  var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;\n  var print = (...args2) => {\n    console.log(...computeLoggingArgs(args2));\n    vconsoles.forEach((vc) => vc.print(args2));\n  };\n  var warn = (...args2) => {\n    console.warn(...computeLoggingArgs(args2));\n    args2.unshift(ORANGE);\n    vconsoles.forEach((vc) => vc.print(args2));\n  };\n  var vconsoles = create2();\n\n  // node_modules/lib0/iterator.js\n  var createIterator = (next) => ({\n    /**\n     * @return {IterableIterator<T>}\n     */\n    [Symbol.iterator]() {\n      return this;\n    },\n    // @ts-ignore\n    next\n  });\n  var iteratorFilter = (iterator, filter) => createIterator(() => {\n    let res;\n    do {\n      res = iterator.next();\n    } while (!res.done && !filter(res.value));\n    return res;\n  });\n  var iteratorMap = (iterator, fmap) => createIterator(() => {\n    const { done, value } = iterator.next();\n    return { done, value: done ? void 0 : fmap(value) };\n  });\n\n  // node_modules/yjs/dist/yjs.mjs\n  var AbstractConnector = class extends ObservableV2 {\n    /**\n     * @param {Doc} ydoc\n     * @param {any} awareness\n     */\n    constructor(ydoc, awareness) {\n      super();\n      this.doc = ydoc;\n      this.awareness = awareness;\n    }\n  };\n  var DeleteItem = class {\n    /**\n     * @param {number} clock\n     * @param {number} len\n     */\n    constructor(clock, len) {\n      this.clock = clock;\n      this.len = len;\n    }\n  };\n  var DeleteSet = class {\n    constructor() {\n      this.clients = /* @__PURE__ */ new Map();\n    }\n  };\n  var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {\n    const structs = (\n      /** @type {Array<GC|Item>} */\n      transaction.doc.store.clients.get(clientid)\n    );\n    if (structs != null) {\n      const lastStruct = structs[structs.length - 1];\n      const clockState = lastStruct.id.clock + lastStruct.length;\n      for (let i = 0, del2 = deletes[i]; i < deletes.length && del2.clock < clockState; del2 = deletes[++i]) {\n        iterateStructs(transaction, structs, del2.clock, del2.len, f);\n      }\n    }\n  });\n  var findIndexDS = (dis, clock) => {\n    let left = 0;\n    let right = dis.length - 1;\n    while (left <= right) {\n      const midindex = floor((left + right) / 2);\n      const mid = dis[midindex];\n      const midclock = mid.clock;\n      if (midclock <= clock) {\n        if (clock < midclock + mid.len) {\n          return midindex;\n        }\n        left = midindex + 1;\n      } else {\n        right = midindex - 1;\n      }\n    }\n    return null;\n  };\n  var isDeleted = (ds, id2) => {\n    const dis = ds.clients.get(id2.client);\n    return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;\n  };\n  var sortAndMergeDeleteSet = (ds) => {\n    ds.clients.forEach((dels) => {\n      dels.sort((a, b) => a.clock - b.clock);\n      let i, j;\n      for (i = 1, j = 1; i < dels.length; i++) {\n        const left = dels[j - 1];\n        const right = dels[i];\n        if (left.clock + left.len >= right.clock) {\n          left.len = max(left.len, right.clock + right.len - left.clock);\n        } else {\n          if (j < i) {\n            dels[j] = right;\n          }\n          j++;\n        }\n      }\n      dels.length = j;\n    });\n  };\n  var mergeDeleteSets = (dss) => {\n    const merged = new DeleteSet();\n    for (let dssI = 0; dssI < dss.length; dssI++) {\n      dss[dssI].clients.forEach((delsLeft, client) => {\n        if (!merged.clients.has(client)) {\n          const dels = delsLeft.slice();\n          for (let i = dssI + 1; i < dss.length; i++) {\n            appendTo(dels, dss[i].clients.get(client) || []);\n          }\n          merged.clients.set(client, dels);\n        }\n      });\n    }\n    sortAndMergeDeleteSet(merged);\n    return merged;\n  };\n  var addToDeleteSet = (ds, client, clock, length4) => {\n    setIfUndefined(ds.clients, client, () => (\n      /** @type {Array<DeleteItem>} */\n      []\n    )).push(new DeleteItem(clock, length4));\n  };\n  var createDeleteSet = () => new DeleteSet();\n  var createDeleteSetFromStructStore = (ss) => {\n    const ds = createDeleteSet();\n    ss.clients.forEach((structs, client) => {\n      const dsitems = [];\n      for (let i = 0; i < structs.length; i++) {\n        const struct = structs[i];\n        if (struct.deleted) {\n          const clock = struct.id.clock;\n          let len = struct.length;\n          if (i + 1 < structs.length) {\n            for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {\n              len += next.length;\n            }\n          }\n          dsitems.push(new DeleteItem(clock, len));\n        }\n      }\n      if (dsitems.length > 0) {\n        ds.clients.set(client, dsitems);\n      }\n    });\n    return ds;\n  };\n  var writeDeleteSet = (encoder, ds) => {\n    writeVarUint(encoder.restEncoder, ds.clients.size);\n    from2(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {\n      encoder.resetDsCurVal();\n      writeVarUint(encoder.restEncoder, client);\n      const len = dsitems.length;\n      writeVarUint(encoder.restEncoder, len);\n      for (let i = 0; i < len; i++) {\n        const item = dsitems[i];\n        encoder.writeDsClock(item.clock);\n        encoder.writeDsLen(item.len);\n      }\n    });\n  };\n  var readDeleteSet = (decoder) => {\n    const ds = new DeleteSet();\n    const numClients = readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numClients; i++) {\n      decoder.resetDsCurVal();\n      const client = readVarUint(decoder.restDecoder);\n      const numberOfDeletes = readVarUint(decoder.restDecoder);\n      if (numberOfDeletes > 0) {\n        const dsField = setIfUndefined(ds.clients, client, () => (\n          /** @type {Array<DeleteItem>} */\n          []\n        ));\n        for (let i2 = 0; i2 < numberOfDeletes; i2++) {\n          dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));\n        }\n      }\n    }\n    return ds;\n  };\n  var readAndApplyDeleteSet = (decoder, transaction, store) => {\n    const unappliedDS = new DeleteSet();\n    const numClients = readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numClients; i++) {\n      decoder.resetDsCurVal();\n      const client = readVarUint(decoder.restDecoder);\n      const numberOfDeletes = readVarUint(decoder.restDecoder);\n      const structs = store.clients.get(client) || [];\n      const state = getState(store, client);\n      for (let i2 = 0; i2 < numberOfDeletes; i2++) {\n        const clock = decoder.readDsClock();\n        const clockEnd = clock + decoder.readDsLen();\n        if (clock < state) {\n          if (state < clockEnd) {\n            addToDeleteSet(unappliedDS, client, state, clockEnd - state);\n          }\n          let index = findIndexSS(structs, clock);\n          let struct = structs[index];\n          if (!struct.deleted && struct.id.clock < clock) {\n            structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n            index++;\n          }\n          while (index < structs.length) {\n            struct = structs[index++];\n            if (struct.id.clock < clockEnd) {\n              if (!struct.deleted) {\n                if (clockEnd < struct.id.clock + struct.length) {\n                  structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));\n                }\n                struct.delete(transaction);\n              }\n            } else {\n              break;\n            }\n          }\n        } else {\n          addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);\n        }\n      }\n    }\n    if (unappliedDS.clients.size > 0) {\n      const ds = new UpdateEncoderV2();\n      writeVarUint(ds.restEncoder, 0);\n      writeDeleteSet(ds, unappliedDS);\n      return ds.toUint8Array();\n    }\n    return null;\n  };\n  var equalDeleteSets = (ds1, ds2) => {\n    if (ds1.clients.size !== ds2.clients.size) return false;\n    for (const [client, deleteItems1] of ds1.clients.entries()) {\n      const deleteItems2 = (\n        /** @type {Array<import('../internals.js').DeleteItem>} */\n        ds2.clients.get(client)\n      );\n      if (deleteItems2 === void 0 || deleteItems1.length !== deleteItems2.length) return false;\n      for (let i = 0; i < deleteItems1.length; i++) {\n        const di1 = deleteItems1[i];\n        const di2 = deleteItems2[i];\n        if (di1.clock !== di2.clock || di1.len !== di2.len) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  var generateNewClientId = uint32;\n  var Doc = class _Doc extends ObservableV2 {\n    /**\n     * @param {DocOpts} opts configuration\n     */\n    constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {\n      super();\n      this.gc = gc;\n      this.gcFilter = gcFilter;\n      this.clientID = generateNewClientId();\n      this.guid = guid;\n      this.collectionid = collectionid;\n      this.share = /* @__PURE__ */ new Map();\n      this.store = new StructStore();\n      this._transaction = null;\n      this._transactionCleanups = [];\n      this.subdocs = /* @__PURE__ */ new Set();\n      this._item = null;\n      this.shouldLoad = shouldLoad;\n      this.autoLoad = autoLoad;\n      this.meta = meta;\n      this.isLoaded = false;\n      this.isSynced = false;\n      this.isDestroyed = false;\n      this.whenLoaded = create4((resolve) => {\n        this.on(\"load\", () => {\n          this.isLoaded = true;\n          resolve(this);\n        });\n      });\n      const provideSyncedPromise = () => create4((resolve) => {\n        const eventHandler = (isSynced) => {\n          if (isSynced === void 0 || isSynced === true) {\n            this.off(\"sync\", eventHandler);\n            resolve();\n          }\n        };\n        this.on(\"sync\", eventHandler);\n      });\n      this.on(\"sync\", (isSynced) => {\n        if (isSynced === false && this.isSynced) {\n          this.whenSynced = provideSyncedPromise();\n        }\n        this.isSynced = isSynced === void 0 || isSynced === true;\n        if (this.isSynced && !this.isLoaded) {\n          this.emit(\"load\", [this]);\n        }\n      });\n      this.whenSynced = provideSyncedPromise();\n    }\n    /**\n     * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n     *\n     * `load()` might be used in the future to request any provider to load the most current data.\n     *\n     * It is safe to call `load()` multiple times.\n     */\n    load() {\n      const item = this._item;\n      if (item !== null && !this.shouldLoad) {\n        transact(\n          /** @type {any} */\n          item.parent.doc,\n          (transaction) => {\n            transaction.subdocsLoaded.add(this);\n          },\n          null,\n          true\n        );\n      }\n      this.shouldLoad = true;\n    }\n    getSubdocs() {\n      return this.subdocs;\n    }\n    getSubdocGuids() {\n      return new Set(from2(this.subdocs).map((doc4) => doc4.guid));\n    }\n    /**\n     * Changes that happen inside of a transaction are bundled. This means that\n     * the observer fires _after_ the transaction is finished and that all changes\n     * that happened inside of the transaction are sent as one message to the\n     * other peers.\n     *\n     * @template T\n     * @param {function(Transaction):T} f The function that should be executed as a transaction\n     * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n     * @return T\n     *\n     * @public\n     */\n    transact(f, origin = null) {\n      return transact(this, f, origin);\n    }\n    /**\n     * Define a shared data type.\n     *\n     * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result\n     * and do not overwrite each other. I.e.\n     * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`\n     *\n     * After this method is called, the type is also available on `ydoc.share.get(name)`.\n     *\n     * *Best Practices:*\n     * Define all types right after the Y.Doc instance is created and store them in a separate object.\n     * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n     *\n     * @template {typeof AbstractType<any>} Type\n     * @example\n     *   const ydoc = new Y.Doc(..)\n     *   const appState = {\n     *     document: ydoc.getText('document')\n     *     comments: ydoc.getArray('comments')\n     *   }\n     *\n     * @param {string} name\n     * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n     * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor\n     *\n     * @public\n     */\n    get(name, TypeConstructor = (\n      /** @type {any} */\n      AbstractType\n    )) {\n      const type = setIfUndefined(this.share, name, () => {\n        const t = new TypeConstructor();\n        t._integrate(this, null);\n        return t;\n      });\n      const Constr = type.constructor;\n      if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n        if (Constr === AbstractType) {\n          const t = new TypeConstructor();\n          t._map = type._map;\n          type._map.forEach(\n            /** @param {Item?} n */\n            (n) => {\n              for (; n !== null; n = n.left) {\n                n.parent = t;\n              }\n            }\n          );\n          t._start = type._start;\n          for (let n = t._start; n !== null; n = n.right) {\n            n.parent = t;\n          }\n          t._length = type._length;\n          this.share.set(name, t);\n          t._integrate(this, null);\n          return (\n            /** @type {InstanceType<Type>} */\n            t\n          );\n        } else {\n          throw new Error(`Type with the name ${name} has already been defined with a different constructor`);\n        }\n      }\n      return (\n        /** @type {InstanceType<Type>} */\n        type\n      );\n    }\n    /**\n     * @template T\n     * @param {string} [name]\n     * @return {YArray<T>}\n     *\n     * @public\n     */\n    getArray(name = \"\") {\n      return (\n        /** @type {YArray<T>} */\n        this.get(name, YArray)\n      );\n    }\n    /**\n     * @param {string} [name]\n     * @return {YText}\n     *\n     * @public\n     */\n    getText(name = \"\") {\n      return this.get(name, YText);\n    }\n    /**\n     * @template T\n     * @param {string} [name]\n     * @return {YMap<T>}\n     *\n     * @public\n     */\n    getMap(name = \"\") {\n      return (\n        /** @type {YMap<T>} */\n        this.get(name, YMap)\n      );\n    }\n    /**\n     * @param {string} [name]\n     * @return {YXmlElement}\n     *\n     * @public\n     */\n    getXmlElement(name = \"\") {\n      return (\n        /** @type {YXmlElement<{[key:string]:string}>} */\n        this.get(name, YXmlElement)\n      );\n    }\n    /**\n     * @param {string} [name]\n     * @return {YXmlFragment}\n     *\n     * @public\n     */\n    getXmlFragment(name = \"\") {\n      return this.get(name, YXmlFragment);\n    }\n    /**\n     * Converts the entire document into a js object, recursively traversing each yjs type\n     * Doesn't log types that have not been defined (using ydoc.getType(..)).\n     *\n     * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n     *\n     * @return {Object<string, any>}\n     */\n    toJSON() {\n      const doc4 = {};\n      this.share.forEach((value, key) => {\n        doc4[key] = value.toJSON();\n      });\n      return doc4;\n    }\n    /**\n     * Emit `destroy` event and unregister all event handlers.\n     */\n    destroy() {\n      this.isDestroyed = true;\n      from2(this.subdocs).forEach((subdoc) => subdoc.destroy());\n      const item = this._item;\n      if (item !== null) {\n        this._item = null;\n        const content = (\n          /** @type {ContentDoc} */\n          item.content\n        );\n        content.doc = new _Doc({ guid: this.guid, ...content.opts, shouldLoad: false });\n        content.doc._item = item;\n        transact(\n          /** @type {any} */\n          item.parent.doc,\n          (transaction) => {\n            const doc4 = content.doc;\n            if (!item.deleted) {\n              transaction.subdocsAdded.add(doc4);\n            }\n            transaction.subdocsRemoved.add(this);\n          },\n          null,\n          true\n        );\n      }\n      this.emit(\"destroyed\", [true]);\n      this.emit(\"destroy\", [this]);\n      super.destroy();\n    }\n  };\n  var DSDecoderV1 = class {\n    /**\n     * @param {decoding.Decoder} decoder\n     */\n    constructor(decoder) {\n      this.restDecoder = decoder;\n    }\n    resetDsCurVal() {\n    }\n    /**\n     * @return {number}\n     */\n    readDsClock() {\n      return readVarUint(this.restDecoder);\n    }\n    /**\n     * @return {number}\n     */\n    readDsLen() {\n      return readVarUint(this.restDecoder);\n    }\n  };\n  var UpdateDecoderV1 = class extends DSDecoderV1 {\n    /**\n     * @return {ID}\n     */\n    readLeftID() {\n      return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));\n    }\n    /**\n     * @return {ID}\n     */\n    readRightID() {\n      return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));\n    }\n    /**\n     * Read the next client id.\n     * Use this in favor of readID whenever possible to reduce the number of objects created.\n     */\n    readClient() {\n      return readVarUint(this.restDecoder);\n    }\n    /**\n     * @return {number} info An unsigned 8-bit integer\n     */\n    readInfo() {\n      return readUint8(this.restDecoder);\n    }\n    /**\n     * @return {string}\n     */\n    readString() {\n      return readVarString(this.restDecoder);\n    }\n    /**\n     * @return {boolean} isKey\n     */\n    readParentInfo() {\n      return readVarUint(this.restDecoder) === 1;\n    }\n    /**\n     * @return {number} info An unsigned 8-bit integer\n     */\n    readTypeRef() {\n      return readVarUint(this.restDecoder);\n    }\n    /**\n     * Write len of a struct - well suited for Opt RLE encoder.\n     *\n     * @return {number} len\n     */\n    readLen() {\n      return readVarUint(this.restDecoder);\n    }\n    /**\n     * @return {any}\n     */\n    readAny() {\n      return readAny(this.restDecoder);\n    }\n    /**\n     * @return {Uint8Array}\n     */\n    readBuf() {\n      return copyUint8Array(readVarUint8Array(this.restDecoder));\n    }\n    /**\n     * Legacy implementation uses JSON parse. We use any-decoding in v2.\n     *\n     * @return {any}\n     */\n    readJSON() {\n      return JSON.parse(readVarString(this.restDecoder));\n    }\n    /**\n     * @return {string}\n     */\n    readKey() {\n      return readVarString(this.restDecoder);\n    }\n  };\n  var DSDecoderV2 = class {\n    /**\n     * @param {decoding.Decoder} decoder\n     */\n    constructor(decoder) {\n      this.dsCurrVal = 0;\n      this.restDecoder = decoder;\n    }\n    resetDsCurVal() {\n      this.dsCurrVal = 0;\n    }\n    /**\n     * @return {number}\n     */\n    readDsClock() {\n      this.dsCurrVal += readVarUint(this.restDecoder);\n      return this.dsCurrVal;\n    }\n    /**\n     * @return {number}\n     */\n    readDsLen() {\n      const diff = readVarUint(this.restDecoder) + 1;\n      this.dsCurrVal += diff;\n      return diff;\n    }\n  };\n  var UpdateDecoderV2 = class extends DSDecoderV2 {\n    /**\n     * @param {decoding.Decoder} decoder\n     */\n    constructor(decoder) {\n      super(decoder);\n      this.keys = [];\n      readVarUint(decoder);\n      this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n      this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n      this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n      this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));\n      this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);\n      this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));\n      this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);\n      this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n      this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));\n    }\n    /**\n     * @return {ID}\n     */\n    readLeftID() {\n      return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());\n    }\n    /**\n     * @return {ID}\n     */\n    readRightID() {\n      return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());\n    }\n    /**\n     * Read the next client id.\n     * Use this in favor of readID whenever possible to reduce the number of objects created.\n     */\n    readClient() {\n      return this.clientDecoder.read();\n    }\n    /**\n     * @return {number} info An unsigned 8-bit integer\n     */\n    readInfo() {\n      return (\n        /** @type {number} */\n        this.infoDecoder.read()\n      );\n    }\n    /**\n     * @return {string}\n     */\n    readString() {\n      return this.stringDecoder.read();\n    }\n    /**\n     * @return {boolean}\n     */\n    readParentInfo() {\n      return this.parentInfoDecoder.read() === 1;\n    }\n    /**\n     * @return {number} An unsigned 8-bit integer\n     */\n    readTypeRef() {\n      return this.typeRefDecoder.read();\n    }\n    /**\n     * Write len of a struct - well suited for Opt RLE encoder.\n     *\n     * @return {number}\n     */\n    readLen() {\n      return this.lenDecoder.read();\n    }\n    /**\n     * @return {any}\n     */\n    readAny() {\n      return readAny(this.restDecoder);\n    }\n    /**\n     * @return {Uint8Array}\n     */\n    readBuf() {\n      return readVarUint8Array(this.restDecoder);\n    }\n    /**\n     * This is mainly here for legacy purposes.\n     *\n     * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n     *\n     * @return {any}\n     */\n    readJSON() {\n      return readAny(this.restDecoder);\n    }\n    /**\n     * @return {string}\n     */\n    readKey() {\n      const keyClock = this.keyClockDecoder.read();\n      if (keyClock < this.keys.length) {\n        return this.keys[keyClock];\n      } else {\n        const key = this.stringDecoder.read();\n        this.keys.push(key);\n        return key;\n      }\n    }\n  };\n  var DSEncoderV1 = class {\n    constructor() {\n      this.restEncoder = createEncoder();\n    }\n    toUint8Array() {\n      return toUint8Array(this.restEncoder);\n    }\n    resetDsCurVal() {\n    }\n    /**\n     * @param {number} clock\n     */\n    writeDsClock(clock) {\n      writeVarUint(this.restEncoder, clock);\n    }\n    /**\n     * @param {number} len\n     */\n    writeDsLen(len) {\n      writeVarUint(this.restEncoder, len);\n    }\n  };\n  var UpdateEncoderV1 = class extends DSEncoderV1 {\n    /**\n     * @param {ID} id\n     */\n    writeLeftID(id2) {\n      writeVarUint(this.restEncoder, id2.client);\n      writeVarUint(this.restEncoder, id2.clock);\n    }\n    /**\n     * @param {ID} id\n     */\n    writeRightID(id2) {\n      writeVarUint(this.restEncoder, id2.client);\n      writeVarUint(this.restEncoder, id2.clock);\n    }\n    /**\n     * Use writeClient and writeClock instead of writeID if possible.\n     * @param {number} client\n     */\n    writeClient(client) {\n      writeVarUint(this.restEncoder, client);\n    }\n    /**\n     * @param {number} info An unsigned 8-bit integer\n     */\n    writeInfo(info) {\n      writeUint8(this.restEncoder, info);\n    }\n    /**\n     * @param {string} s\n     */\n    writeString(s) {\n      writeVarString(this.restEncoder, s);\n    }\n    /**\n     * @param {boolean} isYKey\n     */\n    writeParentInfo(isYKey) {\n      writeVarUint(this.restEncoder, isYKey ? 1 : 0);\n    }\n    /**\n     * @param {number} info An unsigned 8-bit integer\n     */\n    writeTypeRef(info) {\n      writeVarUint(this.restEncoder, info);\n    }\n    /**\n     * Write len of a struct - well suited for Opt RLE encoder.\n     *\n     * @param {number} len\n     */\n    writeLen(len) {\n      writeVarUint(this.restEncoder, len);\n    }\n    /**\n     * @param {any} any\n     */\n    writeAny(any2) {\n      writeAny(this.restEncoder, any2);\n    }\n    /**\n     * @param {Uint8Array} buf\n     */\n    writeBuf(buf) {\n      writeVarUint8Array(this.restEncoder, buf);\n    }\n    /**\n     * @param {any} embed\n     */\n    writeJSON(embed) {\n      writeVarString(this.restEncoder, JSON.stringify(embed));\n    }\n    /**\n     * @param {string} key\n     */\n    writeKey(key) {\n      writeVarString(this.restEncoder, key);\n    }\n  };\n  var DSEncoderV2 = class {\n    constructor() {\n      this.restEncoder = createEncoder();\n      this.dsCurrVal = 0;\n    }\n    toUint8Array() {\n      return toUint8Array(this.restEncoder);\n    }\n    resetDsCurVal() {\n      this.dsCurrVal = 0;\n    }\n    /**\n     * @param {number} clock\n     */\n    writeDsClock(clock) {\n      const diff = clock - this.dsCurrVal;\n      this.dsCurrVal = clock;\n      writeVarUint(this.restEncoder, diff);\n    }\n    /**\n     * @param {number} len\n     */\n    writeDsLen(len) {\n      if (len === 0) {\n        unexpectedCase();\n      }\n      writeVarUint(this.restEncoder, len - 1);\n      this.dsCurrVal += len;\n    }\n  };\n  var UpdateEncoderV2 = class extends DSEncoderV2 {\n    constructor() {\n      super();\n      this.keyMap = /* @__PURE__ */ new Map();\n      this.keyClock = 0;\n      this.keyClockEncoder = new IntDiffOptRleEncoder();\n      this.clientEncoder = new UintOptRleEncoder();\n      this.leftClockEncoder = new IntDiffOptRleEncoder();\n      this.rightClockEncoder = new IntDiffOptRleEncoder();\n      this.infoEncoder = new RleEncoder(writeUint8);\n      this.stringEncoder = new StringEncoder();\n      this.parentInfoEncoder = new RleEncoder(writeUint8);\n      this.typeRefEncoder = new UintOptRleEncoder();\n      this.lenEncoder = new UintOptRleEncoder();\n    }\n    toUint8Array() {\n      const encoder = createEncoder();\n      writeVarUint(encoder, 0);\n      writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());\n      writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());\n      writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());\n      writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());\n      writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));\n      writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());\n      writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));\n      writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());\n      writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());\n      writeUint8Array(encoder, toUint8Array(this.restEncoder));\n      return toUint8Array(encoder);\n    }\n    /**\n     * @param {ID} id\n     */\n    writeLeftID(id2) {\n      this.clientEncoder.write(id2.client);\n      this.leftClockEncoder.write(id2.clock);\n    }\n    /**\n     * @param {ID} id\n     */\n    writeRightID(id2) {\n      this.clientEncoder.write(id2.client);\n      this.rightClockEncoder.write(id2.clock);\n    }\n    /**\n     * @param {number} client\n     */\n    writeClient(client) {\n      this.clientEncoder.write(client);\n    }\n    /**\n     * @param {number} info An unsigned 8-bit integer\n     */\n    writeInfo(info) {\n      this.infoEncoder.write(info);\n    }\n    /**\n     * @param {string} s\n     */\n    writeString(s) {\n      this.stringEncoder.write(s);\n    }\n    /**\n     * @param {boolean} isYKey\n     */\n    writeParentInfo(isYKey) {\n      this.parentInfoEncoder.write(isYKey ? 1 : 0);\n    }\n    /**\n     * @param {number} info An unsigned 8-bit integer\n     */\n    writeTypeRef(info) {\n      this.typeRefEncoder.write(info);\n    }\n    /**\n     * Write len of a struct - well suited for Opt RLE encoder.\n     *\n     * @param {number} len\n     */\n    writeLen(len) {\n      this.lenEncoder.write(len);\n    }\n    /**\n     * @param {any} any\n     */\n    writeAny(any2) {\n      writeAny(this.restEncoder, any2);\n    }\n    /**\n     * @param {Uint8Array} buf\n     */\n    writeBuf(buf) {\n      writeVarUint8Array(this.restEncoder, buf);\n    }\n    /**\n     * This is mainly here for legacy purposes.\n     *\n     * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n     *\n     * @param {any} embed\n     */\n    writeJSON(embed) {\n      writeAny(this.restEncoder, embed);\n    }\n    /**\n     * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n     * occur very often. For a 3d application, the key `position` might occur very often.\n     *\n     * We cache these keys in a Map and refer to them via a unique number.\n     *\n     * @param {string} key\n     */\n    writeKey(key) {\n      const clock = this.keyMap.get(key);\n      if (clock === void 0) {\n        this.keyClockEncoder.write(this.keyClock++);\n        this.stringEncoder.write(key);\n      } else {\n        this.keyClockEncoder.write(clock);\n      }\n    }\n  };\n  var writeStructs = (encoder, structs, client, clock) => {\n    clock = max(clock, structs[0].id.clock);\n    const startNewStructs = findIndexSS(structs, clock);\n    writeVarUint(encoder.restEncoder, structs.length - startNewStructs);\n    encoder.writeClient(client);\n    writeVarUint(encoder.restEncoder, clock);\n    const firstStruct = structs[startNewStructs];\n    firstStruct.write(encoder, clock - firstStruct.id.clock);\n    for (let i = startNewStructs + 1; i < structs.length; i++) {\n      structs[i].write(encoder, 0);\n    }\n  };\n  var writeClientsStructs = (encoder, store, _sm) => {\n    const sm = /* @__PURE__ */ new Map();\n    _sm.forEach((clock, client) => {\n      if (getState(store, client) > clock) {\n        sm.set(client, clock);\n      }\n    });\n    getStateVector(store).forEach((_clock, client) => {\n      if (!_sm.has(client)) {\n        sm.set(client, 0);\n      }\n    });\n    writeVarUint(encoder.restEncoder, sm.size);\n    from2(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n      writeStructs(\n        encoder,\n        /** @type {Array<GC|Item>} */\n        store.clients.get(client),\n        client,\n        clock\n      );\n    });\n  };\n  var readClientsStructRefs = (decoder, doc4) => {\n    const clientRefs = create();\n    const numOfStateUpdates = readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numOfStateUpdates; i++) {\n      const numberOfStructs = readVarUint(decoder.restDecoder);\n      const refs = new Array(numberOfStructs);\n      const client = decoder.readClient();\n      let clock = readVarUint(decoder.restDecoder);\n      clientRefs.set(client, { i: 0, refs });\n      for (let i2 = 0; i2 < numberOfStructs; i2++) {\n        const info = decoder.readInfo();\n        switch (BITS5 & info) {\n          case 0: {\n            const len = decoder.readLen();\n            refs[i2] = new GC(createID(client, clock), len);\n            clock += len;\n            break;\n          }\n          case 10: {\n            const len = readVarUint(decoder.restDecoder);\n            refs[i2] = new Skip(createID(client, clock), len);\n            clock += len;\n            break;\n          }\n          default: {\n            const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;\n            const struct = new Item2(\n              createID(client, clock),\n              null,\n              // left\n              (info & BIT8) === BIT8 ? decoder.readLeftID() : null,\n              // origin\n              null,\n              // right\n              (info & BIT7) === BIT7 ? decoder.readRightID() : null,\n              // right origin\n              cantCopyParentInfo ? decoder.readParentInfo() ? doc4.get(decoder.readString()) : decoder.readLeftID() : null,\n              // parent\n              cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,\n              // parentSub\n              readItemContent(decoder, info)\n              // item content\n            );\n            refs[i2] = struct;\n            clock += struct.length;\n          }\n        }\n      }\n    }\n    return clientRefs;\n  };\n  var integrateStructs = (transaction, store, clientsStructRefs) => {\n    const stack = [];\n    let clientsStructRefsIds = from2(clientsStructRefs.keys()).sort((a, b) => a - b);\n    if (clientsStructRefsIds.length === 0) {\n      return null;\n    }\n    const getNextStructTarget = () => {\n      if (clientsStructRefsIds.length === 0) {\n        return null;\n      }\n      let nextStructsTarget = (\n        /** @type {{i:number,refs:Array<GC|Item>}} */\n        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])\n      );\n      while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n        clientsStructRefsIds.pop();\n        if (clientsStructRefsIds.length > 0) {\n          nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */\n          clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);\n        } else {\n          return null;\n        }\n      }\n      return nextStructsTarget;\n    };\n    let curStructsTarget = getNextStructTarget();\n    if (curStructsTarget === null) {\n      return null;\n    }\n    const restStructs = new StructStore();\n    const missingSV = /* @__PURE__ */ new Map();\n    const updateMissingSv = (client, clock) => {\n      const mclock = missingSV.get(client);\n      if (mclock == null || mclock > clock) {\n        missingSV.set(client, clock);\n      }\n    };\n    let stackHead = (\n      /** @type {any} */\n      curStructsTarget.refs[\n        /** @type {any} */\n        curStructsTarget.i++\n      ]\n    );\n    const state = /* @__PURE__ */ new Map();\n    const addStackToRestSS = () => {\n      for (const item of stack) {\n        const client = item.id.client;\n        const inapplicableItems = clientsStructRefs.get(client);\n        if (inapplicableItems) {\n          inapplicableItems.i--;\n          restStructs.clients.set(client, inapplicableItems.refs.slice(inapplicableItems.i));\n          clientsStructRefs.delete(client);\n          inapplicableItems.i = 0;\n          inapplicableItems.refs = [];\n        } else {\n          restStructs.clients.set(client, [item]);\n        }\n        clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);\n      }\n      stack.length = 0;\n    };\n    while (true) {\n      if (stackHead.constructor !== Skip) {\n        const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));\n        const offset = localClock - stackHead.id.clock;\n        if (offset < 0) {\n          stack.push(stackHead);\n          updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);\n          addStackToRestSS();\n        } else {\n          const missing = stackHead.getMissing(transaction, store);\n          if (missing !== null) {\n            stack.push(stackHead);\n            const structRefs = clientsStructRefs.get(\n              /** @type {number} */\n              missing\n            ) || { refs: [], i: 0 };\n            if (structRefs.refs.length === structRefs.i) {\n              updateMissingSv(\n                /** @type {number} */\n                missing,\n                getState(store, missing)\n              );\n              addStackToRestSS();\n            } else {\n              stackHead = structRefs.refs[structRefs.i++];\n              continue;\n            }\n          } else if (offset === 0 || offset < stackHead.length) {\n            stackHead.integrate(transaction, offset);\n            state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);\n          }\n        }\n      }\n      if (stack.length > 0) {\n        stackHead = /** @type {GC|Item} */\n        stack.pop();\n      } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n        stackHead = /** @type {GC|Item} */\n        curStructsTarget.refs[curStructsTarget.i++];\n      } else {\n        curStructsTarget = getNextStructTarget();\n        if (curStructsTarget === null) {\n          break;\n        } else {\n          stackHead = /** @type {GC|Item} */\n          curStructsTarget.refs[curStructsTarget.i++];\n        }\n      }\n    }\n    if (restStructs.clients.size > 0) {\n      const encoder = new UpdateEncoderV2();\n      writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());\n      writeVarUint(encoder.restEncoder, 0);\n      return { missing: missingSV, update: encoder.toUint8Array() };\n    }\n    return null;\n  };\n  var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);\n  var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {\n    transaction.local = false;\n    let retry2 = false;\n    const doc4 = transaction.doc;\n    const store = doc4.store;\n    const ss = readClientsStructRefs(structDecoder, doc4);\n    const restStructs = integrateStructs(transaction, store, ss);\n    const pending = store.pendingStructs;\n    if (pending) {\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry2 = true;\n          break;\n        }\n      }\n      if (restStructs) {\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client);\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock);\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update]);\n      }\n    } else {\n      store.pendingStructs = restStructs;\n    }\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);\n    if (store.pendingDs) {\n      const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));\n      readVarUint(pendingDSUpdate.restDecoder);\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);\n      if (dsRest && dsRest2) {\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);\n      } else {\n        store.pendingDs = dsRest || dsRest2;\n      }\n    } else {\n      store.pendingDs = dsRest;\n    }\n    if (retry2) {\n      const update = (\n        /** @type {{update: Uint8Array}} */\n        store.pendingStructs.update\n      );\n      store.pendingStructs = null;\n      applyUpdateV2(transaction.doc, update);\n    }\n  }, transactionOrigin, false);\n  var readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));\n  var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n    const decoder = createDecoder(update);\n    readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));\n  };\n  var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);\n  var writeStateAsUpdate = (encoder, doc4, targetStateVector = /* @__PURE__ */ new Map()) => {\n    writeClientsStructs(encoder, doc4.store, targetStateVector);\n    writeDeleteSet(encoder, createDeleteSetFromStructStore(doc4.store));\n  };\n  var encodeStateAsUpdateV2 = (doc4, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n    const targetStateVector = decodeStateVector(encodedTargetStateVector);\n    writeStateAsUpdate(encoder, doc4, targetStateVector);\n    const updates = [encoder.toUint8Array()];\n    if (doc4.store.pendingDs) {\n      updates.push(doc4.store.pendingDs);\n    }\n    if (doc4.store.pendingStructs) {\n      updates.push(diffUpdateV2(doc4.store.pendingStructs.update, encodedTargetStateVector));\n    }\n    if (updates.length > 1) {\n      if (encoder.constructor === UpdateEncoderV1) {\n        return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));\n      } else if (encoder.constructor === UpdateEncoderV2) {\n        return mergeUpdatesV2(updates);\n      }\n    }\n    return updates[0];\n  };\n  var encodeStateAsUpdate = (doc4, encodedTargetStateVector) => encodeStateAsUpdateV2(doc4, encodedTargetStateVector, new UpdateEncoderV1());\n  var readStateVector = (decoder) => {\n    const ss = /* @__PURE__ */ new Map();\n    const ssLength = readVarUint(decoder.restDecoder);\n    for (let i = 0; i < ssLength; i++) {\n      const client = readVarUint(decoder.restDecoder);\n      const clock = readVarUint(decoder.restDecoder);\n      ss.set(client, clock);\n    }\n    return ss;\n  };\n  var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));\n  var writeStateVector = (encoder, sv) => {\n    writeVarUint(encoder.restEncoder, sv.size);\n    from2(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n      writeVarUint(encoder.restEncoder, client);\n      writeVarUint(encoder.restEncoder, clock);\n    });\n    return encoder;\n  };\n  var writeDocumentStateVector = (encoder, doc4) => writeStateVector(encoder, getStateVector(doc4.store));\n  var encodeStateVectorV2 = (doc4, encoder = new DSEncoderV2()) => {\n    if (doc4 instanceof Map) {\n      writeStateVector(encoder, doc4);\n    } else {\n      writeDocumentStateVector(encoder, doc4);\n    }\n    return encoder.toUint8Array();\n  };\n  var encodeStateVector = (doc4) => encodeStateVectorV2(doc4, new DSEncoderV1());\n  var EventHandler = class {\n    constructor() {\n      this.l = [];\n    }\n  };\n  var createEventHandler = () => new EventHandler();\n  var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);\n  var removeEventHandlerListener = (eventHandler, f) => {\n    const l = eventHandler.l;\n    const len = l.length;\n    eventHandler.l = l.filter((g) => f !== g);\n    if (len === eventHandler.l.length) {\n      console.error(\"[yjs] Tried to remove event handler that doesn't exist.\");\n    }\n  };\n  var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);\n  var ID = class {\n    /**\n     * @param {number} client client id\n     * @param {number} clock unique per client id, continuous number\n     */\n    constructor(client, clock) {\n      this.client = client;\n      this.clock = clock;\n    }\n  };\n  var compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;\n  var createID = (client, clock) => new ID(client, clock);\n  var writeID = (encoder, id2) => {\n    writeVarUint(encoder, id2.client);\n    writeVarUint(encoder, id2.clock);\n  };\n  var readID = (decoder) => createID(readVarUint(decoder), readVarUint(decoder));\n  var findRootTypeKey = (type) => {\n    for (const [key, value] of type.doc.share.entries()) {\n      if (value === type) {\n        return key;\n      }\n    }\n    throw unexpectedCase();\n  };\n  var isParentOf = (parent, child) => {\n    while (child !== null) {\n      if (child.parent === parent) {\n        return true;\n      }\n      child = /** @type {AbstractType<any>} */\n      child.parent._item;\n    }\n    return false;\n  };\n  var logType = (type) => {\n    const res = [];\n    let n = type._start;\n    while (n) {\n      res.push(n);\n      n = n.right;\n    }\n    console.log(\"Children: \", res);\n    console.log(\"Children content: \", res.filter((m) => !m.deleted).map((m) => m.content));\n  };\n  var PermanentUserData = class {\n    /**\n     * @param {Doc} doc\n     * @param {YMap<any>} [storeType]\n     */\n    constructor(doc4, storeType = doc4.getMap(\"users\")) {\n      const dss = /* @__PURE__ */ new Map();\n      this.yusers = storeType;\n      this.doc = doc4;\n      this.clients = /* @__PURE__ */ new Map();\n      this.dss = dss;\n      const initUser = (user, userDescription) => {\n        const ds = user.get(\"ds\");\n        const ids = user.get(\"ids\");\n        const addClientId = (\n          /** @param {number} clientid */\n          (clientid) => this.clients.set(clientid, userDescription)\n        );\n        ds.observe(\n          /** @param {YArrayEvent<any>} event */\n          (event) => {\n            event.changes.added.forEach((item) => {\n              item.content.getContent().forEach((encodedDs) => {\n                if (encodedDs instanceof Uint8Array) {\n                  this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(createDecoder(encodedDs)))]));\n                }\n              });\n            });\n          }\n        );\n        this.dss.set(userDescription, mergeDeleteSets(ds.map((encodedDs) => readDeleteSet(new DSDecoderV1(createDecoder(encodedDs))))));\n        ids.observe(\n          /** @param {YArrayEvent<any>} event */\n          (event) => event.changes.added.forEach((item) => item.content.getContent().forEach(addClientId))\n        );\n        ids.forEach(addClientId);\n      };\n      storeType.observe((event) => {\n        event.keysChanged.forEach(\n          (userDescription) => initUser(storeType.get(userDescription), userDescription)\n        );\n      });\n      storeType.forEach(initUser);\n    }\n    /**\n     * @param {Doc} doc\n     * @param {number} clientid\n     * @param {string} userDescription\n     * @param {Object} conf\n     * @param {function(Transaction, DeleteSet):boolean} [conf.filter]\n     */\n    setUserMapping(doc4, clientid, userDescription, { filter = () => true } = {}) {\n      const users = this.yusers;\n      let user = users.get(userDescription);\n      if (!user) {\n        user = new YMap();\n        user.set(\"ids\", new YArray());\n        user.set(\"ds\", new YArray());\n        users.set(userDescription, user);\n      }\n      user.get(\"ids\").push([clientid]);\n      users.observe((_event) => {\n        setTimeout(() => {\n          const userOverwrite = users.get(userDescription);\n          if (userOverwrite !== user) {\n            user = userOverwrite;\n            this.clients.forEach((_userDescription, clientid2) => {\n              if (userDescription === _userDescription) {\n                user.get(\"ids\").push([clientid2]);\n              }\n            });\n            const encoder = new DSEncoderV1();\n            const ds = this.dss.get(userDescription);\n            if (ds) {\n              writeDeleteSet(encoder, ds);\n              user.get(\"ds\").push([encoder.toUint8Array()]);\n            }\n          }\n        }, 0);\n      });\n      doc4.on(\n        \"afterTransaction\",\n        /** @param {Transaction} transaction */\n        (transaction) => {\n          setTimeout(() => {\n            const yds = user.get(\"ds\");\n            const ds = transaction.deleteSet;\n            if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {\n              const encoder = new DSEncoderV1();\n              writeDeleteSet(encoder, ds);\n              yds.push([encoder.toUint8Array()]);\n            }\n          });\n        }\n      );\n    }\n    /**\n     * @param {number} clientid\n     * @return {any}\n     */\n    getUserByClientId(clientid) {\n      return this.clients.get(clientid) || null;\n    }\n    /**\n     * @param {ID} id\n     * @return {string | null}\n     */\n    getUserByDeletedId(id2) {\n      for (const [userDescription, ds] of this.dss.entries()) {\n        if (isDeleted(ds, id2)) {\n          return userDescription;\n        }\n      }\n      return null;\n    }\n  };\n  var RelativePosition = class {\n    /**\n     * @param {ID|null} type\n     * @param {string|null} tname\n     * @param {ID|null} item\n     * @param {number} assoc\n     */\n    constructor(type, tname, item, assoc = 0) {\n      this.type = type;\n      this.tname = tname;\n      this.item = item;\n      this.assoc = assoc;\n    }\n  };\n  var relativePositionToJSON = (rpos) => {\n    const json = {};\n    if (rpos.type) {\n      json.type = rpos.type;\n    }\n    if (rpos.tname) {\n      json.tname = rpos.tname;\n    }\n    if (rpos.item) {\n      json.item = rpos.item;\n    }\n    if (rpos.assoc != null) {\n      json.assoc = rpos.assoc;\n    }\n    return json;\n  };\n  var createRelativePositionFromJSON = (json) => new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname ?? null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);\n  var AbsolutePosition = class {\n    /**\n     * @param {AbstractType<any>} type\n     * @param {number} index\n     * @param {number} [assoc]\n     */\n    constructor(type, index, assoc = 0) {\n      this.type = type;\n      this.index = index;\n      this.assoc = assoc;\n    }\n  };\n  var createAbsolutePosition = (type, index, assoc = 0) => new AbsolutePosition(type, index, assoc);\n  var createRelativePosition = (type, item, assoc) => {\n    let typeid = null;\n    let tname = null;\n    if (type._item === null) {\n      tname = findRootTypeKey(type);\n    } else {\n      typeid = createID(type._item.id.client, type._item.id.clock);\n    }\n    return new RelativePosition(typeid, tname, item, assoc);\n  };\n  var createRelativePositionFromTypeIndex = (type, index, assoc = 0) => {\n    let t = type._start;\n    if (assoc < 0) {\n      if (index === 0) {\n        return createRelativePosition(type, null, assoc);\n      }\n      index--;\n    }\n    while (t !== null) {\n      if (!t.deleted && t.countable) {\n        if (t.length > index) {\n          return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc);\n        }\n        index -= t.length;\n      }\n      if (t.right === null && assoc < 0) {\n        return createRelativePosition(type, t.lastId, assoc);\n      }\n      t = t.right;\n    }\n    return createRelativePosition(type, null, assoc);\n  };\n  var writeRelativePosition = (encoder, rpos) => {\n    const { type, tname, item, assoc } = rpos;\n    if (item !== null) {\n      writeVarUint(encoder, 0);\n      writeID(encoder, item);\n    } else if (tname !== null) {\n      writeUint8(encoder, 1);\n      writeVarString(encoder, tname);\n    } else if (type !== null) {\n      writeUint8(encoder, 2);\n      writeID(encoder, type);\n    } else {\n      throw unexpectedCase();\n    }\n    writeVarInt(encoder, assoc);\n    return encoder;\n  };\n  var encodeRelativePosition = (rpos) => {\n    const encoder = createEncoder();\n    writeRelativePosition(encoder, rpos);\n    return toUint8Array(encoder);\n  };\n  var readRelativePosition = (decoder) => {\n    let type = null;\n    let tname = null;\n    let itemID = null;\n    switch (readVarUint(decoder)) {\n      case 0:\n        itemID = readID(decoder);\n        break;\n      case 1:\n        tname = readVarString(decoder);\n        break;\n      case 2: {\n        type = readID(decoder);\n      }\n    }\n    const assoc = hasContent(decoder) ? readVarInt(decoder) : 0;\n    return new RelativePosition(type, tname, itemID, assoc);\n  };\n  var decodeRelativePosition = (uint8Array) => readRelativePosition(createDecoder(uint8Array));\n  var getItemWithOffset = (store, id2) => {\n    const item = getItem(store, id2);\n    const diff = id2.clock - item.id.clock;\n    return {\n      item,\n      diff\n    };\n  };\n  var createAbsolutePositionFromRelativePosition = (rpos, doc4, followUndoneDeletions = true) => {\n    const store = doc4.store;\n    const rightID = rpos.item;\n    const typeID = rpos.type;\n    const tname = rpos.tname;\n    const assoc = rpos.assoc;\n    let type = null;\n    let index = 0;\n    if (rightID !== null) {\n      if (getState(store, rightID.client) <= rightID.clock) {\n        return null;\n      }\n      const res = followUndoneDeletions ? followRedone(store, rightID) : getItemWithOffset(store, rightID);\n      const right = res.item;\n      if (!(right instanceof Item2)) {\n        return null;\n      }\n      type = /** @type {AbstractType<any>} */\n      right.parent;\n      if (type._item === null || !type._item.deleted) {\n        index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);\n        let n = right.left;\n        while (n !== null) {\n          if (!n.deleted && n.countable) {\n            index += n.length;\n          }\n          n = n.left;\n        }\n      }\n    } else {\n      if (tname !== null) {\n        type = doc4.get(tname);\n      } else if (typeID !== null) {\n        if (getState(store, typeID.client) <= typeID.clock) {\n          return null;\n        }\n        const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };\n        if (item instanceof Item2 && item.content instanceof ContentType) {\n          type = item.content.type;\n        } else {\n          return null;\n        }\n      } else {\n        throw unexpectedCase();\n      }\n      if (assoc >= 0) {\n        index = type._length;\n      } else {\n        index = 0;\n      }\n    }\n    return createAbsolutePosition(type, index, rpos.assoc);\n  };\n  var compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;\n  var Snapshot = class {\n    /**\n     * @param {DeleteSet} ds\n     * @param {Map<number,number>} sv state map\n     */\n    constructor(ds, sv) {\n      this.ds = ds;\n      this.sv = sv;\n    }\n  };\n  var equalSnapshots = (snap1, snap2) => {\n    const ds1 = snap1.ds.clients;\n    const ds2 = snap2.ds.clients;\n    const sv1 = snap1.sv;\n    const sv2 = snap2.sv;\n    if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n      return false;\n    }\n    for (const [key, value] of sv1.entries()) {\n      if (sv2.get(key) !== value) {\n        return false;\n      }\n    }\n    for (const [client, dsitems1] of ds1.entries()) {\n      const dsitems2 = ds2.get(client) || [];\n      if (dsitems1.length !== dsitems2.length) {\n        return false;\n      }\n      for (let i = 0; i < dsitems1.length; i++) {\n        const dsitem1 = dsitems1[i];\n        const dsitem2 = dsitems2[i];\n        if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n          return false;\n        }\n      }\n    }\n    return true;\n  };\n  var encodeSnapshotV2 = (snapshot2, encoder = new DSEncoderV2()) => {\n    writeDeleteSet(encoder, snapshot2.ds);\n    writeStateVector(encoder, snapshot2.sv);\n    return encoder.toUint8Array();\n  };\n  var encodeSnapshot = (snapshot2) => encodeSnapshotV2(snapshot2, new DSEncoderV1());\n  var decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(createDecoder(buf))) => {\n    return new Snapshot(readDeleteSet(decoder), readStateVector(decoder));\n  };\n  var decodeSnapshot = (buf) => decodeSnapshotV2(buf, new DSDecoderV1(createDecoder(buf)));\n  var createSnapshot = (ds, sm) => new Snapshot(ds, sm);\n  var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());\n  var snapshot = (doc4) => createSnapshot(createDeleteSetFromStructStore(doc4.store), getStateVector(doc4.store));\n  var isVisible = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && (snapshot2.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot2.ds, item.id);\n  var splitSnapshotAffectedStructs = (transaction, snapshot2) => {\n    const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);\n    const store = transaction.doc.store;\n    if (!meta.has(snapshot2)) {\n      snapshot2.sv.forEach((clock, client) => {\n        if (clock < getState(store, client)) {\n          getItemCleanStart(transaction, createID(client, clock));\n        }\n      });\n      iterateDeletedStructs(transaction, snapshot2.ds, (_item) => {\n      });\n      meta.add(snapshot2);\n    }\n  };\n  var createDocFromSnapshot = (originDoc, snapshot2, newDoc = new Doc()) => {\n    if (originDoc.gc) {\n      throw new Error(\"Garbage-collection must be disabled in `originDoc`!\");\n    }\n    const { sv, ds } = snapshot2;\n    const encoder = new UpdateEncoderV2();\n    originDoc.transact((transaction) => {\n      let size2 = 0;\n      sv.forEach((clock) => {\n        if (clock > 0) {\n          size2++;\n        }\n      });\n      writeVarUint(encoder.restEncoder, size2);\n      for (const [client, clock] of sv) {\n        if (clock === 0) {\n          continue;\n        }\n        if (clock < getState(originDoc.store, client)) {\n          getItemCleanStart(transaction, createID(client, clock));\n        }\n        const structs = originDoc.store.clients.get(client) || [];\n        const lastStructIndex = findIndexSS(structs, clock - 1);\n        writeVarUint(encoder.restEncoder, lastStructIndex + 1);\n        encoder.writeClient(client);\n        writeVarUint(encoder.restEncoder, 0);\n        for (let i = 0; i <= lastStructIndex; i++) {\n          structs[i].write(encoder, 0);\n        }\n      }\n      writeDeleteSet(encoder, ds);\n    });\n    applyUpdateV2(newDoc, encoder.toUint8Array(), \"snapshot\");\n    return newDoc;\n  };\n  var snapshotContainsUpdateV2 = (snapshot2, update, YDecoder = UpdateDecoderV2) => {\n    const updateDecoder = new YDecoder(createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n      if ((snapshot2.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {\n        return false;\n      }\n    }\n    const mergedDS = mergeDeleteSets([snapshot2.ds, readDeleteSet(updateDecoder)]);\n    return equalDeleteSets(snapshot2.ds, mergedDS);\n  };\n  var snapshotContainsUpdate = (snapshot2, update) => snapshotContainsUpdateV2(snapshot2, update, UpdateDecoderV1);\n  var StructStore = class {\n    constructor() {\n      this.clients = /* @__PURE__ */ new Map();\n      this.pendingStructs = null;\n      this.pendingDs = null;\n    }\n  };\n  var getStateVector = (store) => {\n    const sm = /* @__PURE__ */ new Map();\n    store.clients.forEach((structs, client) => {\n      const struct = structs[structs.length - 1];\n      sm.set(client, struct.id.clock + struct.length);\n    });\n    return sm;\n  };\n  var getState = (store, client) => {\n    const structs = store.clients.get(client);\n    if (structs === void 0) {\n      return 0;\n    }\n    const lastStruct = structs[structs.length - 1];\n    return lastStruct.id.clock + lastStruct.length;\n  };\n  var addStruct = (store, struct) => {\n    let structs = store.clients.get(struct.id.client);\n    if (structs === void 0) {\n      structs = [];\n      store.clients.set(struct.id.client, structs);\n    } else {\n      const lastStruct = structs[structs.length - 1];\n      if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n        throw unexpectedCase();\n      }\n    }\n    structs.push(struct);\n  };\n  var findIndexSS = (structs, clock) => {\n    let left = 0;\n    let right = structs.length - 1;\n    let mid = structs[right];\n    let midclock = mid.id.clock;\n    if (midclock === clock) {\n      return right;\n    }\n    let midindex = floor(clock / (midclock + mid.length - 1) * right);\n    while (left <= right) {\n      mid = structs[midindex];\n      midclock = mid.id.clock;\n      if (midclock <= clock) {\n        if (clock < midclock + mid.length) {\n          return midindex;\n        }\n        left = midindex + 1;\n      } else {\n        right = midindex - 1;\n      }\n      midindex = floor((left + right) / 2);\n    }\n    throw unexpectedCase();\n  };\n  var find = (store, id2) => {\n    const structs = store.clients.get(id2.client);\n    return structs[findIndexSS(structs, id2.clock)];\n  };\n  var getItem = (\n    /** @type {function(StructStore,ID):Item} */\n    find\n  );\n  var findIndexCleanStart = (transaction, structs, clock) => {\n    const index = findIndexSS(structs, clock);\n    const struct = structs[index];\n    if (struct.id.clock < clock && struct instanceof Item2) {\n      structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));\n      return index + 1;\n    }\n    return index;\n  };\n  var getItemCleanStart = (transaction, id2) => {\n    const structs = (\n      /** @type {Array<Item>} */\n      transaction.doc.store.clients.get(id2.client)\n    );\n    return structs[findIndexCleanStart(transaction, structs, id2.clock)];\n  };\n  var getItemCleanEnd = (transaction, store, id2) => {\n    const structs = store.clients.get(id2.client);\n    const index = findIndexSS(structs, id2.clock);\n    const struct = structs[index];\n    if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n      structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));\n    }\n    return struct;\n  };\n  var replaceStruct = (store, struct, newStruct) => {\n    const structs = (\n      /** @type {Array<GC|Item>} */\n      store.clients.get(struct.id.client)\n    );\n    structs[findIndexSS(structs, struct.id.clock)] = newStruct;\n  };\n  var iterateStructs = (transaction, structs, clockStart, len, f) => {\n    if (len === 0) {\n      return;\n    }\n    const clockEnd = clockStart + len;\n    let index = findIndexCleanStart(transaction, structs, clockStart);\n    let struct;\n    do {\n      struct = structs[index++];\n      if (clockEnd < struct.id.clock + struct.length) {\n        findIndexCleanStart(transaction, structs, clockEnd);\n      }\n      f(struct);\n    } while (index < structs.length && structs[index].id.clock < clockEnd);\n  };\n  var Transaction2 = class {\n    /**\n     * @param {Doc} doc\n     * @param {any} origin\n     * @param {boolean} local\n     */\n    constructor(doc4, origin, local) {\n      this.doc = doc4;\n      this.deleteSet = new DeleteSet();\n      this.beforeState = getStateVector(doc4.store);\n      this.afterState = /* @__PURE__ */ new Map();\n      this.changed = /* @__PURE__ */ new Map();\n      this.changedParentTypes = /* @__PURE__ */ new Map();\n      this._mergeStructs = [];\n      this.origin = origin;\n      this.meta = /* @__PURE__ */ new Map();\n      this.local = local;\n      this.subdocsAdded = /* @__PURE__ */ new Set();\n      this.subdocsRemoved = /* @__PURE__ */ new Set();\n      this.subdocsLoaded = /* @__PURE__ */ new Set();\n      this._needFormattingCleanup = false;\n    }\n  };\n  var writeUpdateMessageFromTransaction = (encoder, transaction) => {\n    if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n      return false;\n    }\n    sortAndMergeDeleteSet(transaction.deleteSet);\n    writeStructsFromTransaction(encoder, transaction);\n    writeDeleteSet(encoder, transaction.deleteSet);\n    return true;\n  };\n  var addChangedTypeToTransaction = (transaction, type, parentSub) => {\n    const item = type._item;\n    if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {\n      setIfUndefined(transaction.changed, type, create2).add(parentSub);\n    }\n  };\n  var tryToMergeWithLefts = (structs, pos) => {\n    let right = structs[pos];\n    let left = structs[pos - 1];\n    let i = pos;\n    for (; i > 0; right = left, left = structs[--i - 1]) {\n      if (left.deleted === right.deleted && left.constructor === right.constructor) {\n        if (left.mergeWith(right)) {\n          if (right instanceof Item2 && right.parentSub !== null && /** @type {AbstractType<any>} */\n          right.parent._map.get(right.parentSub) === right) {\n            right.parent._map.set(\n              right.parentSub,\n              /** @type {Item} */\n              left\n            );\n          }\n          continue;\n        }\n      }\n      break;\n    }\n    const merged = pos - i;\n    if (merged) {\n      structs.splice(pos + 1 - merged, merged);\n    }\n    return merged;\n  };\n  var tryGcDeleteSet = (ds, store, gcFilter) => {\n    for (const [client, deleteItems] of ds.clients.entries()) {\n      const structs = (\n        /** @type {Array<GC|Item>} */\n        store.clients.get(client)\n      );\n      for (let di = deleteItems.length - 1; di >= 0; di--) {\n        const deleteItem = deleteItems[di];\n        const endDeleteItemClock = deleteItem.clock + deleteItem.len;\n        for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {\n          const struct2 = structs[si];\n          if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {\n            break;\n          }\n          if (struct2 instanceof Item2 && struct2.deleted && !struct2.keep && gcFilter(struct2)) {\n            struct2.gc(store, false);\n          }\n        }\n      }\n    }\n  };\n  var tryMergeDeleteSet = (ds, store) => {\n    ds.clients.forEach((deleteItems, client) => {\n      const structs = (\n        /** @type {Array<GC|Item>} */\n        store.clients.get(client)\n      );\n      for (let di = deleteItems.length - 1; di >= 0; di--) {\n        const deleteItem = deleteItems[di];\n        const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));\n        for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {\n          si -= 1 + tryToMergeWithLefts(structs, si);\n        }\n      }\n    });\n  };\n  var tryGc = (ds, store, gcFilter) => {\n    tryGcDeleteSet(ds, store, gcFilter);\n    tryMergeDeleteSet(ds, store);\n  };\n  var cleanupTransactions = (transactionCleanups, i) => {\n    if (i < transactionCleanups.length) {\n      const transaction = transactionCleanups[i];\n      const doc4 = transaction.doc;\n      const store = doc4.store;\n      const ds = transaction.deleteSet;\n      const mergeStructs = transaction._mergeStructs;\n      try {\n        sortAndMergeDeleteSet(ds);\n        transaction.afterState = getStateVector(transaction.doc.store);\n        doc4.emit(\"beforeObserverCalls\", [transaction, doc4]);\n        const fs = [];\n        transaction.changed.forEach(\n          (subs, itemtype) => fs.push(() => {\n            if (itemtype._item === null || !itemtype._item.deleted) {\n              itemtype._callObserver(transaction, subs);\n            }\n          })\n        );\n        fs.push(() => {\n          transaction.changedParentTypes.forEach((events, type) => {\n            if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {\n              events = events.filter(\n                (event) => event.target._item === null || !event.target._item.deleted\n              );\n              events.forEach((event) => {\n                event.currentTarget = type;\n                event._path = null;\n              });\n              events.sort((event1, event2) => event1.path.length - event2.path.length);\n              callEventHandlerListeners(type._dEH, events, transaction);\n            }\n          });\n        });\n        fs.push(() => doc4.emit(\"afterTransaction\", [transaction, doc4]));\n        callAll(fs, []);\n        if (transaction._needFormattingCleanup) {\n          cleanupYTextAfterTransaction(transaction);\n        }\n      } finally {\n        if (doc4.gc) {\n          tryGcDeleteSet(ds, store, doc4.gcFilter);\n        }\n        tryMergeDeleteSet(ds, store);\n        transaction.afterState.forEach((clock, client) => {\n          const beforeClock = transaction.beforeState.get(client) || 0;\n          if (beforeClock !== clock) {\n            const structs = (\n              /** @type {Array<GC|Item>} */\n              store.clients.get(client)\n            );\n            const firstChangePos = max(findIndexSS(structs, beforeClock), 1);\n            for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {\n              i2 -= 1 + tryToMergeWithLefts(structs, i2);\n            }\n          }\n        });\n        for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {\n          const { client, clock } = mergeStructs[i2].id;\n          const structs = (\n            /** @type {Array<GC|Item>} */\n            store.clients.get(client)\n          );\n          const replacedStructPos = findIndexSS(structs, clock);\n          if (replacedStructPos + 1 < structs.length) {\n            if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {\n              continue;\n            }\n          }\n          if (replacedStructPos > 0) {\n            tryToMergeWithLefts(structs, replacedStructPos);\n          }\n        }\n        if (!transaction.local && transaction.afterState.get(doc4.clientID) !== transaction.beforeState.get(doc4.clientID)) {\n          print(ORANGE, BOLD, \"[yjs] \", UNBOLD, RED, \"Changed the client-id because another client seems to be using it.\");\n          doc4.clientID = generateNewClientId();\n        }\n        doc4.emit(\"afterTransactionCleanup\", [transaction, doc4]);\n        if (doc4._observers.has(\"update\")) {\n          const encoder = new UpdateEncoderV1();\n          const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);\n          if (hasContent2) {\n            doc4.emit(\"update\", [encoder.toUint8Array(), transaction.origin, doc4, transaction]);\n          }\n        }\n        if (doc4._observers.has(\"updateV2\")) {\n          const encoder = new UpdateEncoderV2();\n          const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);\n          if (hasContent2) {\n            doc4.emit(\"updateV2\", [encoder.toUint8Array(), transaction.origin, doc4, transaction]);\n          }\n        }\n        const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;\n        if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {\n          subdocsAdded.forEach((subdoc) => {\n            subdoc.clientID = doc4.clientID;\n            if (subdoc.collectionid == null) {\n              subdoc.collectionid = doc4.collectionid;\n            }\n            doc4.subdocs.add(subdoc);\n          });\n          subdocsRemoved.forEach((subdoc) => doc4.subdocs.delete(subdoc));\n          doc4.emit(\"subdocs\", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc4, transaction]);\n          subdocsRemoved.forEach((subdoc) => subdoc.destroy());\n        }\n        if (transactionCleanups.length <= i + 1) {\n          doc4._transactionCleanups = [];\n          doc4.emit(\"afterAllTransactions\", [doc4, transactionCleanups]);\n        } else {\n          cleanupTransactions(transactionCleanups, i + 1);\n        }\n      }\n    }\n  };\n  var transact = (doc4, f, origin = null, local = true) => {\n    const transactionCleanups = doc4._transactionCleanups;\n    let initialCall = false;\n    let result = null;\n    if (doc4._transaction === null) {\n      initialCall = true;\n      doc4._transaction = new Transaction2(doc4, origin, local);\n      transactionCleanups.push(doc4._transaction);\n      if (transactionCleanups.length === 1) {\n        doc4.emit(\"beforeAllTransactions\", [doc4]);\n      }\n      doc4.emit(\"beforeTransaction\", [doc4._transaction, doc4]);\n    }\n    try {\n      result = f(doc4._transaction);\n    } finally {\n      if (initialCall) {\n        const finishCleanup = doc4._transaction === transactionCleanups[0];\n        doc4._transaction = null;\n        if (finishCleanup) {\n          cleanupTransactions(transactionCleanups, 0);\n        }\n      }\n    }\n    return result;\n  };\n  var StackItem = class {\n    /**\n     * @param {DeleteSet} deletions\n     * @param {DeleteSet} insertions\n     */\n    constructor(deletions, insertions) {\n      this.insertions = insertions;\n      this.deletions = deletions;\n      this.meta = /* @__PURE__ */ new Map();\n    }\n  };\n  var clearUndoManagerStackItem = (tr, um, stackItem) => {\n    iterateDeletedStructs(tr, stackItem.deletions, (item) => {\n      if (item instanceof Item2 && um.scope.some((type) => type === tr.doc || isParentOf(\n        /** @type {AbstractType<any>} */\n        type,\n        item\n      ))) {\n        keepItem(item, false);\n      }\n    });\n  };\n  var popStackItem = (undoManager, stack, eventType) => {\n    let _tr = null;\n    const doc4 = undoManager.doc;\n    const scope = undoManager.scope;\n    transact(doc4, (transaction) => {\n      while (stack.length > 0 && undoManager.currStackItem === null) {\n        const store = doc4.store;\n        const stackItem = (\n          /** @type {StackItem} */\n          stack.pop()\n        );\n        const itemsToRedo = /* @__PURE__ */ new Set();\n        const itemsToDelete = [];\n        let performedChange = false;\n        iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {\n          if (struct instanceof Item2) {\n            if (struct.redone !== null) {\n              let { item, diff } = followRedone(store, struct.id);\n              if (diff > 0) {\n                item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));\n              }\n              struct = item;\n            }\n            if (!struct.deleted && scope.some((type) => type === transaction.doc || isParentOf(\n              /** @type {AbstractType<any>} */\n              type,\n              /** @type {Item} */\n              struct\n            ))) {\n              itemsToDelete.push(struct);\n            }\n          }\n        });\n        iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {\n          if (struct instanceof Item2 && scope.some((type) => type === transaction.doc || isParentOf(\n            /** @type {AbstractType<any>} */\n            type,\n            struct\n          )) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.\n          !isDeleted(stackItem.insertions, struct.id)) {\n            itemsToRedo.add(struct);\n          }\n        });\n        itemsToRedo.forEach((struct) => {\n          performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;\n        });\n        for (let i = itemsToDelete.length - 1; i >= 0; i--) {\n          const item = itemsToDelete[i];\n          if (undoManager.deleteFilter(item)) {\n            item.delete(transaction);\n            performedChange = true;\n          }\n        }\n        undoManager.currStackItem = performedChange ? stackItem : null;\n      }\n      transaction.changed.forEach((subProps, type) => {\n        if (subProps.has(null) && type._searchMarker) {\n          type._searchMarker.length = 0;\n        }\n      });\n      _tr = transaction;\n    }, undoManager);\n    const res = undoManager.currStackItem;\n    if (res != null) {\n      const changedParentTypes = _tr.changedParentTypes;\n      undoManager.emit(\"stack-item-popped\", [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);\n      undoManager.currStackItem = null;\n    }\n    return res;\n  };\n  var UndoManager = class extends ObservableV2 {\n    /**\n     * @param {Doc|AbstractType<any>|Array<AbstractType<any>>} typeScope Limits the scope of the UndoManager. If this is set to a ydoc instance, all changes on that ydoc will be undone. If set to a specific type, only changes on that type or its children will be undone. Also accepts an array of types.\n     * @param {UndoManagerOptions} options\n     */\n    constructor(typeScope, {\n      captureTimeout = 500,\n      captureTransaction = (_tr) => true,\n      deleteFilter = () => true,\n      trackedOrigins = /* @__PURE__ */ new Set([null]),\n      ignoreRemoteMapChanges = false,\n      doc: doc4 = (\n        /** @type {Doc} */\n        isArray(typeScope) ? typeScope[0].doc : typeScope instanceof Doc ? typeScope : typeScope.doc\n      )\n    } = {}) {\n      super();\n      this.scope = [];\n      this.doc = doc4;\n      this.addToScope(typeScope);\n      this.deleteFilter = deleteFilter;\n      trackedOrigins.add(this);\n      this.trackedOrigins = trackedOrigins;\n      this.captureTransaction = captureTransaction;\n      this.undoStack = [];\n      this.redoStack = [];\n      this.undoing = false;\n      this.redoing = false;\n      this.currStackItem = null;\n      this.lastChange = 0;\n      this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;\n      this.captureTimeout = captureTimeout;\n      this.afterTransactionHandler = (transaction) => {\n        if (!this.captureTransaction(transaction) || !this.scope.some((type) => transaction.changedParentTypes.has(\n          /** @type {AbstractType<any>} */\n          type\n        ) || type === this.doc) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {\n          return;\n        }\n        const undoing = this.undoing;\n        const redoing = this.redoing;\n        const stack = undoing ? this.redoStack : this.undoStack;\n        if (undoing) {\n          this.stopCapturing();\n        } else if (!redoing) {\n          this.clear(false, true);\n        }\n        const insertions = new DeleteSet();\n        transaction.afterState.forEach((endClock, client) => {\n          const startClock = transaction.beforeState.get(client) || 0;\n          const len = endClock - startClock;\n          if (len > 0) {\n            addToDeleteSet(insertions, client, startClock, len);\n          }\n        });\n        const now = getUnixTime();\n        let didAdd = false;\n        if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {\n          const lastOp = stack[stack.length - 1];\n          lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);\n          lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);\n        } else {\n          stack.push(new StackItem(transaction.deleteSet, insertions));\n          didAdd = true;\n        }\n        if (!undoing && !redoing) {\n          this.lastChange = now;\n        }\n        iterateDeletedStructs(\n          transaction,\n          transaction.deleteSet,\n          /** @param {Item|GC} item */\n          (item) => {\n            if (item instanceof Item2 && this.scope.some((type) => type === transaction.doc || isParentOf(\n              /** @type {AbstractType<any>} */\n              type,\n              item\n            ))) {\n              keepItem(item, true);\n            }\n          }\n        );\n        const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? \"redo\" : \"undo\", changedParentTypes: transaction.changedParentTypes }, this];\n        if (didAdd) {\n          this.emit(\"stack-item-added\", changeEvent);\n        } else {\n          this.emit(\"stack-item-updated\", changeEvent);\n        }\n      };\n      this.doc.on(\"afterTransaction\", this.afterTransactionHandler);\n      this.doc.on(\"destroy\", () => {\n        this.destroy();\n      });\n    }\n    /**\n     * Extend the scope.\n     *\n     * @param {Array<AbstractType<any> | Doc> | AbstractType<any> | Doc} ytypes\n     */\n    addToScope(ytypes) {\n      const tmpSet = new Set(this.scope);\n      ytypes = isArray(ytypes) ? ytypes : [ytypes];\n      ytypes.forEach((ytype) => {\n        if (!tmpSet.has(ytype)) {\n          tmpSet.add(ytype);\n          if (ytype instanceof AbstractType ? ytype.doc !== this.doc : ytype !== this.doc) warn(\"[yjs#509] Not same Y.Doc\");\n          this.scope.push(ytype);\n        }\n      });\n    }\n    /**\n     * @param {any} origin\n     */\n    addTrackedOrigin(origin) {\n      this.trackedOrigins.add(origin);\n    }\n    /**\n     * @param {any} origin\n     */\n    removeTrackedOrigin(origin) {\n      this.trackedOrigins.delete(origin);\n    }\n    clear(clearUndoStack = true, clearRedoStack = true) {\n      if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {\n        this.doc.transact((tr) => {\n          if (clearUndoStack) {\n            this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));\n            this.undoStack = [];\n          }\n          if (clearRedoStack) {\n            this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));\n            this.redoStack = [];\n          }\n          this.emit(\"stack-cleared\", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);\n        });\n      }\n    }\n    /**\n     * UndoManager merges Undo-StackItem if they are created within time-gap\n     * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next\n     * StackItem won't be merged.\n     *\n     *\n     * @example\n     *     // without stopCapturing\n     *     ytext.insert(0, 'a')\n     *     ytext.insert(1, 'b')\n     *     um.undo()\n     *     ytext.toString() // => '' (note that 'ab' was removed)\n     *     // with stopCapturing\n     *     ytext.insert(0, 'a')\n     *     um.stopCapturing()\n     *     ytext.insert(0, 'b')\n     *     um.undo()\n     *     ytext.toString() // => 'a' (note that only 'b' was removed)\n     *\n     */\n    stopCapturing() {\n      this.lastChange = 0;\n    }\n    /**\n     * Undo last changes on type.\n     *\n     * @return {StackItem?} Returns StackItem if a change was applied\n     */\n    undo() {\n      this.undoing = true;\n      let res;\n      try {\n        res = popStackItem(this, this.undoStack, \"undo\");\n      } finally {\n        this.undoing = false;\n      }\n      return res;\n    }\n    /**\n     * Redo last undo operation.\n     *\n     * @return {StackItem?} Returns StackItem if a change was applied\n     */\n    redo() {\n      this.redoing = true;\n      let res;\n      try {\n        res = popStackItem(this, this.redoStack, \"redo\");\n      } finally {\n        this.redoing = false;\n      }\n      return res;\n    }\n    /**\n     * Are undo steps available?\n     *\n     * @return {boolean} `true` if undo is possible\n     */\n    canUndo() {\n      return this.undoStack.length > 0;\n    }\n    /**\n     * Are redo steps available?\n     *\n     * @return {boolean} `true` if redo is possible\n     */\n    canRedo() {\n      return this.redoStack.length > 0;\n    }\n    destroy() {\n      this.trackedOrigins.delete(this);\n      this.doc.off(\"afterTransaction\", this.afterTransactionHandler);\n      super.destroy();\n    }\n  };\n  function* lazyStructReaderGenerator(decoder) {\n    const numOfStateUpdates = readVarUint(decoder.restDecoder);\n    for (let i = 0; i < numOfStateUpdates; i++) {\n      const numberOfStructs = readVarUint(decoder.restDecoder);\n      const client = decoder.readClient();\n      let clock = readVarUint(decoder.restDecoder);\n      for (let i2 = 0; i2 < numberOfStructs; i2++) {\n        const info = decoder.readInfo();\n        if (info === 10) {\n          const len = readVarUint(decoder.restDecoder);\n          yield new Skip(createID(client, clock), len);\n          clock += len;\n        } else if ((BITS5 & info) !== 0) {\n          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;\n          const struct = new Item2(\n            createID(client, clock),\n            null,\n            // left\n            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,\n            // origin\n            null,\n            // right\n            (info & BIT7) === BIT7 ? decoder.readRightID() : null,\n            // right origin\n            // @ts-ignore Force writing a string here.\n            cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,\n            // parent\n            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,\n            // parentSub\n            readItemContent(decoder, info)\n            // item content\n          );\n          yield struct;\n          clock += struct.length;\n        } else {\n          const len = decoder.readLen();\n          yield new GC(createID(client, clock), len);\n          clock += len;\n        }\n      }\n    }\n  }\n  var LazyStructReader = class {\n    /**\n     * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n     * @param {boolean} filterSkips\n     */\n    constructor(decoder, filterSkips) {\n      this.gen = lazyStructReaderGenerator(decoder);\n      this.curr = null;\n      this.done = false;\n      this.filterSkips = filterSkips;\n      this.next();\n    }\n    /**\n     * @return {Item | GC | Skip |null}\n     */\n    next() {\n      do {\n        this.curr = this.gen.next().value || null;\n      } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);\n      return this.curr;\n    }\n  };\n  var logUpdate = (update) => logUpdateV2(update, UpdateDecoderV1);\n  var logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n    const structs = [];\n    const updateDecoder = new YDecoder(createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n      structs.push(curr);\n    }\n    print(\"Structs: \", structs);\n    const ds = readDeleteSet(updateDecoder);\n    print(\"DeleteSet: \", ds);\n  };\n  var decodeUpdate = (update) => decodeUpdateV2(update, UpdateDecoderV1);\n  var decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n    const structs = [];\n    const updateDecoder = new YDecoder(createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n      structs.push(curr);\n    }\n    return {\n      structs,\n      ds: readDeleteSet(updateDecoder)\n    };\n  };\n  var LazyStructWriter = class {\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     */\n    constructor(encoder) {\n      this.currClient = 0;\n      this.startClock = 0;\n      this.written = 0;\n      this.encoder = encoder;\n      this.clientStructs = [];\n    }\n  };\n  var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);\n  var encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n    const encoder = new YEncoder();\n    const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);\n    let curr = updateDecoder.curr;\n    if (curr !== null) {\n      let size2 = 0;\n      let currClient = curr.id.client;\n      let stopCounting = curr.id.clock !== 0;\n      let currClock = stopCounting ? 0 : curr.id.clock + curr.length;\n      for (; curr !== null; curr = updateDecoder.next()) {\n        if (currClient !== curr.id.client) {\n          if (currClock !== 0) {\n            size2++;\n            writeVarUint(encoder.restEncoder, currClient);\n            writeVarUint(encoder.restEncoder, currClock);\n          }\n          currClient = curr.id.client;\n          currClock = 0;\n          stopCounting = curr.id.clock !== 0;\n        }\n        if (curr.constructor === Skip) {\n          stopCounting = true;\n        }\n        if (!stopCounting) {\n          currClock = curr.id.clock + curr.length;\n        }\n      }\n      if (currClock !== 0) {\n        size2++;\n        writeVarUint(encoder.restEncoder, currClient);\n        writeVarUint(encoder.restEncoder, currClock);\n      }\n      const enc = createEncoder();\n      writeVarUint(enc, size2);\n      writeBinaryEncoder(enc, encoder.restEncoder);\n      encoder.restEncoder = enc;\n      return encoder.toUint8Array();\n    } else {\n      writeVarUint(encoder.restEncoder, 0);\n      return encoder.toUint8Array();\n    }\n  };\n  var encodeStateVectorFromUpdate = (update) => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);\n  var parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n    const from4 = /* @__PURE__ */ new Map();\n    const to = /* @__PURE__ */ new Map();\n    const updateDecoder = new LazyStructReader(new YDecoder(createDecoder(update)), false);\n    let curr = updateDecoder.curr;\n    if (curr !== null) {\n      let currClient = curr.id.client;\n      let currClock = curr.id.clock;\n      from4.set(currClient, currClock);\n      for (; curr !== null; curr = updateDecoder.next()) {\n        if (currClient !== curr.id.client) {\n          to.set(currClient, currClock);\n          from4.set(curr.id.client, curr.id.clock);\n          currClient = curr.id.client;\n        }\n        currClock = curr.id.clock + curr.length;\n      }\n      to.set(currClient, currClock);\n    }\n    return { from: from4, to };\n  };\n  var parseUpdateMeta = (update) => parseUpdateMetaV2(update, UpdateDecoderV1);\n  var sliceStruct = (left, diff) => {\n    if (left.constructor === GC) {\n      const { client, clock } = left.id;\n      return new GC(createID(client, clock + diff), left.length - diff);\n    } else if (left.constructor === Skip) {\n      const { client, clock } = left.id;\n      return new Skip(createID(client, clock + diff), left.length - diff);\n    } else {\n      const leftItem = (\n        /** @type {Item} */\n        left\n      );\n      const { client, clock } = leftItem.id;\n      return new Item2(\n        createID(client, clock + diff),\n        null,\n        createID(client, clock + diff - 1),\n        null,\n        leftItem.rightOrigin,\n        leftItem.parent,\n        leftItem.parentSub,\n        leftItem.content.splice(diff)\n      );\n    }\n  };\n  var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n    if (updates.length === 1) {\n      return updates[0];\n    }\n    const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));\n    let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));\n    let currWrite = null;\n    const updateEncoder = new YEncoder();\n    const lazyStructEncoder = new LazyStructWriter(updateEncoder);\n    while (true) {\n      lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);\n      lazyStructDecoders.sort(\n        /** @type {function(any,any):number} */\n        (dec1, dec2) => {\n          if (dec1.curr.id.client === dec2.curr.id.client) {\n            const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;\n            if (clockDiff === 0) {\n              return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;\n            } else {\n              return clockDiff;\n            }\n          } else {\n            return dec2.curr.id.client - dec1.curr.id.client;\n          }\n        }\n      );\n      if (lazyStructDecoders.length === 0) {\n        break;\n      }\n      const currDecoder = lazyStructDecoders[0];\n      const firstClient = (\n        /** @type {Item | GC} */\n        currDecoder.curr.id.client\n      );\n      if (currWrite !== null) {\n        let curr = (\n          /** @type {Item | GC | null} */\n          currDecoder.curr\n        );\n        let iterated = false;\n        while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n          curr = currDecoder.next();\n          iterated = true;\n        }\n        if (curr === null || // current decoder is empty\n        curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`\n        iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {\n          continue;\n        }\n        if (firstClient !== currWrite.struct.id.client) {\n          writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n          currWrite = { struct: curr, offset: 0 };\n          currDecoder.next();\n        } else {\n          if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n            if (currWrite.struct.constructor === Skip) {\n              currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;\n            } else {\n              writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n              const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;\n              const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);\n              currWrite = { struct, offset: 0 };\n            }\n          } else {\n            const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;\n            if (diff > 0) {\n              if (currWrite.struct.constructor === Skip) {\n                currWrite.struct.length -= diff;\n              } else {\n                curr = sliceStruct(curr, diff);\n              }\n            }\n            if (!currWrite.struct.mergeWith(\n              /** @type {any} */\n              curr\n            )) {\n              writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n              currWrite = { struct: curr, offset: 0 };\n              currDecoder.next();\n            }\n          }\n        }\n      } else {\n        currWrite = { struct: (\n          /** @type {Item | GC} */\n          currDecoder.curr\n        ), offset: 0 };\n        currDecoder.next();\n      }\n      for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n        currWrite = { struct: next, offset: 0 };\n      }\n    }\n    if (currWrite !== null) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);\n      currWrite = null;\n    }\n    finishLazyStructWriting(lazyStructEncoder);\n    const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));\n    const ds = mergeDeleteSets(dss);\n    writeDeleteSet(updateEncoder, ds);\n    return updateEncoder.toUint8Array();\n  };\n  var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n    const state = decodeStateVector(sv);\n    const encoder = new YEncoder();\n    const lazyStructWriter = new LazyStructWriter(encoder);\n    const decoder = new YDecoder(createDecoder(update));\n    const reader = new LazyStructReader(decoder, false);\n    while (reader.curr) {\n      const curr = reader.curr;\n      const currClient = curr.id.client;\n      const svClock = state.get(currClient) || 0;\n      if (reader.curr.constructor === Skip) {\n        reader.next();\n        continue;\n      }\n      if (curr.id.clock + curr.length > svClock) {\n        writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));\n        reader.next();\n        while (reader.curr && reader.curr.id.client === currClient) {\n          writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);\n          reader.next();\n        }\n      } else {\n        while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n          reader.next();\n        }\n      }\n    }\n    finishLazyStructWriting(lazyStructWriter);\n    const ds = readDeleteSet(decoder);\n    writeDeleteSet(encoder, ds);\n    return encoder.toUint8Array();\n  };\n  var diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);\n  var flushLazyStructWriter = (lazyWriter) => {\n    if (lazyWriter.written > 0) {\n      lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });\n      lazyWriter.encoder.restEncoder = createEncoder();\n      lazyWriter.written = 0;\n    }\n  };\n  var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n    if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n      flushLazyStructWriter(lazyWriter);\n    }\n    if (lazyWriter.written === 0) {\n      lazyWriter.currClient = struct.id.client;\n      lazyWriter.encoder.writeClient(struct.id.client);\n      writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);\n    }\n    struct.write(lazyWriter.encoder, offset);\n    lazyWriter.written++;\n  };\n  var finishLazyStructWriting = (lazyWriter) => {\n    flushLazyStructWriter(lazyWriter);\n    const restEncoder = lazyWriter.encoder.restEncoder;\n    writeVarUint(restEncoder, lazyWriter.clientStructs.length);\n    for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n      const partStructs = lazyWriter.clientStructs[i];\n      writeVarUint(restEncoder, partStructs.written);\n      writeUint8Array(restEncoder, partStructs.restEncoder);\n    }\n  };\n  var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {\n    const updateDecoder = new YDecoder(createDecoder(update));\n    const lazyDecoder = new LazyStructReader(updateDecoder, false);\n    const updateEncoder = new YEncoder();\n    const lazyWriter = new LazyStructWriter(updateEncoder);\n    for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n      writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);\n    }\n    finishLazyStructWriting(lazyWriter);\n    const ds = readDeleteSet(updateDecoder);\n    writeDeleteSet(updateEncoder, ds);\n    return updateEncoder.toUint8Array();\n  };\n  var createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) => {\n    let i = 0;\n    const mapKeyCache = create();\n    const nodeNameCache = create();\n    const formattingKeyCache = create();\n    const formattingValueCache = create();\n    formattingValueCache.set(null, null);\n    return (block) => {\n      switch (block.constructor) {\n        case GC:\n        case Skip:\n          return block;\n        case Item2: {\n          const item = (\n            /** @type {Item} */\n            block\n          );\n          const content = item.content;\n          switch (content.constructor) {\n            case ContentDeleted:\n              break;\n            case ContentType: {\n              if (yxml) {\n                const type = (\n                  /** @type {ContentType} */\n                  content.type\n                );\n                if (type instanceof YXmlElement) {\n                  type.nodeName = setIfUndefined(nodeNameCache, type.nodeName, () => \"node-\" + i);\n                }\n                if (type instanceof YXmlHook) {\n                  type.hookName = setIfUndefined(nodeNameCache, type.hookName, () => \"hook-\" + i);\n                }\n              }\n              break;\n            }\n            case ContentAny: {\n              const c = (\n                /** @type {ContentAny} */\n                content\n              );\n              c.arr = c.arr.map(() => i);\n              break;\n            }\n            case ContentBinary: {\n              const c = (\n                /** @type {ContentBinary} */\n                content\n              );\n              c.content = new Uint8Array([i]);\n              break;\n            }\n            case ContentDoc: {\n              const c = (\n                /** @type {ContentDoc} */\n                content\n              );\n              if (subdocs) {\n                c.opts = {};\n                c.doc.guid = i + \"\";\n              }\n              break;\n            }\n            case ContentEmbed: {\n              const c = (\n                /** @type {ContentEmbed} */\n                content\n              );\n              c.embed = {};\n              break;\n            }\n            case ContentFormat: {\n              const c = (\n                /** @type {ContentFormat} */\n                content\n              );\n              if (formatting) {\n                c.key = setIfUndefined(formattingKeyCache, c.key, () => i + \"\");\n                c.value = setIfUndefined(formattingValueCache, c.value, () => ({ i }));\n              }\n              break;\n            }\n            case ContentJSON: {\n              const c = (\n                /** @type {ContentJSON} */\n                content\n              );\n              c.arr = c.arr.map(() => i);\n              break;\n            }\n            case ContentString: {\n              const c = (\n                /** @type {ContentString} */\n                content\n              );\n              c.str = repeat(i % 10 + \"\", c.str.length);\n              break;\n            }\n            default:\n              unexpectedCase();\n          }\n          if (item.parentSub) {\n            item.parentSub = setIfUndefined(mapKeyCache, item.parentSub, () => i + \"\");\n          }\n          i++;\n          return block;\n        }\n        default:\n          unexpectedCase();\n      }\n    };\n  };\n  var obfuscateUpdate = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);\n  var obfuscateUpdateV2 = (update, opts) => convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);\n  var convertUpdateFormatV1ToV2 = (update) => convertUpdateFormat(update, id, UpdateDecoderV1, UpdateEncoderV2);\n  var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);\n  var errorComputeChanges = \"You must not compute changes after the event-handler fired.\";\n  var YEvent = class {\n    /**\n     * @param {T} target The changed type.\n     * @param {Transaction} transaction\n     */\n    constructor(target, transaction) {\n      this.target = target;\n      this.currentTarget = target;\n      this.transaction = transaction;\n      this._changes = null;\n      this._keys = null;\n      this._delta = null;\n      this._path = null;\n    }\n    /**\n     * Computes the path from `y` to the changed type.\n     *\n     * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n     *\n     * The following property holds:\n     * @example\n     *   let type = y\n     *   event.path.forEach(dir => {\n     *     type = type.get(dir)\n     *   })\n     *   type === event.target // => true\n     */\n    get path() {\n      return this._path || (this._path = getPathTo(this.currentTarget, this.target));\n    }\n    /**\n     * Check if a struct is deleted by this event.\n     *\n     * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n     *\n     * @param {AbstractStruct} struct\n     * @return {boolean}\n     */\n    deletes(struct) {\n      return isDeleted(this.transaction.deleteSet, struct.id);\n    }\n    /**\n     * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    get keys() {\n      if (this._keys === null) {\n        if (this.transaction.doc._transactionCleanups.length === 0) {\n          throw create3(errorComputeChanges);\n        }\n        const keys4 = /* @__PURE__ */ new Map();\n        const target = this.target;\n        const changed = (\n          /** @type Set<string|null> */\n          this.transaction.changed.get(target)\n        );\n        changed.forEach((key) => {\n          if (key !== null) {\n            const item = (\n              /** @type {Item} */\n              target._map.get(key)\n            );\n            let action;\n            let oldValue;\n            if (this.adds(item)) {\n              let prev = item.left;\n              while (prev !== null && this.adds(prev)) {\n                prev = prev.left;\n              }\n              if (this.deletes(item)) {\n                if (prev !== null && this.deletes(prev)) {\n                  action = \"delete\";\n                  oldValue = last(prev.content.getContent());\n                } else {\n                  return;\n                }\n              } else {\n                if (prev !== null && this.deletes(prev)) {\n                  action = \"update\";\n                  oldValue = last(prev.content.getContent());\n                } else {\n                  action = \"add\";\n                  oldValue = void 0;\n                }\n              }\n            } else {\n              if (this.deletes(item)) {\n                action = \"delete\";\n                oldValue = last(\n                  /** @type {Item} */\n                  item.content.getContent()\n                );\n              } else {\n                return;\n              }\n            }\n            keys4.set(key, { action, oldValue });\n          }\n        });\n        this._keys = keys4;\n      }\n      return this._keys;\n    }\n    /**\n     * This is a computed property. Note that this can only be safely computed during the\n     * event call. Computing this property after other changes happened might result in\n     * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n     * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n     *\n     * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n     */\n    get delta() {\n      return this.changes.delta;\n    }\n    /**\n     * Check if a struct is added by this event.\n     *\n     * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n     *\n     * @param {AbstractStruct} struct\n     * @return {boolean}\n     */\n    adds(struct) {\n      return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);\n    }\n    /**\n     * This is a computed property. Note that this can only be safely computed during the\n     * event call. Computing this property after other changes happened might result in\n     * unexpected behavior (incorrect computation of deltas). A safe way to collect changes\n     * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.\n     *\n     * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n     */\n    get changes() {\n      let changes = this._changes;\n      if (changes === null) {\n        if (this.transaction.doc._transactionCleanups.length === 0) {\n          throw create3(errorComputeChanges);\n        }\n        const target = this.target;\n        const added = create2();\n        const deleted = create2();\n        const delta = [];\n        changes = {\n          added,\n          deleted,\n          delta,\n          keys: this.keys\n        };\n        const changed = (\n          /** @type Set<string|null> */\n          this.transaction.changed.get(target)\n        );\n        if (changed.has(null)) {\n          let lastOp = null;\n          const packOp = () => {\n            if (lastOp) {\n              delta.push(lastOp);\n            }\n          };\n          for (let item = target._start; item !== null; item = item.right) {\n            if (item.deleted) {\n              if (this.deletes(item) && !this.adds(item)) {\n                if (lastOp === null || lastOp.delete === void 0) {\n                  packOp();\n                  lastOp = { delete: 0 };\n                }\n                lastOp.delete += item.length;\n                deleted.add(item);\n              }\n            } else {\n              if (this.adds(item)) {\n                if (lastOp === null || lastOp.insert === void 0) {\n                  packOp();\n                  lastOp = { insert: [] };\n                }\n                lastOp.insert = lastOp.insert.concat(item.content.getContent());\n                added.add(item);\n              } else {\n                if (lastOp === null || lastOp.retain === void 0) {\n                  packOp();\n                  lastOp = { retain: 0 };\n                }\n                lastOp.retain += item.length;\n              }\n            }\n          }\n          if (lastOp !== null && lastOp.retain === void 0) {\n            packOp();\n          }\n        }\n        this._changes = changes;\n      }\n      return (\n        /** @type {any} */\n        changes\n      );\n    }\n  };\n  var getPathTo = (parent, child) => {\n    const path = [];\n    while (child._item !== null && child !== parent) {\n      if (child._item.parentSub !== null) {\n        path.unshift(child._item.parentSub);\n      } else {\n        let i = 0;\n        let c = (\n          /** @type {AbstractType<any>} */\n          child._item.parent._start\n        );\n        while (c !== child._item && c !== null) {\n          if (!c.deleted && c.countable) {\n            i += c.length;\n          }\n          c = c.right;\n        }\n        path.unshift(i);\n      }\n      child = /** @type {AbstractType<any>} */\n      child._item.parent;\n    }\n    return path;\n  };\n  var warnPrematureAccess = () => {\n    warn(\"Invalid access: Add Yjs type to a document before reading data.\");\n  };\n  var maxSearchMarker = 80;\n  var globalSearchMarkerTimestamp = 0;\n  var ArraySearchMarker = class {\n    /**\n     * @param {Item} p\n     * @param {number} index\n     */\n    constructor(p, index) {\n      p.marker = true;\n      this.p = p;\n      this.index = index;\n      this.timestamp = globalSearchMarkerTimestamp++;\n    }\n  };\n  var refreshMarkerTimestamp = (marker) => {\n    marker.timestamp = globalSearchMarkerTimestamp++;\n  };\n  var overwriteMarker = (marker, p, index) => {\n    marker.p.marker = false;\n    marker.p = p;\n    p.marker = true;\n    marker.index = index;\n    marker.timestamp = globalSearchMarkerTimestamp++;\n  };\n  var markPosition = (searchMarker, p, index) => {\n    if (searchMarker.length >= maxSearchMarker) {\n      const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);\n      overwriteMarker(marker, p, index);\n      return marker;\n    } else {\n      const pm = new ArraySearchMarker(p, index);\n      searchMarker.push(pm);\n      return pm;\n    }\n  };\n  var findMarker = (yarray, index) => {\n    if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n      return null;\n    }\n    const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);\n    let p = yarray._start;\n    let pindex = 0;\n    if (marker !== null) {\n      p = marker.p;\n      pindex = marker.index;\n      refreshMarkerTimestamp(marker);\n    }\n    while (p.right !== null && pindex < index) {\n      if (!p.deleted && p.countable) {\n        if (index < pindex + p.length) {\n          break;\n        }\n        pindex += p.length;\n      }\n      p = p.right;\n    }\n    while (p.left !== null && pindex > index) {\n      p = p.left;\n      if (!p.deleted && p.countable) {\n        pindex -= p.length;\n      }\n    }\n    while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n      p = p.left;\n      if (!p.deleted && p.countable) {\n        pindex -= p.length;\n      }\n    }\n    if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */\n    p.parent.length / maxSearchMarker) {\n      overwriteMarker(marker, p, pindex);\n      return marker;\n    } else {\n      return markPosition(yarray._searchMarker, p, pindex);\n    }\n  };\n  var updateMarkerChanges = (searchMarker, index, len) => {\n    for (let i = searchMarker.length - 1; i >= 0; i--) {\n      const m = searchMarker[i];\n      if (len > 0) {\n        let p = m.p;\n        p.marker = false;\n        while (p && (p.deleted || !p.countable)) {\n          p = p.left;\n          if (p && !p.deleted && p.countable) {\n            m.index -= p.length;\n          }\n        }\n        if (p === null || p.marker === true) {\n          searchMarker.splice(i, 1);\n          continue;\n        }\n        m.p = p;\n        p.marker = true;\n      }\n      if (index < m.index || len > 0 && index === m.index) {\n        m.index = max(index, m.index + len);\n      }\n    }\n  };\n  var getTypeChildren = (t) => {\n    t.doc ?? warnPrematureAccess();\n    let s = t._start;\n    const arr = [];\n    while (s) {\n      arr.push(s);\n      s = s.right;\n    }\n    return arr;\n  };\n  var callTypeObservers = (type, transaction, event) => {\n    const changedType = type;\n    const changedParentTypes = transaction.changedParentTypes;\n    while (true) {\n      setIfUndefined(changedParentTypes, type, () => []).push(event);\n      if (type._item === null) {\n        break;\n      }\n      type = /** @type {AbstractType<any>} */\n      type._item.parent;\n    }\n    callEventHandlerListeners(changedType._eH, event, transaction);\n  };\n  var AbstractType = class {\n    constructor() {\n      this._item = null;\n      this._map = /* @__PURE__ */ new Map();\n      this._start = null;\n      this.doc = null;\n      this._length = 0;\n      this._eH = createEventHandler();\n      this._dEH = createEventHandler();\n      this._searchMarker = null;\n    }\n    /**\n     * @return {AbstractType<any>|null}\n     */\n    get parent() {\n      return this._item ? (\n        /** @type {AbstractType<any>} */\n        this._item.parent\n      ) : null;\n    }\n    /**\n     * Integrate this type into the Yjs instance.\n     *\n     * * Save this struct in the os\n     * * This type is sent to other client\n     * * Observer functions are fired\n     *\n     * @param {Doc} y The Yjs instance\n     * @param {Item|null} item\n     */\n    _integrate(y, item) {\n      this.doc = y;\n      this._item = item;\n    }\n    /**\n     * @return {AbstractType<EventType>}\n     */\n    _copy() {\n      throw methodUnimplemented();\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {AbstractType<EventType>}\n     */\n    clone() {\n      throw methodUnimplemented();\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder\n     */\n    _write(_encoder) {\n    }\n    /**\n     * The first non-deleted item\n     */\n    get _first() {\n      let n = this._start;\n      while (n !== null && n.deleted) {\n        n = n.right;\n      }\n      return n;\n    }\n    /**\n     * Creates YEvent and calls all type observers.\n     * Must be implemented by each type.\n     *\n     * @param {Transaction} transaction\n     * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.\n     */\n    _callObserver(transaction, _parentSubs) {\n      if (!transaction.local && this._searchMarker) {\n        this._searchMarker.length = 0;\n      }\n    }\n    /**\n     * Observe all events that are created on this type.\n     *\n     * @param {function(EventType, Transaction):void} f Observer function\n     */\n    observe(f) {\n      addEventHandlerListener(this._eH, f);\n    }\n    /**\n     * Observe all events that are created by this type and its children.\n     *\n     * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n     */\n    observeDeep(f) {\n      addEventHandlerListener(this._dEH, f);\n    }\n    /**\n     * Unregister an observer function.\n     *\n     * @param {function(EventType,Transaction):void} f Observer function\n     */\n    unobserve(f) {\n      removeEventHandlerListener(this._eH, f);\n    }\n    /**\n     * Unregister an observer function.\n     *\n     * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function\n     */\n    unobserveDeep(f) {\n      removeEventHandlerListener(this._dEH, f);\n    }\n    /**\n     * @abstract\n     * @return {any}\n     */\n    toJSON() {\n    }\n  };\n  var typeListSlice = (type, start, end) => {\n    type.doc ?? warnPrematureAccess();\n    if (start < 0) {\n      start = type._length + start;\n    }\n    if (end < 0) {\n      end = type._length + end;\n    }\n    let len = end - start;\n    const cs = [];\n    let n = type._start;\n    while (n !== null && len > 0) {\n      if (n.countable && !n.deleted) {\n        const c = n.content.getContent();\n        if (c.length <= start) {\n          start -= c.length;\n        } else {\n          for (let i = start; i < c.length && len > 0; i++) {\n            cs.push(c[i]);\n            len--;\n          }\n          start = 0;\n        }\n      }\n      n = n.right;\n    }\n    return cs;\n  };\n  var typeListToArray = (type) => {\n    type.doc ?? warnPrematureAccess();\n    const cs = [];\n    let n = type._start;\n    while (n !== null) {\n      if (n.countable && !n.deleted) {\n        const c = n.content.getContent();\n        for (let i = 0; i < c.length; i++) {\n          cs.push(c[i]);\n        }\n      }\n      n = n.right;\n    }\n    return cs;\n  };\n  var typeListToArraySnapshot = (type, snapshot2) => {\n    const cs = [];\n    let n = type._start;\n    while (n !== null) {\n      if (n.countable && isVisible(n, snapshot2)) {\n        const c = n.content.getContent();\n        for (let i = 0; i < c.length; i++) {\n          cs.push(c[i]);\n        }\n      }\n      n = n.right;\n    }\n    return cs;\n  };\n  var typeListForEach = (type, f) => {\n    let index = 0;\n    let n = type._start;\n    type.doc ?? warnPrematureAccess();\n    while (n !== null) {\n      if (n.countable && !n.deleted) {\n        const c = n.content.getContent();\n        for (let i = 0; i < c.length; i++) {\n          f(c[i], index++, type);\n        }\n      }\n      n = n.right;\n    }\n  };\n  var typeListMap = (type, f) => {\n    const result = [];\n    typeListForEach(type, (c, i) => {\n      result.push(f(c, i, type));\n    });\n    return result;\n  };\n  var typeListCreateIterator = (type) => {\n    let n = type._start;\n    let currentContent = null;\n    let currentContentIndex = 0;\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next: () => {\n        if (currentContent === null) {\n          while (n !== null && n.deleted) {\n            n = n.right;\n          }\n          if (n === null) {\n            return {\n              done: true,\n              value: void 0\n            };\n          }\n          currentContent = n.content.getContent();\n          currentContentIndex = 0;\n          n = n.right;\n        }\n        const value = currentContent[currentContentIndex++];\n        if (currentContent.length <= currentContentIndex) {\n          currentContent = null;\n        }\n        return {\n          done: false,\n          value\n        };\n      }\n    };\n  };\n  var typeListGet = (type, index) => {\n    type.doc ?? warnPrematureAccess();\n    const marker = findMarker(type, index);\n    let n = type._start;\n    if (marker !== null) {\n      n = marker.p;\n      index -= marker.index;\n    }\n    for (; n !== null; n = n.right) {\n      if (!n.deleted && n.countable) {\n        if (index < n.length) {\n          return n.content.getContent()[index];\n        }\n        index -= n.length;\n      }\n    }\n  };\n  var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n    let left = referenceItem;\n    const doc4 = transaction.doc;\n    const ownClientId = doc4.clientID;\n    const store = doc4.store;\n    const right = referenceItem === null ? parent._start : referenceItem.right;\n    let jsonContent = [];\n    const packJsonContent = () => {\n      if (jsonContent.length > 0) {\n        left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));\n        left.integrate(transaction, 0);\n        jsonContent = [];\n      }\n    };\n    content.forEach((c) => {\n      if (c === null) {\n        jsonContent.push(c);\n      } else {\n        switch (c.constructor) {\n          case Number:\n          case Object:\n          case Boolean:\n          case Array:\n          case String:\n            jsonContent.push(c);\n            break;\n          default:\n            packJsonContent();\n            switch (c.constructor) {\n              case Uint8Array:\n              case ArrayBuffer:\n                left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(\n                  /** @type {Uint8Array} */\n                  c\n                )));\n                left.integrate(transaction, 0);\n                break;\n              case Doc:\n                left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(\n                  /** @type {Doc} */\n                  c\n                ));\n                left.integrate(transaction, 0);\n                break;\n              default:\n                if (c instanceof AbstractType) {\n                  left = new Item2(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));\n                  left.integrate(transaction, 0);\n                } else {\n                  throw new Error(\"Unexpected content type in insert operation\");\n                }\n            }\n        }\n      }\n    });\n    packJsonContent();\n  };\n  var lengthExceeded = () => create3(\"Length exceeded!\");\n  var typeListInsertGenerics = (transaction, parent, index, content) => {\n    if (index > parent._length) {\n      throw lengthExceeded();\n    }\n    if (index === 0) {\n      if (parent._searchMarker) {\n        updateMarkerChanges(parent._searchMarker, index, content.length);\n      }\n      return typeListInsertGenericsAfter(transaction, parent, null, content);\n    }\n    const startIndex = index;\n    const marker = findMarker(parent, index);\n    let n = parent._start;\n    if (marker !== null) {\n      n = marker.p;\n      index -= marker.index;\n      if (index === 0) {\n        n = n.prev;\n        index += n && n.countable && !n.deleted ? n.length : 0;\n      }\n    }\n    for (; n !== null; n = n.right) {\n      if (!n.deleted && n.countable) {\n        if (index <= n.length) {\n          if (index < n.length) {\n            getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n          }\n          break;\n        }\n        index -= n.length;\n      }\n    }\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, startIndex, content.length);\n    }\n    return typeListInsertGenericsAfter(transaction, parent, n, content);\n  };\n  var typeListPushGenerics = (transaction, parent, content) => {\n    const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });\n    let n = marker.p;\n    if (n) {\n      while (n.right) {\n        n = n.right;\n      }\n    }\n    return typeListInsertGenericsAfter(transaction, parent, n, content);\n  };\n  var typeListDelete = (transaction, parent, index, length4) => {\n    if (length4 === 0) {\n      return;\n    }\n    const startIndex = index;\n    const startLength = length4;\n    const marker = findMarker(parent, index);\n    let n = parent._start;\n    if (marker !== null) {\n      n = marker.p;\n      index -= marker.index;\n    }\n    for (; n !== null && index > 0; n = n.right) {\n      if (!n.deleted && n.countable) {\n        if (index < n.length) {\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));\n        }\n        index -= n.length;\n      }\n    }\n    while (length4 > 0 && n !== null) {\n      if (!n.deleted) {\n        if (length4 < n.length) {\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length4));\n        }\n        n.delete(transaction);\n        length4 -= n.length;\n      }\n      n = n.right;\n    }\n    if (length4 > 0) {\n      throw lengthExceeded();\n    }\n    if (parent._searchMarker) {\n      updateMarkerChanges(\n        parent._searchMarker,\n        startIndex,\n        -startLength + length4\n        /* in case we remove the above exception */\n      );\n    }\n  };\n  var typeMapDelete = (transaction, parent, key) => {\n    const c = parent._map.get(key);\n    if (c !== void 0) {\n      c.delete(transaction);\n    }\n  };\n  var typeMapSet = (transaction, parent, key, value) => {\n    const left = parent._map.get(key) || null;\n    const doc4 = transaction.doc;\n    const ownClientId = doc4.clientID;\n    let content;\n    if (value == null) {\n      content = new ContentAny([value]);\n    } else {\n      switch (value.constructor) {\n        case Number:\n        case Object:\n        case Boolean:\n        case Array:\n        case String:\n        case Date:\n        case BigInt:\n          content = new ContentAny([value]);\n          break;\n        case Uint8Array:\n          content = new ContentBinary(\n            /** @type {Uint8Array} */\n            value\n          );\n          break;\n        case Doc:\n          content = new ContentDoc(\n            /** @type {Doc} */\n            value\n          );\n          break;\n        default:\n          if (value instanceof AbstractType) {\n            content = new ContentType(value);\n          } else {\n            throw new Error(\"Unexpected content type\");\n          }\n      }\n    }\n    new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);\n  };\n  var typeMapGet = (parent, key) => {\n    parent.doc ?? warnPrematureAccess();\n    const val = parent._map.get(key);\n    return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;\n  };\n  var typeMapGetAll = (parent) => {\n    const res = {};\n    parent.doc ?? warnPrematureAccess();\n    parent._map.forEach((value, key) => {\n      if (!value.deleted) {\n        res[key] = value.content.getContent()[value.length - 1];\n      }\n    });\n    return res;\n  };\n  var typeMapHas = (parent, key) => {\n    parent.doc ?? warnPrematureAccess();\n    const val = parent._map.get(key);\n    return val !== void 0 && !val.deleted;\n  };\n  var typeMapGetSnapshot = (parent, key, snapshot2) => {\n    let v = parent._map.get(key) || null;\n    while (v !== null && (!snapshot2.sv.has(v.id.client) || v.id.clock >= (snapshot2.sv.get(v.id.client) || 0))) {\n      v = v.left;\n    }\n    return v !== null && isVisible(v, snapshot2) ? v.content.getContent()[v.length - 1] : void 0;\n  };\n  var typeMapGetAllSnapshot = (parent, snapshot2) => {\n    const res = {};\n    parent._map.forEach((value, key) => {\n      let v = value;\n      while (v !== null && (!snapshot2.sv.has(v.id.client) || v.id.clock >= (snapshot2.sv.get(v.id.client) || 0))) {\n        v = v.left;\n      }\n      if (v !== null && isVisible(v, snapshot2)) {\n        res[key] = v.content.getContent()[v.length - 1];\n      }\n    });\n    return res;\n  };\n  var createMapIterator = (type) => {\n    type.doc ?? warnPrematureAccess();\n    return iteratorFilter(\n      type._map.entries(),\n      /** @param {any} entry */\n      (entry) => !entry[1].deleted\n    );\n  };\n  var YArrayEvent = class extends YEvent {\n  };\n  var YArray = class _YArray extends AbstractType {\n    constructor() {\n      super();\n      this._prelimContent = [];\n      this._searchMarker = [];\n    }\n    /**\n     * Construct a new YArray containing the specified items.\n     * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T\n     * @param {Array<T>} items\n     * @return {YArray<T>}\n     */\n    static from(items) {\n      const a = new _YArray();\n      a.push(items);\n      return a;\n    }\n    /**\n     * Integrate this type into the Yjs instance.\n     *\n     * * Save this struct in the os\n     * * This type is sent to other client\n     * * Observer functions are fired\n     *\n     * @param {Doc} y The Yjs instance\n     * @param {Item} item\n     */\n    _integrate(y, item) {\n      super._integrate(y, item);\n      this.insert(\n        0,\n        /** @type {Array<any>} */\n        this._prelimContent\n      );\n      this._prelimContent = null;\n    }\n    /**\n     * @return {YArray<T>}\n     */\n    _copy() {\n      return new _YArray();\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {YArray<T>}\n     */\n    clone() {\n      const arr = new _YArray();\n      arr.insert(0, this.toArray().map(\n        (el) => el instanceof AbstractType ? (\n          /** @type {typeof el} */\n          el.clone()\n        ) : el\n      ));\n      return arr;\n    }\n    get length() {\n      this.doc ?? warnPrematureAccess();\n      return this._length;\n    }\n    /**\n     * Creates YArrayEvent and calls observers.\n     *\n     * @param {Transaction} transaction\n     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n     */\n    _callObserver(transaction, parentSubs) {\n      super._callObserver(transaction, parentSubs);\n      callTypeObservers(this, transaction, new YArrayEvent(this, transaction));\n    }\n    /**\n     * Inserts new content at an index.\n     *\n     * Important: This function expects an array of content. Not just a content\n     * object. The reason for this \"weirdness\" is that inserting several elements\n     * is very efficient when it is done as a single operation.\n     *\n     * @example\n     *  // Insert character 'a' at position 0\n     *  yarray.insert(0, ['a'])\n     *  // Insert numbers 1, 2 at position 1\n     *  yarray.insert(1, [1, 2])\n     *\n     * @param {number} index The index to insert content at.\n     * @param {Array<T>} content The array of content\n     */\n    insert(index, content) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeListInsertGenerics(\n            transaction,\n            this,\n            index,\n            /** @type {any} */\n            content\n          );\n        });\n      } else {\n        this._prelimContent.splice(index, 0, ...content);\n      }\n    }\n    /**\n     * Appends content to this YArray.\n     *\n     * @param {Array<T>} content Array of content to append.\n     *\n     * @todo Use the following implementation in all types.\n     */\n    push(content) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeListPushGenerics(\n            transaction,\n            this,\n            /** @type {any} */\n            content\n          );\n        });\n      } else {\n        this._prelimContent.push(...content);\n      }\n    }\n    /**\n     * Prepends content to this YArray.\n     *\n     * @param {Array<T>} content Array of content to prepend.\n     */\n    unshift(content) {\n      this.insert(0, content);\n    }\n    /**\n     * Deletes elements starting from an index.\n     *\n     * @param {number} index Index at which to start deleting elements\n     * @param {number} length The number of elements to remove. Defaults to 1.\n     */\n    delete(index, length4 = 1) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeListDelete(transaction, this, index, length4);\n        });\n      } else {\n        this._prelimContent.splice(index, length4);\n      }\n    }\n    /**\n     * Returns the i-th element from a YArray.\n     *\n     * @param {number} index The index of the element to return from the YArray\n     * @return {T}\n     */\n    get(index) {\n      return typeListGet(this, index);\n    }\n    /**\n     * Transforms this YArray to a JavaScript Array.\n     *\n     * @return {Array<T>}\n     */\n    toArray() {\n      return typeListToArray(this);\n    }\n    /**\n     * Returns a portion of this YArray into a JavaScript Array selected\n     * from start to end (end not included).\n     *\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {Array<T>}\n     */\n    slice(start = 0, end = this.length) {\n      return typeListSlice(this, start, end);\n    }\n    /**\n     * Transforms this Shared Type to a JSON object.\n     *\n     * @return {Array<any>}\n     */\n    toJSON() {\n      return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);\n    }\n    /**\n     * Returns an Array with the result of calling a provided function on every\n     * element of this YArray.\n     *\n     * @template M\n     * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n     * @return {Array<M>} A new array with each element being the result of the\n     *                 callback function\n     */\n    map(f) {\n      return typeListMap(\n        this,\n        /** @type {any} */\n        f\n      );\n    }\n    /**\n     * Executes a provided function once on every element of this YArray.\n     *\n     * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n     */\n    forEach(f) {\n      typeListForEach(this, f);\n    }\n    /**\n     * @return {IterableIterator<T>}\n     */\n    [Symbol.iterator]() {\n      return typeListCreateIterator(this);\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     */\n    _write(encoder) {\n      encoder.writeTypeRef(YArrayRefID);\n    }\n  };\n  var readYArray = (_decoder) => new YArray();\n  var YMapEvent = class extends YEvent {\n    /**\n     * @param {YMap<T>} ymap The YArray that changed.\n     * @param {Transaction} transaction\n     * @param {Set<any>} subs The keys that changed.\n     */\n    constructor(ymap, transaction, subs) {\n      super(ymap, transaction);\n      this.keysChanged = subs;\n    }\n  };\n  var YMap = class _YMap extends AbstractType {\n    /**\n     *\n     * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n     */\n    constructor(entries) {\n      super();\n      this._prelimContent = null;\n      if (entries === void 0) {\n        this._prelimContent = /* @__PURE__ */ new Map();\n      } else {\n        this._prelimContent = new Map(entries);\n      }\n    }\n    /**\n     * Integrate this type into the Yjs instance.\n     *\n     * * Save this struct in the os\n     * * This type is sent to other client\n     * * Observer functions are fired\n     *\n     * @param {Doc} y The Yjs instance\n     * @param {Item} item\n     */\n    _integrate(y, item) {\n      super._integrate(y, item);\n      this._prelimContent.forEach((value, key) => {\n        this.set(key, value);\n      });\n      this._prelimContent = null;\n    }\n    /**\n     * @return {YMap<MapType>}\n     */\n    _copy() {\n      return new _YMap();\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {YMap<MapType>}\n     */\n    clone() {\n      const map3 = new _YMap();\n      this.forEach((value, key) => {\n        map3.set(key, value instanceof AbstractType ? (\n          /** @type {typeof value} */\n          value.clone()\n        ) : value);\n      });\n      return map3;\n    }\n    /**\n     * Creates YMapEvent and calls observers.\n     *\n     * @param {Transaction} transaction\n     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n     */\n    _callObserver(transaction, parentSubs) {\n      callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));\n    }\n    /**\n     * Transforms this Shared Type to a JSON object.\n     *\n     * @return {Object<string,any>}\n     */\n    toJSON() {\n      this.doc ?? warnPrematureAccess();\n      const map3 = {};\n      this._map.forEach((item, key) => {\n        if (!item.deleted) {\n          const v = item.content.getContent()[item.length - 1];\n          map3[key] = v instanceof AbstractType ? v.toJSON() : v;\n        }\n      });\n      return map3;\n    }\n    /**\n     * Returns the size of the YMap (count of key/value pairs)\n     *\n     * @return {number}\n     */\n    get size() {\n      return [...createMapIterator(this)].length;\n    }\n    /**\n     * Returns the keys for each element in the YMap Type.\n     *\n     * @return {IterableIterator<string>}\n     */\n    keys() {\n      return iteratorMap(\n        createMapIterator(this),\n        /** @param {any} v */\n        (v) => v[0]\n      );\n    }\n    /**\n     * Returns the values for each element in the YMap Type.\n     *\n     * @return {IterableIterator<MapType>}\n     */\n    values() {\n      return iteratorMap(\n        createMapIterator(this),\n        /** @param {any} v */\n        (v) => v[1].content.getContent()[v[1].length - 1]\n      );\n    }\n    /**\n     * Returns an Iterator of [key, value] pairs\n     *\n     * @return {IterableIterator<[string, MapType]>}\n     */\n    entries() {\n      return iteratorMap(\n        createMapIterator(this),\n        /** @param {any} v */\n        (v) => (\n          /** @type {any} */\n          [v[0], v[1].content.getContent()[v[1].length - 1]]\n        )\n      );\n    }\n    /**\n     * Executes a provided function on once on every key-value pair.\n     *\n     * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.\n     */\n    forEach(f) {\n      this.doc ?? warnPrematureAccess();\n      this._map.forEach((item, key) => {\n        if (!item.deleted) {\n          f(item.content.getContent()[item.length - 1], key, this);\n        }\n      });\n    }\n    /**\n     * Returns an Iterator of [key, value] pairs\n     *\n     * @return {IterableIterator<[string, MapType]>}\n     */\n    [Symbol.iterator]() {\n      return this.entries();\n    }\n    /**\n     * Remove a specified element from this YMap.\n     *\n     * @param {string} key The key of the element to remove.\n     */\n    delete(key) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeMapDelete(transaction, this, key);\n        });\n      } else {\n        this._prelimContent.delete(key);\n      }\n    }\n    /**\n     * Adds or updates an element with a specified key and value.\n     * @template {MapType} VAL\n     *\n     * @param {string} key The key of the element to add to this YMap\n     * @param {VAL} value The value of the element to add\n     * @return {VAL}\n     */\n    set(key, value) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeMapSet(\n            transaction,\n            this,\n            key,\n            /** @type {any} */\n            value\n          );\n        });\n      } else {\n        this._prelimContent.set(key, value);\n      }\n      return value;\n    }\n    /**\n     * Returns a specified element from this YMap.\n     *\n     * @param {string} key\n     * @return {MapType|undefined}\n     */\n    get(key) {\n      return (\n        /** @type {any} */\n        typeMapGet(this, key)\n      );\n    }\n    /**\n     * Returns a boolean indicating whether the specified key exists or not.\n     *\n     * @param {string} key The key to test.\n     * @return {boolean}\n     */\n    has(key) {\n      return typeMapHas(this, key);\n    }\n    /**\n     * Removes all elements from this YMap.\n     */\n    clear() {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          this.forEach(function(_value, key, map3) {\n            typeMapDelete(transaction, map3, key);\n          });\n        });\n      } else {\n        this._prelimContent.clear();\n      }\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     */\n    _write(encoder) {\n      encoder.writeTypeRef(YMapRefID);\n    }\n  };\n  var readYMap = (_decoder) => new YMap();\n  var equalAttrs = (a, b) => a === b || typeof a === \"object\" && typeof b === \"object\" && a && b && equalFlat(a, b);\n  var ItemTextListPosition = class {\n    /**\n     * @param {Item|null} left\n     * @param {Item|null} right\n     * @param {number} index\n     * @param {Map<string,any>} currentAttributes\n     */\n    constructor(left, right, index, currentAttributes) {\n      this.left = left;\n      this.right = right;\n      this.index = index;\n      this.currentAttributes = currentAttributes;\n    }\n    /**\n     * Only call this if you know that this.right is defined\n     */\n    forward() {\n      if (this.right === null) {\n        unexpectedCase();\n      }\n      switch (this.right.content.constructor) {\n        case ContentFormat:\n          if (!this.right.deleted) {\n            updateCurrentAttributes(\n              this.currentAttributes,\n              /** @type {ContentFormat} */\n              this.right.content\n            );\n          }\n          break;\n        default:\n          if (!this.right.deleted) {\n            this.index += this.right.length;\n          }\n          break;\n      }\n      this.left = this.right;\n      this.right = this.right.right;\n    }\n  };\n  var findNextPosition = (transaction, pos, count) => {\n    while (pos.right !== null && count > 0) {\n      switch (pos.right.content.constructor) {\n        case ContentFormat:\n          if (!pos.right.deleted) {\n            updateCurrentAttributes(\n              pos.currentAttributes,\n              /** @type {ContentFormat} */\n              pos.right.content\n            );\n          }\n          break;\n        default:\n          if (!pos.right.deleted) {\n            if (count < pos.right.length) {\n              getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));\n            }\n            pos.index += pos.right.length;\n            count -= pos.right.length;\n          }\n          break;\n      }\n      pos.left = pos.right;\n      pos.right = pos.right.right;\n    }\n    return pos;\n  };\n  var findPosition = (transaction, parent, index, useSearchMarker) => {\n    const currentAttributes = /* @__PURE__ */ new Map();\n    const marker = useSearchMarker ? findMarker(parent, index) : null;\n    if (marker) {\n      const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);\n      return findNextPosition(transaction, pos, index - marker.index);\n    } else {\n      const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);\n      return findNextPosition(transaction, pos, index);\n    }\n  };\n  var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n    while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(\n      negatedAttributes.get(\n        /** @type {ContentFormat} */\n        currPos.right.content.key\n      ),\n      /** @type {ContentFormat} */\n      currPos.right.content.value\n    ))) {\n      if (!currPos.right.deleted) {\n        negatedAttributes.delete(\n          /** @type {ContentFormat} */\n          currPos.right.content.key\n        );\n      }\n      currPos.forward();\n    }\n    const doc4 = transaction.doc;\n    const ownClientId = doc4.clientID;\n    negatedAttributes.forEach((val, key) => {\n      const left = currPos.left;\n      const right = currPos.right;\n      const nextFormat = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n      nextFormat.integrate(transaction, 0);\n      currPos.right = nextFormat;\n      currPos.forward();\n    });\n  };\n  var updateCurrentAttributes = (currentAttributes, format) => {\n    const { key, value } = format;\n    if (value === null) {\n      currentAttributes.delete(key);\n    } else {\n      currentAttributes.set(key, value);\n    }\n  };\n  var minimizeAttributeChanges = (currPos, attributes) => {\n    while (true) {\n      if (currPos.right === null) {\n        break;\n      } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(\n        attributes[\n          /** @type {ContentFormat} */\n          currPos.right.content.key\n        ] ?? null,\n        /** @type {ContentFormat} */\n        currPos.right.content.value\n      )) ;\n      else {\n        break;\n      }\n      currPos.forward();\n    }\n  };\n  var insertAttributes = (transaction, parent, currPos, attributes) => {\n    const doc4 = transaction.doc;\n    const ownClientId = doc4.clientID;\n    const negatedAttributes = /* @__PURE__ */ new Map();\n    for (const key in attributes) {\n      const val = attributes[key];\n      const currentVal = currPos.currentAttributes.get(key) ?? null;\n      if (!equalAttrs(currentVal, val)) {\n        negatedAttributes.set(key, currentVal);\n        const { left, right } = currPos;\n        currPos.right = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));\n        currPos.right.integrate(transaction, 0);\n        currPos.forward();\n      }\n    }\n    return negatedAttributes;\n  };\n  var insertText = (transaction, parent, currPos, text2, attributes) => {\n    currPos.currentAttributes.forEach((_val, key) => {\n      if (attributes[key] === void 0) {\n        attributes[key] = null;\n      }\n    });\n    const doc4 = transaction.doc;\n    const ownClientId = doc4.clientID;\n    minimizeAttributeChanges(currPos, attributes);\n    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n    const content = text2.constructor === String ? new ContentString(\n      /** @type {string} */\n      text2\n    ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);\n    let { left, right, index } = currPos;\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());\n    }\n    right = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);\n    right.integrate(transaction, 0);\n    currPos.right = right;\n    currPos.index = index;\n    currPos.forward();\n    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n  };\n  var formatText = (transaction, parent, currPos, length4, attributes) => {\n    const doc4 = transaction.doc;\n    const ownClientId = doc4.clientID;\n    minimizeAttributeChanges(currPos, attributes);\n    const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);\n    iterationLoop: while (currPos.right !== null && (length4 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {\n      if (!currPos.right.deleted) {\n        switch (currPos.right.content.constructor) {\n          case ContentFormat: {\n            const { key, value } = (\n              /** @type {ContentFormat} */\n              currPos.right.content\n            );\n            const attr = attributes[key];\n            if (attr !== void 0) {\n              if (equalAttrs(attr, value)) {\n                negatedAttributes.delete(key);\n              } else {\n                if (length4 === 0) {\n                  break iterationLoop;\n                }\n                negatedAttributes.set(key, value);\n              }\n              currPos.right.delete(transaction);\n            } else {\n              currPos.currentAttributes.set(key, value);\n            }\n            break;\n          }\n          default:\n            if (length4 < currPos.right.length) {\n              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));\n            }\n            length4 -= currPos.right.length;\n            break;\n        }\n      }\n      currPos.forward();\n    }\n    if (length4 > 0) {\n      let newlines = \"\";\n      for (; length4 > 0; length4--) {\n        newlines += \"\\n\";\n      }\n      currPos.right = new Item2(createID(ownClientId, getState(doc4.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));\n      currPos.right.integrate(transaction, 0);\n      currPos.forward();\n    }\n    insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);\n  };\n  var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {\n    let end = start;\n    const endFormats = create();\n    while (end && (!end.countable || end.deleted)) {\n      if (!end.deleted && end.content.constructor === ContentFormat) {\n        const cf = (\n          /** @type {ContentFormat} */\n          end.content\n        );\n        endFormats.set(cf.key, cf);\n      }\n      end = end.right;\n    }\n    let cleanups = 0;\n    let reachedCurr = false;\n    while (start !== end) {\n      if (curr === start) {\n        reachedCurr = true;\n      }\n      if (!start.deleted) {\n        const content = start.content;\n        switch (content.constructor) {\n          case ContentFormat: {\n            const { key, value } = (\n              /** @type {ContentFormat} */\n              content\n            );\n            const startAttrValue = startAttributes.get(key) ?? null;\n            if (endFormats.get(key) !== content || startAttrValue === value) {\n              start.delete(transaction);\n              cleanups++;\n              if (!reachedCurr && (currAttributes.get(key) ?? null) === value && startAttrValue !== value) {\n                if (startAttrValue === null) {\n                  currAttributes.delete(key);\n                } else {\n                  currAttributes.set(key, startAttrValue);\n                }\n              }\n            }\n            if (!reachedCurr && !start.deleted) {\n              updateCurrentAttributes(\n                currAttributes,\n                /** @type {ContentFormat} */\n                content\n              );\n            }\n            break;\n          }\n        }\n      }\n      start = /** @type {Item} */\n      start.right;\n    }\n    return cleanups;\n  };\n  var cleanupContextlessFormattingGap = (transaction, item) => {\n    while (item && item.right && (item.right.deleted || !item.right.countable)) {\n      item = item.right;\n    }\n    const attrs = /* @__PURE__ */ new Set();\n    while (item && (item.deleted || !item.countable)) {\n      if (!item.deleted && item.content.constructor === ContentFormat) {\n        const key = (\n          /** @type {ContentFormat} */\n          item.content.key\n        );\n        if (attrs.has(key)) {\n          item.delete(transaction);\n        } else {\n          attrs.add(key);\n        }\n      }\n      item = item.left;\n    }\n  };\n  var cleanupYTextFormatting = (type) => {\n    let res = 0;\n    transact(\n      /** @type {Doc} */\n      type.doc,\n      (transaction) => {\n        let start = (\n          /** @type {Item} */\n          type._start\n        );\n        let end = type._start;\n        let startAttributes = create();\n        const currentAttributes = copy2(startAttributes);\n        while (end) {\n          if (end.deleted === false) {\n            switch (end.content.constructor) {\n              case ContentFormat:\n                updateCurrentAttributes(\n                  currentAttributes,\n                  /** @type {ContentFormat} */\n                  end.content\n                );\n                break;\n              default:\n                res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);\n                startAttributes = copy2(currentAttributes);\n                start = end;\n                break;\n            }\n          }\n          end = end.right;\n        }\n      }\n    );\n    return res;\n  };\n  var cleanupYTextAfterTransaction = (transaction) => {\n    const needFullCleanup = /* @__PURE__ */ new Set();\n    const doc4 = transaction.doc;\n    for (const [client, afterClock] of transaction.afterState.entries()) {\n      const clock = transaction.beforeState.get(client) || 0;\n      if (afterClock === clock) {\n        continue;\n      }\n      iterateStructs(\n        transaction,\n        /** @type {Array<Item|GC>} */\n        doc4.store.clients.get(client),\n        clock,\n        afterClock,\n        (item) => {\n          if (!item.deleted && /** @type {Item} */\n          item.content.constructor === ContentFormat && item.constructor !== GC) {\n            needFullCleanup.add(\n              /** @type {any} */\n              item.parent\n            );\n          }\n        }\n      );\n    }\n    transact(doc4, (t) => {\n      iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {\n        if (item instanceof GC || !/** @type {YText} */\n        item.parent._hasFormatting || needFullCleanup.has(\n          /** @type {YText} */\n          item.parent\n        )) {\n          return;\n        }\n        const parent = (\n          /** @type {YText} */\n          item.parent\n        );\n        if (item.content.constructor === ContentFormat) {\n          needFullCleanup.add(parent);\n        } else {\n          cleanupContextlessFormattingGap(t, item);\n        }\n      });\n      for (const yText of needFullCleanup) {\n        cleanupYTextFormatting(yText);\n      }\n    });\n  };\n  var deleteText = (transaction, currPos, length4) => {\n    const startLength = length4;\n    const startAttrs = copy2(currPos.currentAttributes);\n    const start = currPos.right;\n    while (length4 > 0 && currPos.right !== null) {\n      if (currPos.right.deleted === false) {\n        switch (currPos.right.content.constructor) {\n          case ContentType:\n          case ContentEmbed:\n          case ContentString:\n            if (length4 < currPos.right.length) {\n              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length4));\n            }\n            length4 -= currPos.right.length;\n            currPos.right.delete(transaction);\n            break;\n        }\n      }\n      currPos.forward();\n    }\n    if (start) {\n      cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);\n    }\n    const parent = (\n      /** @type {AbstractType<any>} */\n      /** @type {Item} */\n      (currPos.left || currPos.right).parent\n    );\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length4);\n    }\n    return currPos;\n  };\n  var YTextEvent = class extends YEvent {\n    /**\n     * @param {YText} ytext\n     * @param {Transaction} transaction\n     * @param {Set<any>} subs The keys that changed\n     */\n    constructor(ytext, transaction, subs) {\n      super(ytext, transaction);\n      this.childListChanged = false;\n      this.keysChanged = /* @__PURE__ */ new Set();\n      subs.forEach((sub) => {\n        if (sub === null) {\n          this.childListChanged = true;\n        } else {\n          this.keysChanged.add(sub);\n        }\n      });\n    }\n    /**\n     * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n     */\n    get changes() {\n      if (this._changes === null) {\n        const changes = {\n          keys: this.keys,\n          delta: this.delta,\n          added: /* @__PURE__ */ new Set(),\n          deleted: /* @__PURE__ */ new Set()\n        };\n        this._changes = changes;\n      }\n      return (\n        /** @type {any} */\n        this._changes\n      );\n    }\n    /**\n     * Compute the changes in the delta format.\n     * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n     *\n     * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n     *\n     * @public\n     */\n    get delta() {\n      if (this._delta === null) {\n        const y = (\n          /** @type {Doc} */\n          this.target.doc\n        );\n        const delta = [];\n        transact(y, (transaction) => {\n          const currentAttributes = /* @__PURE__ */ new Map();\n          const oldAttributes = /* @__PURE__ */ new Map();\n          let item = this.target._start;\n          let action = null;\n          const attributes = {};\n          let insert = \"\";\n          let retain = 0;\n          let deleteLen = 0;\n          const addOp = () => {\n            if (action !== null) {\n              let op = null;\n              switch (action) {\n                case \"delete\":\n                  if (deleteLen > 0) {\n                    op = { delete: deleteLen };\n                  }\n                  deleteLen = 0;\n                  break;\n                case \"insert\":\n                  if (typeof insert === \"object\" || insert.length > 0) {\n                    op = { insert };\n                    if (currentAttributes.size > 0) {\n                      op.attributes = {};\n                      currentAttributes.forEach((value, key) => {\n                        if (value !== null) {\n                          op.attributes[key] = value;\n                        }\n                      });\n                    }\n                  }\n                  insert = \"\";\n                  break;\n                case \"retain\":\n                  if (retain > 0) {\n                    op = { retain };\n                    if (!isEmpty(attributes)) {\n                      op.attributes = assign({}, attributes);\n                    }\n                  }\n                  retain = 0;\n                  break;\n              }\n              if (op) delta.push(op);\n              action = null;\n            }\n          };\n          while (item !== null) {\n            switch (item.content.constructor) {\n              case ContentType:\n              case ContentEmbed:\n                if (this.adds(item)) {\n                  if (!this.deletes(item)) {\n                    addOp();\n                    action = \"insert\";\n                    insert = item.content.getContent()[0];\n                    addOp();\n                  }\n                } else if (this.deletes(item)) {\n                  if (action !== \"delete\") {\n                    addOp();\n                    action = \"delete\";\n                  }\n                  deleteLen += 1;\n                } else if (!item.deleted) {\n                  if (action !== \"retain\") {\n                    addOp();\n                    action = \"retain\";\n                  }\n                  retain += 1;\n                }\n                break;\n              case ContentString:\n                if (this.adds(item)) {\n                  if (!this.deletes(item)) {\n                    if (action !== \"insert\") {\n                      addOp();\n                      action = \"insert\";\n                    }\n                    insert += /** @type {ContentString} */\n                    item.content.str;\n                  }\n                } else if (this.deletes(item)) {\n                  if (action !== \"delete\") {\n                    addOp();\n                    action = \"delete\";\n                  }\n                  deleteLen += item.length;\n                } else if (!item.deleted) {\n                  if (action !== \"retain\") {\n                    addOp();\n                    action = \"retain\";\n                  }\n                  retain += item.length;\n                }\n                break;\n              case ContentFormat: {\n                const { key, value } = (\n                  /** @type {ContentFormat} */\n                  item.content\n                );\n                if (this.adds(item)) {\n                  if (!this.deletes(item)) {\n                    const curVal = currentAttributes.get(key) ?? null;\n                    if (!equalAttrs(curVal, value)) {\n                      if (action === \"retain\") {\n                        addOp();\n                      }\n                      if (equalAttrs(value, oldAttributes.get(key) ?? null)) {\n                        delete attributes[key];\n                      } else {\n                        attributes[key] = value;\n                      }\n                    } else if (value !== null) {\n                      item.delete(transaction);\n                    }\n                  }\n                } else if (this.deletes(item)) {\n                  oldAttributes.set(key, value);\n                  const curVal = currentAttributes.get(key) ?? null;\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === \"retain\") {\n                      addOp();\n                    }\n                    attributes[key] = curVal;\n                  }\n                } else if (!item.deleted) {\n                  oldAttributes.set(key, value);\n                  const attr = attributes[key];\n                  if (attr !== void 0) {\n                    if (!equalAttrs(attr, value)) {\n                      if (action === \"retain\") {\n                        addOp();\n                      }\n                      if (value === null) {\n                        delete attributes[key];\n                      } else {\n                        attributes[key] = value;\n                      }\n                    } else if (attr !== null) {\n                      item.delete(transaction);\n                    }\n                  }\n                }\n                if (!item.deleted) {\n                  if (action === \"insert\") {\n                    addOp();\n                  }\n                  updateCurrentAttributes(\n                    currentAttributes,\n                    /** @type {ContentFormat} */\n                    item.content\n                  );\n                }\n                break;\n              }\n            }\n            item = item.right;\n          }\n          addOp();\n          while (delta.length > 0) {\n            const lastOp = delta[delta.length - 1];\n            if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {\n              delta.pop();\n            } else {\n              break;\n            }\n          }\n        });\n        this._delta = delta;\n      }\n      return (\n        /** @type {any} */\n        this._delta\n      );\n    }\n  };\n  var YText = class _YText extends AbstractType {\n    /**\n     * @param {String} [string] The initial value of the YText.\n     */\n    constructor(string) {\n      super();\n      this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];\n      this._searchMarker = [];\n      this._hasFormatting = false;\n    }\n    /**\n     * Number of characters of this text type.\n     *\n     * @type {number}\n     */\n    get length() {\n      this.doc ?? warnPrematureAccess();\n      return this._length;\n    }\n    /**\n     * @param {Doc} y\n     * @param {Item} item\n     */\n    _integrate(y, item) {\n      super._integrate(y, item);\n      try {\n        this._pending.forEach((f) => f());\n      } catch (e) {\n        console.error(e);\n      }\n      this._pending = null;\n    }\n    _copy() {\n      return new _YText();\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {YText}\n     */\n    clone() {\n      const text2 = new _YText();\n      text2.applyDelta(this.toDelta());\n      return text2;\n    }\n    /**\n     * Creates YTextEvent and calls observers.\n     *\n     * @param {Transaction} transaction\n     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n     */\n    _callObserver(transaction, parentSubs) {\n      super._callObserver(transaction, parentSubs);\n      const event = new YTextEvent(this, transaction, parentSubs);\n      callTypeObservers(this, transaction, event);\n      if (!transaction.local && this._hasFormatting) {\n        transaction._needFormattingCleanup = true;\n      }\n    }\n    /**\n     * Returns the unformatted string representation of this YText type.\n     *\n     * @public\n     */\n    toString() {\n      this.doc ?? warnPrematureAccess();\n      let str = \"\";\n      let n = this._start;\n      while (n !== null) {\n        if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n          str += /** @type {ContentString} */\n          n.content.str;\n        }\n        n = n.right;\n      }\n      return str;\n    }\n    /**\n     * Returns the unformatted string representation of this YText type.\n     *\n     * @return {string}\n     * @public\n     */\n    toJSON() {\n      return this.toString();\n    }\n    /**\n     * Apply a {@link Delta} on this shared YText type.\n     *\n     * @param {Array<any>} delta The changes to apply on this element.\n     * @param {object}  opts\n     * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n     *\n     *\n     * @public\n     */\n    applyDelta(delta, { sanitize = true } = {}) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());\n          for (let i = 0; i < delta.length; i++) {\n            const op = delta[i];\n            if (op.insert !== void 0) {\n              const ins = !sanitize && typeof op.insert === \"string\" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === \"\\n\" ? op.insert.slice(0, -1) : op.insert;\n              if (typeof ins !== \"string\" || ins.length > 0) {\n                insertText(transaction, this, currPos, ins, op.attributes || {});\n              }\n            } else if (op.retain !== void 0) {\n              formatText(transaction, this, currPos, op.retain, op.attributes || {});\n            } else if (op.delete !== void 0) {\n              deleteText(transaction, currPos, op.delete);\n            }\n          }\n        });\n      } else {\n        this._pending.push(() => this.applyDelta(delta));\n      }\n    }\n    /**\n     * Returns the Delta representation of this YText type.\n     *\n     * @param {Snapshot} [snapshot]\n     * @param {Snapshot} [prevSnapshot]\n     * @param {function('removed' | 'added', ID):any} [computeYChange]\n     * @return {any} The Delta representation of this type.\n     *\n     * @public\n     */\n    toDelta(snapshot2, prevSnapshot, computeYChange) {\n      this.doc ?? warnPrematureAccess();\n      const ops = [];\n      const currentAttributes = /* @__PURE__ */ new Map();\n      const doc4 = (\n        /** @type {Doc} */\n        this.doc\n      );\n      let str = \"\";\n      let n = this._start;\n      function packStr() {\n        if (str.length > 0) {\n          const attributes = {};\n          let addAttributes = false;\n          currentAttributes.forEach((value, key) => {\n            addAttributes = true;\n            attributes[key] = value;\n          });\n          const op = { insert: str };\n          if (addAttributes) {\n            op.attributes = attributes;\n          }\n          ops.push(op);\n          str = \"\";\n        }\n      }\n      const computeDelta = () => {\n        while (n !== null) {\n          if (isVisible(n, snapshot2) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {\n            switch (n.content.constructor) {\n              case ContentString: {\n                const cur = currentAttributes.get(\"ychange\");\n                if (snapshot2 !== void 0 && !isVisible(n, snapshot2)) {\n                  if (cur === void 0 || cur.user !== n.id.client || cur.type !== \"removed\") {\n                    packStr();\n                    currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"removed\", n.id) : { type: \"removed\" });\n                  }\n                } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {\n                  if (cur === void 0 || cur.user !== n.id.client || cur.type !== \"added\") {\n                    packStr();\n                    currentAttributes.set(\"ychange\", computeYChange ? computeYChange(\"added\", n.id) : { type: \"added\" });\n                  }\n                } else if (cur !== void 0) {\n                  packStr();\n                  currentAttributes.delete(\"ychange\");\n                }\n                str += /** @type {ContentString} */\n                n.content.str;\n                break;\n              }\n              case ContentType:\n              case ContentEmbed: {\n                packStr();\n                const op = {\n                  insert: n.content.getContent()[0]\n                };\n                if (currentAttributes.size > 0) {\n                  const attrs = (\n                    /** @type {Object<string,any>} */\n                    {}\n                  );\n                  op.attributes = attrs;\n                  currentAttributes.forEach((value, key) => {\n                    attrs[key] = value;\n                  });\n                }\n                ops.push(op);\n                break;\n              }\n              case ContentFormat:\n                if (isVisible(n, snapshot2)) {\n                  packStr();\n                  updateCurrentAttributes(\n                    currentAttributes,\n                    /** @type {ContentFormat} */\n                    n.content\n                  );\n                }\n                break;\n            }\n          }\n          n = n.right;\n        }\n        packStr();\n      };\n      if (snapshot2 || prevSnapshot) {\n        transact(doc4, (transaction) => {\n          if (snapshot2) {\n            splitSnapshotAffectedStructs(transaction, snapshot2);\n          }\n          if (prevSnapshot) {\n            splitSnapshotAffectedStructs(transaction, prevSnapshot);\n          }\n          computeDelta();\n        }, \"cleanup\");\n      } else {\n        computeDelta();\n      }\n      return ops;\n    }\n    /**\n     * Insert text at a given index.\n     *\n     * @param {number} index The index at which to start inserting.\n     * @param {String} text The text to insert at the specified position.\n     * @param {TextAttributes} [attributes] Optionally define some formatting\n     *                                    information to apply on the inserted\n     *                                    Text.\n     * @public\n     */\n    insert(index, text2, attributes) {\n      if (text2.length <= 0) {\n        return;\n      }\n      const y = this.doc;\n      if (y !== null) {\n        transact(y, (transaction) => {\n          const pos = findPosition(transaction, this, index, !attributes);\n          if (!attributes) {\n            attributes = {};\n            pos.currentAttributes.forEach((v, k) => {\n              attributes[k] = v;\n            });\n          }\n          insertText(transaction, this, pos, text2, attributes);\n        });\n      } else {\n        this._pending.push(() => this.insert(index, text2, attributes));\n      }\n    }\n    /**\n     * Inserts an embed at a index.\n     *\n     * @param {number} index The index to insert the embed at.\n     * @param {Object | AbstractType<any>} embed The Object that represents the embed.\n     * @param {TextAttributes} [attributes] Attribute information to apply on the\n     *                                    embed\n     *\n     * @public\n     */\n    insertEmbed(index, embed, attributes) {\n      const y = this.doc;\n      if (y !== null) {\n        transact(y, (transaction) => {\n          const pos = findPosition(transaction, this, index, !attributes);\n          insertText(transaction, this, pos, embed, attributes || {});\n        });\n      } else {\n        this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));\n      }\n    }\n    /**\n     * Deletes text starting from an index.\n     *\n     * @param {number} index Index at which to start deleting.\n     * @param {number} length The number of characters to remove. Defaults to 1.\n     *\n     * @public\n     */\n    delete(index, length4) {\n      if (length4 === 0) {\n        return;\n      }\n      const y = this.doc;\n      if (y !== null) {\n        transact(y, (transaction) => {\n          deleteText(transaction, findPosition(transaction, this, index, true), length4);\n        });\n      } else {\n        this._pending.push(() => this.delete(index, length4));\n      }\n    }\n    /**\n     * Assigns properties to a range of text.\n     *\n     * @param {number} index The position where to start formatting.\n     * @param {number} length The amount of characters to assign properties to.\n     * @param {TextAttributes} attributes Attribute information to apply on the\n     *                                    text.\n     *\n     * @public\n     */\n    format(index, length4, attributes) {\n      if (length4 === 0) {\n        return;\n      }\n      const y = this.doc;\n      if (y !== null) {\n        transact(y, (transaction) => {\n          const pos = findPosition(transaction, this, index, false);\n          if (pos.right === null) {\n            return;\n          }\n          formatText(transaction, this, pos, length4, attributes);\n        });\n      } else {\n        this._pending.push(() => this.format(index, length4, attributes));\n      }\n    }\n    /**\n     * Removes an attribute.\n     *\n     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n     *\n     * @param {String} attributeName The attribute name that is to be removed.\n     *\n     * @public\n     */\n    removeAttribute(attributeName) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeMapDelete(transaction, this, attributeName);\n        });\n      } else {\n        this._pending.push(() => this.removeAttribute(attributeName));\n      }\n    }\n    /**\n     * Sets or updates an attribute.\n     *\n     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n     *\n     * @param {String} attributeName The attribute name that is to be set.\n     * @param {any} attributeValue The attribute value that is to be set.\n     *\n     * @public\n     */\n    setAttribute(attributeName, attributeValue) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeMapSet(transaction, this, attributeName, attributeValue);\n        });\n      } else {\n        this._pending.push(() => this.setAttribute(attributeName, attributeValue));\n      }\n    }\n    /**\n     * Returns an attribute value that belongs to the attribute name.\n     *\n     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n     *\n     * @param {String} attributeName The attribute name that identifies the\n     *                               queried value.\n     * @return {any} The queried attribute value.\n     *\n     * @public\n     */\n    getAttribute(attributeName) {\n      return (\n        /** @type {any} */\n        typeMapGet(this, attributeName)\n      );\n    }\n    /**\n     * Returns all attribute name/value pairs in a JSON Object.\n     *\n     * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n     *\n     * @return {Object<string, any>} A JSON Object that describes the attributes.\n     *\n     * @public\n     */\n    getAttributes() {\n      return typeMapGetAll(this);\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     */\n    _write(encoder) {\n      encoder.writeTypeRef(YTextRefID);\n    }\n  };\n  var readYText = (_decoder) => new YText();\n  var YXmlTreeWalker = class {\n    /**\n     * @param {YXmlFragment | YXmlElement} root\n     * @param {function(AbstractType<any>):boolean} [f]\n     */\n    constructor(root, f = () => true) {\n      this._filter = f;\n      this._root = root;\n      this._currentNode = /** @type {Item} */\n      root._start;\n      this._firstCall = true;\n      root.doc ?? warnPrematureAccess();\n    }\n    [Symbol.iterator]() {\n      return this;\n    }\n    /**\n     * Get the next node.\n     *\n     * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n     *\n     * @public\n     */\n    next() {\n      let n = this._currentNode;\n      let type = n && n.content && /** @type {any} */\n      n.content.type;\n      if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {\n        do {\n          type = /** @type {any} */\n          n.content.type;\n          if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n            n = type._start;\n          } else {\n            while (n !== null) {\n              const nxt = n.next;\n              if (nxt !== null) {\n                n = nxt;\n                break;\n              } else if (n.parent === this._root) {\n                n = null;\n              } else {\n                n = /** @type {AbstractType<any>} */\n                n.parent._item;\n              }\n            }\n          }\n        } while (n !== null && (n.deleted || !this._filter(\n          /** @type {ContentType} */\n          n.content.type\n        )));\n      }\n      this._firstCall = false;\n      if (n === null) {\n        return { value: void 0, done: true };\n      }\n      this._currentNode = n;\n      return { value: (\n        /** @type {any} */\n        n.content.type\n      ), done: false };\n    }\n  };\n  var YXmlFragment = class _YXmlFragment extends AbstractType {\n    constructor() {\n      super();\n      this._prelimContent = [];\n    }\n    /**\n     * @type {YXmlElement|YXmlText|null}\n     */\n    get firstChild() {\n      const first = this._first;\n      return first ? first.content.getContent()[0] : null;\n    }\n    /**\n     * Integrate this type into the Yjs instance.\n     *\n     * * Save this struct in the os\n     * * This type is sent to other client\n     * * Observer functions are fired\n     *\n     * @param {Doc} y The Yjs instance\n     * @param {Item} item\n     */\n    _integrate(y, item) {\n      super._integrate(y, item);\n      this.insert(\n        0,\n        /** @type {Array<any>} */\n        this._prelimContent\n      );\n      this._prelimContent = null;\n    }\n    _copy() {\n      return new _YXmlFragment();\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {YXmlFragment}\n     */\n    clone() {\n      const el = new _YXmlFragment();\n      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));\n      return el;\n    }\n    get length() {\n      this.doc ?? warnPrematureAccess();\n      return this._prelimContent === null ? this._length : this._prelimContent.length;\n    }\n    /**\n     * Create a subtree of childNodes.\n     *\n     * @example\n     * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n     * for (let node in walker) {\n     *   // `node` is a div node\n     *   nop(node)\n     * }\n     *\n     * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n     *                          returns a Boolean indicating whether the child\n     *                          is to be included in the subtree.\n     * @return {YXmlTreeWalker} A subtree and a position within it.\n     *\n     * @public\n     */\n    createTreeWalker(filter) {\n      return new YXmlTreeWalker(this, filter);\n    }\n    /**\n     * Returns the first YXmlElement that matches the query.\n     * Similar to DOM's {@link querySelector}.\n     *\n     * Query support:\n     *   - tagname\n     * TODO:\n     *   - id\n     *   - attribute\n     *\n     * @param {CSS_Selector} query The query on the children.\n     * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n     *\n     * @public\n     */\n    querySelector(query) {\n      query = query.toUpperCase();\n      const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);\n      const next = iterator.next();\n      if (next.done) {\n        return null;\n      } else {\n        return next.value;\n      }\n    }\n    /**\n     * Returns all YXmlElements that match the query.\n     * Similar to Dom's {@link querySelectorAll}.\n     *\n     * @todo Does not yet support all queries. Currently only query by tagName.\n     *\n     * @param {CSS_Selector} query The query on the children\n     * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n     *\n     * @public\n     */\n    querySelectorAll(query) {\n      query = query.toUpperCase();\n      return from2(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));\n    }\n    /**\n     * Creates YXmlEvent and calls observers.\n     *\n     * @param {Transaction} transaction\n     * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n     */\n    _callObserver(transaction, parentSubs) {\n      callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));\n    }\n    /**\n     * Get the string representation of all the children of this YXmlFragment.\n     *\n     * @return {string} The string representation of all children.\n     */\n    toString() {\n      return typeListMap(this, (xml) => xml.toString()).join(\"\");\n    }\n    /**\n     * @return {string}\n     */\n    toJSON() {\n      return this.toString();\n    }\n    /**\n     * Creates a Dom Element that mirrors this YXmlElement.\n     *\n     * @param {Document} [_document=document] The document object (you must define\n     *                                        this when calling this method in\n     *                                        nodejs)\n     * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n     *                                             are presented in the DOM\n     * @param {any} [binding] You should not set this property. This is\n     *                               used if DomBinding wants to create a\n     *                               association to the created DOM type.\n     * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n     *\n     * @public\n     */\n    toDOM(_document = document, hooks = {}, binding) {\n      const fragment = _document.createDocumentFragment();\n      if (binding !== void 0) {\n        binding._createAssociation(fragment, this);\n      }\n      typeListForEach(this, (xmlType) => {\n        fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);\n      });\n      return fragment;\n    }\n    /**\n     * Inserts new content at an index.\n     *\n     * @example\n     *  // Insert character 'a' at position 0\n     *  xml.insert(0, [new Y.XmlText('text')])\n     *\n     * @param {number} index The index to insert content at\n     * @param {Array<YXmlElement|YXmlText>} content The array of content\n     */\n    insert(index, content) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeListInsertGenerics(transaction, this, index, content);\n        });\n      } else {\n        this._prelimContent.splice(index, 0, ...content);\n      }\n    }\n    /**\n     * Inserts new content at an index.\n     *\n     * @example\n     *  // Insert character 'a' at position 0\n     *  xml.insert(0, [new Y.XmlText('text')])\n     *\n     * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n     * @param {Array<YXmlElement|YXmlText>} content The array of content\n     */\n    insertAfter(ref, content) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          const refItem = ref && ref instanceof AbstractType ? ref._item : ref;\n          typeListInsertGenericsAfter(transaction, this, refItem, content);\n        });\n      } else {\n        const pc = (\n          /** @type {Array<any>} */\n          this._prelimContent\n        );\n        const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;\n        if (index === 0 && ref !== null) {\n          throw create3(\"Reference item not found\");\n        }\n        pc.splice(index, 0, ...content);\n      }\n    }\n    /**\n     * Deletes elements starting from an index.\n     *\n     * @param {number} index Index at which to start deleting elements\n     * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n     */\n    delete(index, length4 = 1) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeListDelete(transaction, this, index, length4);\n        });\n      } else {\n        this._prelimContent.splice(index, length4);\n      }\n    }\n    /**\n     * Transforms this YArray to a JavaScript Array.\n     *\n     * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n     */\n    toArray() {\n      return typeListToArray(this);\n    }\n    /**\n     * Appends content to this YArray.\n     *\n     * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n     */\n    push(content) {\n      this.insert(this.length, content);\n    }\n    /**\n     * Prepends content to this YArray.\n     *\n     * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.\n     */\n    unshift(content) {\n      this.insert(0, content);\n    }\n    /**\n     * Returns the i-th element from a YArray.\n     *\n     * @param {number} index The index of the element to return from the YArray\n     * @return {YXmlElement|YXmlText}\n     */\n    get(index) {\n      return typeListGet(this, index);\n    }\n    /**\n     * Returns a portion of this YXmlFragment into a JavaScript Array selected\n     * from start to end (end not included).\n     *\n     * @param {number} [start]\n     * @param {number} [end]\n     * @return {Array<YXmlElement|YXmlText>}\n     */\n    slice(start = 0, end = this.length) {\n      return typeListSlice(this, start, end);\n    }\n    /**\n     * Executes a provided function on once on every child element.\n     *\n     * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.\n     */\n    forEach(f) {\n      typeListForEach(this, f);\n    }\n    /**\n     * Transform the properties of this type to binary and write it to an\n     * BinaryEncoder.\n     *\n     * This is called when this Item is sent to a remote peer.\n     *\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n     */\n    _write(encoder) {\n      encoder.writeTypeRef(YXmlFragmentRefID);\n    }\n  };\n  var readYXmlFragment = (_decoder) => new YXmlFragment();\n  var YXmlElement = class _YXmlElement extends YXmlFragment {\n    constructor(nodeName = \"UNDEFINED\") {\n      super();\n      this.nodeName = nodeName;\n      this._prelimAttrs = /* @__PURE__ */ new Map();\n    }\n    /**\n     * @type {YXmlElement|YXmlText|null}\n     */\n    get nextSibling() {\n      const n = this._item ? this._item.next : null;\n      return n ? (\n        /** @type {YXmlElement|YXmlText} */\n        /** @type {ContentType} */\n        n.content.type\n      ) : null;\n    }\n    /**\n     * @type {YXmlElement|YXmlText|null}\n     */\n    get prevSibling() {\n      const n = this._item ? this._item.prev : null;\n      return n ? (\n        /** @type {YXmlElement|YXmlText} */\n        /** @type {ContentType} */\n        n.content.type\n      ) : null;\n    }\n    /**\n     * Integrate this type into the Yjs instance.\n     *\n     * * Save this struct in the os\n     * * This type is sent to other client\n     * * Observer functions are fired\n     *\n     * @param {Doc} y The Yjs instance\n     * @param {Item} item\n     */\n    _integrate(y, item) {\n      super._integrate(y, item);\n      /** @type {Map<string, any>} */\n      this._prelimAttrs.forEach((value, key) => {\n        this.setAttribute(key, value);\n      });\n      this._prelimAttrs = null;\n    }\n    /**\n     * Creates an Item with the same effect as this Item (without position effect)\n     *\n     * @return {YXmlElement}\n     */\n    _copy() {\n      return new _YXmlElement(this.nodeName);\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {YXmlElement<KV>}\n     */\n    clone() {\n      const el = new _YXmlElement(this.nodeName);\n      const attrs = this.getAttributes();\n      forEach2(attrs, (value, key) => {\n        if (typeof value === \"string\") {\n          el.setAttribute(key, value);\n        }\n      });\n      el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));\n      return el;\n    }\n    /**\n     * Returns the XML serialization of this YXmlElement.\n     * The attributes are ordered by attribute-name, so you can easily use this\n     * method to compare YXmlElements\n     *\n     * @return {string} The string representation of this type.\n     *\n     * @public\n     */\n    toString() {\n      const attrs = this.getAttributes();\n      const stringBuilder = [];\n      const keys4 = [];\n      for (const key in attrs) {\n        keys4.push(key);\n      }\n      keys4.sort();\n      const keysLen = keys4.length;\n      for (let i = 0; i < keysLen; i++) {\n        const key = keys4[i];\n        stringBuilder.push(key + '=\"' + attrs[key] + '\"');\n      }\n      const nodeName = this.nodeName.toLocaleLowerCase();\n      const attrsString = stringBuilder.length > 0 ? \" \" + stringBuilder.join(\" \") : \"\";\n      return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;\n    }\n    /**\n     * Removes an attribute from this YXmlElement.\n     *\n     * @param {string} attributeName The attribute name that is to be removed.\n     *\n     * @public\n     */\n    removeAttribute(attributeName) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeMapDelete(transaction, this, attributeName);\n        });\n      } else {\n        this._prelimAttrs.delete(attributeName);\n      }\n    }\n    /**\n     * Sets or updates an attribute.\n     *\n     * @template {keyof KV & string} KEY\n     *\n     * @param {KEY} attributeName The attribute name that is to be set.\n     * @param {KV[KEY]} attributeValue The attribute value that is to be set.\n     *\n     * @public\n     */\n    setAttribute(attributeName, attributeValue) {\n      if (this.doc !== null) {\n        transact(this.doc, (transaction) => {\n          typeMapSet(transaction, this, attributeName, attributeValue);\n        });\n      } else {\n        this._prelimAttrs.set(attributeName, attributeValue);\n      }\n    }\n    /**\n     * Returns an attribute value that belongs to the attribute name.\n     *\n     * @template {keyof KV & string} KEY\n     *\n     * @param {KEY} attributeName The attribute name that identifies the\n     *                               queried value.\n     * @return {KV[KEY]|undefined} The queried attribute value.\n     *\n     * @public\n     */\n    getAttribute(attributeName) {\n      return (\n        /** @type {any} */\n        typeMapGet(this, attributeName)\n      );\n    }\n    /**\n     * Returns whether an attribute exists\n     *\n     * @param {string} attributeName The attribute name to check for existence.\n     * @return {boolean} whether the attribute exists.\n     *\n     * @public\n     */\n    hasAttribute(attributeName) {\n      return (\n        /** @type {any} */\n        typeMapHas(this, attributeName)\n      );\n    }\n    /**\n     * Returns all attribute name/value pairs in a JSON Object.\n     *\n     * @param {Snapshot} [snapshot]\n     * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.\n     *\n     * @public\n     */\n    getAttributes(snapshot2) {\n      return (\n        /** @type {any} */\n        snapshot2 ? typeMapGetAllSnapshot(this, snapshot2) : typeMapGetAll(this)\n      );\n    }\n    /**\n     * Creates a Dom Element that mirrors this YXmlElement.\n     *\n     * @param {Document} [_document=document] The document object (you must define\n     *                                        this when calling this method in\n     *                                        nodejs)\n     * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n     *                                             are presented in the DOM\n     * @param {any} [binding] You should not set this property. This is\n     *                               used if DomBinding wants to create a\n     *                               association to the created DOM type.\n     * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n     *\n     * @public\n     */\n    toDOM(_document = document, hooks = {}, binding) {\n      const dom = _document.createElement(this.nodeName);\n      const attrs = this.getAttributes();\n      for (const key in attrs) {\n        const value = attrs[key];\n        if (typeof value === \"string\") {\n          dom.setAttribute(key, value);\n        }\n      }\n      typeListForEach(this, (yxml) => {\n        dom.appendChild(yxml.toDOM(_document, hooks, binding));\n      });\n      if (binding !== void 0) {\n        binding._createAssociation(dom, this);\n      }\n      return dom;\n    }\n    /**\n     * Transform the properties of this type to binary and write it to an\n     * BinaryEncoder.\n     *\n     * This is called when this Item is sent to a remote peer.\n     *\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n     */\n    _write(encoder) {\n      encoder.writeTypeRef(YXmlElementRefID);\n      encoder.writeKey(this.nodeName);\n    }\n  };\n  var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());\n  var YXmlEvent = class extends YEvent {\n    /**\n     * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n     * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n     *                   child list changed.\n     * @param {Transaction} transaction The transaction instance with which the\n     *                                  change was created.\n     */\n    constructor(target, subs, transaction) {\n      super(target, transaction);\n      this.childListChanged = false;\n      this.attributesChanged = /* @__PURE__ */ new Set();\n      subs.forEach((sub) => {\n        if (sub === null) {\n          this.childListChanged = true;\n        } else {\n          this.attributesChanged.add(sub);\n        }\n      });\n    }\n  };\n  var YXmlHook = class _YXmlHook extends YMap {\n    /**\n     * @param {string} hookName nodeName of the Dom Node.\n     */\n    constructor(hookName) {\n      super();\n      this.hookName = hookName;\n    }\n    /**\n     * Creates an Item with the same effect as this Item (without position effect)\n     */\n    _copy() {\n      return new _YXmlHook(this.hookName);\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {YXmlHook}\n     */\n    clone() {\n      const el = new _YXmlHook(this.hookName);\n      this.forEach((value, key) => {\n        el.set(key, value);\n      });\n      return el;\n    }\n    /**\n     * Creates a Dom Element that mirrors this YXmlElement.\n     *\n     * @param {Document} [_document=document] The document object (you must define\n     *                                        this when calling this method in\n     *                                        nodejs)\n     * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n     *                                             are presented in the DOM\n     * @param {any} [binding] You should not set this property. This is\n     *                               used if DomBinding wants to create a\n     *                               association to the created DOM type\n     * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n     *\n     * @public\n     */\n    toDOM(_document = document, hooks = {}, binding) {\n      const hook = hooks[this.hookName];\n      let dom;\n      if (hook !== void 0) {\n        dom = hook.createDom(this);\n      } else {\n        dom = document.createElement(this.hookName);\n      }\n      dom.setAttribute(\"data-yjs-hook\", this.hookName);\n      if (binding !== void 0) {\n        binding._createAssociation(dom, this);\n      }\n      return dom;\n    }\n    /**\n     * Transform the properties of this type to binary and write it to an\n     * BinaryEncoder.\n     *\n     * This is called when this Item is sent to a remote peer.\n     *\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n     */\n    _write(encoder) {\n      encoder.writeTypeRef(YXmlHookRefID);\n      encoder.writeKey(this.hookName);\n    }\n  };\n  var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());\n  var YXmlText = class _YXmlText extends YText {\n    /**\n     * @type {YXmlElement|YXmlText|null}\n     */\n    get nextSibling() {\n      const n = this._item ? this._item.next : null;\n      return n ? (\n        /** @type {YXmlElement|YXmlText} */\n        /** @type {ContentType} */\n        n.content.type\n      ) : null;\n    }\n    /**\n     * @type {YXmlElement|YXmlText|null}\n     */\n    get prevSibling() {\n      const n = this._item ? this._item.prev : null;\n      return n ? (\n        /** @type {YXmlElement|YXmlText} */\n        /** @type {ContentType} */\n        n.content.type\n      ) : null;\n    }\n    _copy() {\n      return new _YXmlText();\n    }\n    /**\n     * Makes a copy of this data type that can be included somewhere else.\n     *\n     * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.\n     *\n     * @return {YXmlText}\n     */\n    clone() {\n      const text2 = new _YXmlText();\n      text2.applyDelta(this.toDelta());\n      return text2;\n    }\n    /**\n     * Creates a Dom Element that mirrors this YXmlText.\n     *\n     * @param {Document} [_document=document] The document object (you must define\n     *                                        this when calling this method in\n     *                                        nodejs)\n     * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n     *                                             are presented in the DOM\n     * @param {any} [binding] You should not set this property. This is\n     *                               used if DomBinding wants to create a\n     *                               association to the created DOM type.\n     * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n     *\n     * @public\n     */\n    toDOM(_document = document, hooks, binding) {\n      const dom = _document.createTextNode(this.toString());\n      if (binding !== void 0) {\n        binding._createAssociation(dom, this);\n      }\n      return dom;\n    }\n    toString() {\n      return this.toDelta().map((delta) => {\n        const nestedNodes = [];\n        for (const nodeName in delta.attributes) {\n          const attrs = [];\n          for (const key in delta.attributes[nodeName]) {\n            attrs.push({ key, value: delta.attributes[nodeName][key] });\n          }\n          attrs.sort((a, b) => a.key < b.key ? -1 : 1);\n          nestedNodes.push({ nodeName, attrs });\n        }\n        nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);\n        let str = \"\";\n        for (let i = 0; i < nestedNodes.length; i++) {\n          const node = nestedNodes[i];\n          str += `<${node.nodeName}`;\n          for (let j = 0; j < node.attrs.length; j++) {\n            const attr = node.attrs[j];\n            str += ` ${attr.key}=\"${attr.value}\"`;\n          }\n          str += \">\";\n        }\n        str += delta.insert;\n        for (let i = nestedNodes.length - 1; i >= 0; i--) {\n          str += `</${nestedNodes[i].nodeName}>`;\n        }\n        return str;\n      }).join(\"\");\n    }\n    /**\n     * @return {string}\n     */\n    toJSON() {\n      return this.toString();\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     */\n    _write(encoder) {\n      encoder.writeTypeRef(YXmlTextRefID);\n    }\n  };\n  var readYXmlText = (decoder) => new YXmlText();\n  var AbstractStruct = class {\n    /**\n     * @param {ID} id\n     * @param {number} length\n     */\n    constructor(id2, length4) {\n      this.id = id2;\n      this.length = length4;\n    }\n    /**\n     * @type {boolean}\n     */\n    get deleted() {\n      throw methodUnimplemented();\n    }\n    /**\n     * Merge this struct with the item to the right.\n     * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n     * Also this method does *not* remove right from StructStore!\n     * @param {AbstractStruct} right\n     * @return {boolean} whether this merged with right\n     */\n    mergeWith(right) {\n      return false;\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n     * @param {number} offset\n     * @param {number} encodingRef\n     */\n    write(encoder, offset, encodingRef) {\n      throw methodUnimplemented();\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {number} offset\n     */\n    integrate(transaction, offset) {\n      throw methodUnimplemented();\n    }\n  };\n  var structGCRefNumber = 0;\n  var GC = class extends AbstractStruct {\n    get deleted() {\n      return true;\n    }\n    delete() {\n    }\n    /**\n     * @param {GC} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      if (this.constructor !== right.constructor) {\n        return false;\n      }\n      this.length += right.length;\n      return true;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {number} offset\n     */\n    integrate(transaction, offset) {\n      if (offset > 0) {\n        this.id.clock += offset;\n        this.length -= offset;\n      }\n      addStruct(transaction.doc.store, this);\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeInfo(structGCRefNumber);\n      encoder.writeLen(this.length - offset);\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {StructStore} store\n     * @return {null | number}\n     */\n    getMissing(transaction, store) {\n      return null;\n    }\n  };\n  var ContentBinary = class _ContentBinary {\n    /**\n     * @param {Uint8Array} content\n     */\n    constructor(content) {\n      this.content = content;\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return 1;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return [this.content];\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return true;\n    }\n    /**\n     * @return {ContentBinary}\n     */\n    copy() {\n      return new _ContentBinary(this.content);\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentBinary}\n     */\n    splice(offset) {\n      throw methodUnimplemented();\n    }\n    /**\n     * @param {ContentBinary} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      return false;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeBuf(this.content);\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 3;\n    }\n  };\n  var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());\n  var ContentDeleted = class _ContentDeleted {\n    /**\n     * @param {number} len\n     */\n    constructor(len) {\n      this.len = len;\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return this.len;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return [];\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return false;\n    }\n    /**\n     * @return {ContentDeleted}\n     */\n    copy() {\n      return new _ContentDeleted(this.len);\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentDeleted}\n     */\n    splice(offset) {\n      const right = new _ContentDeleted(this.len - offset);\n      this.len = offset;\n      return right;\n    }\n    /**\n     * @param {ContentDeleted} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      this.len += right.len;\n      return true;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n      addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);\n      item.markDeleted();\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeLen(this.len - offset);\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 1;\n    }\n  };\n  var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());\n  var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });\n  var ContentDoc = class _ContentDoc {\n    /**\n     * @param {Doc} doc\n     */\n    constructor(doc4) {\n      if (doc4._item) {\n        console.error(\"This document was already integrated as a sub-document. You should create a second instance instead with the same guid.\");\n      }\n      this.doc = doc4;\n      const opts = {};\n      this.opts = opts;\n      if (!doc4.gc) {\n        opts.gc = false;\n      }\n      if (doc4.autoLoad) {\n        opts.autoLoad = true;\n      }\n      if (doc4.meta !== null) {\n        opts.meta = doc4.meta;\n      }\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return 1;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return [this.doc];\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return true;\n    }\n    /**\n     * @return {ContentDoc}\n     */\n    copy() {\n      return new _ContentDoc(createDocFromOpts(this.doc.guid, this.opts));\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentDoc}\n     */\n    splice(offset) {\n      throw methodUnimplemented();\n    }\n    /**\n     * @param {ContentDoc} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      return false;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n      this.doc._item = item;\n      transaction.subdocsAdded.add(this.doc);\n      if (this.doc.shouldLoad) {\n        transaction.subdocsLoaded.add(this.doc);\n      }\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n      if (transaction.subdocsAdded.has(this.doc)) {\n        transaction.subdocsAdded.delete(this.doc);\n      } else {\n        transaction.subdocsRemoved.add(this.doc);\n      }\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeString(this.doc.guid);\n      encoder.writeAny(this.opts);\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 9;\n    }\n  };\n  var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));\n  var ContentEmbed = class _ContentEmbed {\n    /**\n     * @param {Object} embed\n     */\n    constructor(embed) {\n      this.embed = embed;\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return 1;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return [this.embed];\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return true;\n    }\n    /**\n     * @return {ContentEmbed}\n     */\n    copy() {\n      return new _ContentEmbed(this.embed);\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentEmbed}\n     */\n    splice(offset) {\n      throw methodUnimplemented();\n    }\n    /**\n     * @param {ContentEmbed} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      return false;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeJSON(this.embed);\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 5;\n    }\n  };\n  var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());\n  var ContentFormat = class _ContentFormat {\n    /**\n     * @param {string} key\n     * @param {Object} value\n     */\n    constructor(key, value) {\n      this.key = key;\n      this.value = value;\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return 1;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return [];\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return false;\n    }\n    /**\n     * @return {ContentFormat}\n     */\n    copy() {\n      return new _ContentFormat(this.key, this.value);\n    }\n    /**\n     * @param {number} _offset\n     * @return {ContentFormat}\n     */\n    splice(_offset) {\n      throw methodUnimplemented();\n    }\n    /**\n     * @param {ContentFormat} _right\n     * @return {boolean}\n     */\n    mergeWith(_right) {\n      return false;\n    }\n    /**\n     * @param {Transaction} _transaction\n     * @param {Item} item\n     */\n    integrate(_transaction, item) {\n      const p = (\n        /** @type {YText} */\n        item.parent\n      );\n      p._searchMarker = null;\n      p._hasFormatting = true;\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeKey(this.key);\n      encoder.writeJSON(this.value);\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 6;\n    }\n  };\n  var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());\n  var ContentJSON = class _ContentJSON {\n    /**\n     * @param {Array<any>} arr\n     */\n    constructor(arr) {\n      this.arr = arr;\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return this.arr.length;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return this.arr;\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return true;\n    }\n    /**\n     * @return {ContentJSON}\n     */\n    copy() {\n      return new _ContentJSON(this.arr);\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentJSON}\n     */\n    splice(offset) {\n      const right = new _ContentJSON(this.arr.slice(offset));\n      this.arr = this.arr.slice(0, offset);\n      return right;\n    }\n    /**\n     * @param {ContentJSON} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      this.arr = this.arr.concat(right.arr);\n      return true;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      const len = this.arr.length;\n      encoder.writeLen(len - offset);\n      for (let i = offset; i < len; i++) {\n        const c = this.arr[i];\n        encoder.writeString(c === void 0 ? \"undefined\" : JSON.stringify(c));\n      }\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 2;\n    }\n  };\n  var readContentJSON = (decoder) => {\n    const len = decoder.readLen();\n    const cs = [];\n    for (let i = 0; i < len; i++) {\n      const c = decoder.readString();\n      if (c === \"undefined\") {\n        cs.push(void 0);\n      } else {\n        cs.push(JSON.parse(c));\n      }\n    }\n    return new ContentJSON(cs);\n  };\n  var isDevMode = getVariable(\"node_env\") === \"development\";\n  var ContentAny = class _ContentAny {\n    /**\n     * @param {Array<any>} arr\n     */\n    constructor(arr) {\n      this.arr = arr;\n      isDevMode && deepFreeze(arr);\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return this.arr.length;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return this.arr;\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return true;\n    }\n    /**\n     * @return {ContentAny}\n     */\n    copy() {\n      return new _ContentAny(this.arr);\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentAny}\n     */\n    splice(offset) {\n      const right = new _ContentAny(this.arr.slice(offset));\n      this.arr = this.arr.slice(0, offset);\n      return right;\n    }\n    /**\n     * @param {ContentAny} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      this.arr = this.arr.concat(right.arr);\n      return true;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      const len = this.arr.length;\n      encoder.writeLen(len - offset);\n      for (let i = offset; i < len; i++) {\n        const c = this.arr[i];\n        encoder.writeAny(c);\n      }\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 8;\n    }\n  };\n  var readContentAny = (decoder) => {\n    const len = decoder.readLen();\n    const cs = [];\n    for (let i = 0; i < len; i++) {\n      cs.push(decoder.readAny());\n    }\n    return new ContentAny(cs);\n  };\n  var ContentString = class _ContentString {\n    /**\n     * @param {string} str\n     */\n    constructor(str) {\n      this.str = str;\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return this.str.length;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return this.str.split(\"\");\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return true;\n    }\n    /**\n     * @return {ContentString}\n     */\n    copy() {\n      return new _ContentString(this.str);\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentString}\n     */\n    splice(offset) {\n      const right = new _ContentString(this.str.slice(offset));\n      this.str = this.str.slice(0, offset);\n      const firstCharCode = this.str.charCodeAt(offset - 1);\n      if (firstCharCode >= 55296 && firstCharCode <= 56319) {\n        this.str = this.str.slice(0, offset - 1) + \"\\uFFFD\";\n        right.str = \"\\uFFFD\" + right.str.slice(1);\n      }\n      return right;\n    }\n    /**\n     * @param {ContentString} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      this.str += right.str;\n      return true;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 4;\n    }\n  };\n  var readContentString = (decoder) => new ContentString(decoder.readString());\n  var typeRefs = [\n    readYArray,\n    readYMap,\n    readYText,\n    readYXmlElement,\n    readYXmlFragment,\n    readYXmlHook,\n    readYXmlText\n  ];\n  var YArrayRefID = 0;\n  var YMapRefID = 1;\n  var YTextRefID = 2;\n  var YXmlElementRefID = 3;\n  var YXmlFragmentRefID = 4;\n  var YXmlHookRefID = 5;\n  var YXmlTextRefID = 6;\n  var ContentType = class _ContentType {\n    /**\n     * @param {AbstractType<any>} type\n     */\n    constructor(type) {\n      this.type = type;\n    }\n    /**\n     * @return {number}\n     */\n    getLength() {\n      return 1;\n    }\n    /**\n     * @return {Array<any>}\n     */\n    getContent() {\n      return [this.type];\n    }\n    /**\n     * @return {boolean}\n     */\n    isCountable() {\n      return true;\n    }\n    /**\n     * @return {ContentType}\n     */\n    copy() {\n      return new _ContentType(this.type._copy());\n    }\n    /**\n     * @param {number} offset\n     * @return {ContentType}\n     */\n    splice(offset) {\n      throw methodUnimplemented();\n    }\n    /**\n     * @param {ContentType} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      return false;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {Item} item\n     */\n    integrate(transaction, item) {\n      this.type._integrate(transaction.doc, item);\n    }\n    /**\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n      let item = this.type._start;\n      while (item !== null) {\n        if (!item.deleted) {\n          item.delete(transaction);\n        } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {\n          transaction._mergeStructs.push(item);\n        }\n        item = item.right;\n      }\n      this.type._map.forEach((item2) => {\n        if (!item2.deleted) {\n          item2.delete(transaction);\n        } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {\n          transaction._mergeStructs.push(item2);\n        }\n      });\n      transaction.changed.delete(this.type);\n    }\n    /**\n     * @param {StructStore} store\n     */\n    gc(store) {\n      let item = this.type._start;\n      while (item !== null) {\n        item.gc(store, true);\n        item = item.right;\n      }\n      this.type._start = null;\n      this.type._map.forEach(\n        /** @param {Item | null} item */\n        (item2) => {\n          while (item2 !== null) {\n            item2.gc(store, true);\n            item2 = item2.left;\n          }\n        }\n      );\n      this.type._map = /* @__PURE__ */ new Map();\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      this.type._write(encoder);\n    }\n    /**\n     * @return {number}\n     */\n    getRef() {\n      return 7;\n    }\n  };\n  var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));\n  var followRedone = (store, id2) => {\n    let nextID = id2;\n    let diff = 0;\n    let item;\n    do {\n      if (diff > 0) {\n        nextID = createID(nextID.client, nextID.clock + diff);\n      }\n      item = getItem(store, nextID);\n      diff = nextID.clock - item.id.clock;\n      nextID = item.redone;\n    } while (nextID !== null && item instanceof Item2);\n    return {\n      item,\n      diff\n    };\n  };\n  var keepItem = (item, keep) => {\n    while (item !== null && item.keep !== keep) {\n      item.keep = keep;\n      item = /** @type {AbstractType<any>} */\n      item.parent._item;\n    }\n  };\n  var splitItem = (transaction, leftItem, diff) => {\n    const { client, clock } = leftItem.id;\n    const rightItem = new Item2(\n      createID(client, clock + diff),\n      leftItem,\n      createID(client, clock + diff - 1),\n      leftItem.right,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    );\n    if (leftItem.deleted) {\n      rightItem.markDeleted();\n    }\n    if (leftItem.keep) {\n      rightItem.keep = true;\n    }\n    if (leftItem.redone !== null) {\n      rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);\n    }\n    leftItem.right = rightItem;\n    if (rightItem.right !== null) {\n      rightItem.right.left = rightItem;\n    }\n    transaction._mergeStructs.push(rightItem);\n    if (rightItem.parentSub !== null && rightItem.right === null) {\n      rightItem.parent._map.set(rightItem.parentSub, rightItem);\n    }\n    leftItem.length = diff;\n    return rightItem;\n  };\n  var isDeletedByUndoStack = (stack, id2) => some(\n    stack,\n    /** @param {StackItem} s */\n    (s) => isDeleted(s.deletions, id2)\n  );\n  var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {\n    const doc4 = transaction.doc;\n    const store = doc4.store;\n    const ownClientID = doc4.clientID;\n    const redone = item.redone;\n    if (redone !== null) {\n      return getItemCleanStart(transaction, redone);\n    }\n    let parentItem = (\n      /** @type {AbstractType<any>} */\n      item.parent._item\n    );\n    let left = null;\n    let right;\n    if (parentItem !== null && parentItem.deleted === true) {\n      if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {\n        return null;\n      }\n      while (parentItem.redone !== null) {\n        parentItem = getItemCleanStart(transaction, parentItem.redone);\n      }\n    }\n    const parentType = parentItem === null ? (\n      /** @type {AbstractType<any>} */\n      item.parent\n    ) : (\n      /** @type {ContentType} */\n      parentItem.content.type\n    );\n    if (item.parentSub === null) {\n      left = item.left;\n      right = item;\n      while (left !== null) {\n        let leftTrace = left;\n        while (leftTrace !== null && /** @type {AbstractType<any>} */\n        leftTrace.parent._item !== parentItem) {\n          leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);\n        }\n        if (leftTrace !== null && /** @type {AbstractType<any>} */\n        leftTrace.parent._item === parentItem) {\n          left = leftTrace;\n          break;\n        }\n        left = left.left;\n      }\n      while (right !== null) {\n        let rightTrace = right;\n        while (rightTrace !== null && /** @type {AbstractType<any>} */\n        rightTrace.parent._item !== parentItem) {\n          rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);\n        }\n        if (rightTrace !== null && /** @type {AbstractType<any>} */\n        rightTrace.parent._item === parentItem) {\n          right = rightTrace;\n          break;\n        }\n        right = right.right;\n      }\n    } else {\n      right = null;\n      if (item.right && !ignoreRemoteMapChanges) {\n        left = item;\n        while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {\n          left = left.right;\n          while (left.redone) left = getItemCleanStart(transaction, left.redone);\n        }\n        if (left && left.right !== null) {\n          return null;\n        }\n      } else {\n        left = parentType._map.get(item.parentSub) || null;\n      }\n    }\n    const nextClock = getState(store, ownClientID);\n    const nextId = createID(ownClientID, nextClock);\n    const redoneItem = new Item2(\n      nextId,\n      left,\n      left && left.lastId,\n      right,\n      right && right.id,\n      parentType,\n      item.parentSub,\n      item.content.copy()\n    );\n    item.redone = nextId;\n    keepItem(redoneItem, true);\n    redoneItem.integrate(transaction, 0);\n    return redoneItem;\n  };\n  var Item2 = class _Item extends AbstractStruct {\n    /**\n     * @param {ID} id\n     * @param {Item | null} left\n     * @param {ID | null} origin\n     * @param {Item | null} right\n     * @param {ID | null} rightOrigin\n     * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n     * @param {string | null} parentSub\n     * @param {AbstractContent} content\n     */\n    constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {\n      super(id2, content.getLength());\n      this.origin = origin;\n      this.left = left;\n      this.right = right;\n      this.rightOrigin = rightOrigin;\n      this.parent = parent;\n      this.parentSub = parentSub;\n      this.redone = null;\n      this.content = content;\n      this.info = this.content.isCountable() ? BIT2 : 0;\n    }\n    /**\n     * This is used to mark the item as an indexed fast-search marker\n     *\n     * @type {boolean}\n     */\n    set marker(isMarked) {\n      if ((this.info & BIT4) > 0 !== isMarked) {\n        this.info ^= BIT4;\n      }\n    }\n    get marker() {\n      return (this.info & BIT4) > 0;\n    }\n    /**\n     * If true, do not garbage collect this Item.\n     */\n    get keep() {\n      return (this.info & BIT1) > 0;\n    }\n    set keep(doKeep) {\n      if (this.keep !== doKeep) {\n        this.info ^= BIT1;\n      }\n    }\n    get countable() {\n      return (this.info & BIT2) > 0;\n    }\n    /**\n     * Whether this item was deleted or not.\n     * @type {Boolean}\n     */\n    get deleted() {\n      return (this.info & BIT3) > 0;\n    }\n    set deleted(doDelete) {\n      if (this.deleted !== doDelete) {\n        this.info ^= BIT3;\n      }\n    }\n    markDeleted() {\n      this.info |= BIT3;\n    }\n    /**\n     * Return the creator clientID of the missing op or define missing items and return null.\n     *\n     * @param {Transaction} transaction\n     * @param {StructStore} store\n     * @return {null | number}\n     */\n    getMissing(transaction, store) {\n      if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n        return this.origin.client;\n      }\n      if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n        return this.rightOrigin.client;\n      }\n      if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n        return this.parent.client;\n      }\n      if (this.origin) {\n        this.left = getItemCleanEnd(transaction, store, this.origin);\n        this.origin = this.left.lastId;\n      }\n      if (this.rightOrigin) {\n        this.right = getItemCleanStart(transaction, this.rightOrigin);\n        this.rightOrigin = this.right.id;\n      }\n      if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {\n        this.parent = null;\n      } else if (!this.parent) {\n        if (this.left && this.left.constructor === _Item) {\n          this.parent = this.left.parent;\n          this.parentSub = this.left.parentSub;\n        } else if (this.right && this.right.constructor === _Item) {\n          this.parent = this.right.parent;\n          this.parentSub = this.right.parentSub;\n        }\n      } else if (this.parent.constructor === ID) {\n        const parentItem = getItem(store, this.parent);\n        if (parentItem.constructor === GC) {\n          this.parent = null;\n        } else {\n          this.parent = /** @type {ContentType} */\n          parentItem.content.type;\n        }\n      }\n      return null;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {number} offset\n     */\n    integrate(transaction, offset) {\n      if (offset > 0) {\n        this.id.clock += offset;\n        this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));\n        this.origin = this.left.lastId;\n        this.content = this.content.splice(offset);\n        this.length -= offset;\n      }\n      if (this.parent) {\n        if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {\n          let left = this.left;\n          let o;\n          if (left !== null) {\n            o = left.right;\n          } else if (this.parentSub !== null) {\n            o = /** @type {AbstractType<any>} */\n            this.parent._map.get(this.parentSub) || null;\n            while (o !== null && o.left !== null) {\n              o = o.left;\n            }\n          } else {\n            o = /** @type {AbstractType<any>} */\n            this.parent._start;\n          }\n          const conflictingItems = /* @__PURE__ */ new Set();\n          const itemsBeforeOrigin = /* @__PURE__ */ new Set();\n          while (o !== null && o !== this.right) {\n            itemsBeforeOrigin.add(o);\n            conflictingItems.add(o);\n            if (compareIDs(this.origin, o.origin)) {\n              if (o.id.client < this.id.client) {\n                left = o;\n                conflictingItems.clear();\n              } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n                break;\n              }\n            } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {\n              if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n                left = o;\n                conflictingItems.clear();\n              }\n            } else {\n              break;\n            }\n            o = o.right;\n          }\n          this.left = left;\n        }\n        if (this.left !== null) {\n          const right = this.left.right;\n          this.right = right;\n          this.left.right = this;\n        } else {\n          let r;\n          if (this.parentSub !== null) {\n            r = /** @type {AbstractType<any>} */\n            this.parent._map.get(this.parentSub) || null;\n            while (r !== null && r.left !== null) {\n              r = r.left;\n            }\n          } else {\n            r = /** @type {AbstractType<any>} */\n            this.parent._start;\n            this.parent._start = this;\n          }\n          this.right = r;\n        }\n        if (this.right !== null) {\n          this.right.left = this;\n        } else if (this.parentSub !== null) {\n          this.parent._map.set(this.parentSub, this);\n          if (this.left !== null) {\n            this.left.delete(transaction);\n          }\n        }\n        if (this.parentSub === null && this.countable && !this.deleted) {\n          this.parent._length += this.length;\n        }\n        addStruct(transaction.doc.store, this);\n        this.content.integrate(transaction, this);\n        addChangedTypeToTransaction(\n          transaction,\n          /** @type {AbstractType<any>} */\n          this.parent,\n          this.parentSub\n        );\n        if (\n          /** @type {AbstractType<any>} */\n          this.parent._item !== null && /** @type {AbstractType<any>} */\n          this.parent._item.deleted || this.parentSub !== null && this.right !== null\n        ) {\n          this.delete(transaction);\n        }\n      } else {\n        new GC(this.id, this.length).integrate(transaction, 0);\n      }\n    }\n    /**\n     * Returns the next non-deleted item\n     */\n    get next() {\n      let n = this.right;\n      while (n !== null && n.deleted) {\n        n = n.right;\n      }\n      return n;\n    }\n    /**\n     * Returns the previous non-deleted item\n     */\n    get prev() {\n      let n = this.left;\n      while (n !== null && n.deleted) {\n        n = n.left;\n      }\n      return n;\n    }\n    /**\n     * Computes the last content address of this Item.\n     */\n    get lastId() {\n      return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);\n    }\n    /**\n     * Try to merge two items\n     *\n     * @param {Item} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {\n        const searchMarker = (\n          /** @type {AbstractType<any>} */\n          this.parent._searchMarker\n        );\n        if (searchMarker) {\n          searchMarker.forEach((marker) => {\n            if (marker.p === right) {\n              marker.p = this;\n              if (!this.deleted && this.countable) {\n                marker.index -= this.length;\n              }\n            }\n          });\n        }\n        if (right.keep) {\n          this.keep = true;\n        }\n        this.right = right.right;\n        if (this.right !== null) {\n          this.right.left = this;\n        }\n        this.length += right.length;\n        return true;\n      }\n      return false;\n    }\n    /**\n     * Mark this Item as deleted.\n     *\n     * @param {Transaction} transaction\n     */\n    delete(transaction) {\n      if (!this.deleted) {\n        const parent = (\n          /** @type {AbstractType<any>} */\n          this.parent\n        );\n        if (this.countable && this.parentSub === null) {\n          parent._length -= this.length;\n        }\n        this.markDeleted();\n        addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);\n        addChangedTypeToTransaction(transaction, parent, this.parentSub);\n        this.content.delete(transaction);\n      }\n    }\n    /**\n     * @param {StructStore} store\n     * @param {boolean} parentGCd\n     */\n    gc(store, parentGCd) {\n      if (!this.deleted) {\n        throw unexpectedCase();\n      }\n      this.content.gc(store);\n      if (parentGCd) {\n        replaceStruct(store, this, new GC(this.id, this.length));\n      } else {\n        this.content = new ContentDeleted(this.length);\n      }\n    }\n    /**\n     * Transform the properties of this type to binary and write it to an\n     * BinaryEncoder.\n     *\n     * This is called when this Item is sent to a remote peer.\n     *\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;\n      const rightOrigin = this.rightOrigin;\n      const parentSub = this.parentSub;\n      const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : BIT7) | // right origin is defined\n      (parentSub === null ? 0 : BIT6);\n      encoder.writeInfo(info);\n      if (origin !== null) {\n        encoder.writeLeftID(origin);\n      }\n      if (rightOrigin !== null) {\n        encoder.writeRightID(rightOrigin);\n      }\n      if (origin === null && rightOrigin === null) {\n        const parent = (\n          /** @type {AbstractType<any>} */\n          this.parent\n        );\n        if (parent._item !== void 0) {\n          const parentItem = parent._item;\n          if (parentItem === null) {\n            const ykey = findRootTypeKey(parent);\n            encoder.writeParentInfo(true);\n            encoder.writeString(ykey);\n          } else {\n            encoder.writeParentInfo(false);\n            encoder.writeLeftID(parentItem.id);\n          }\n        } else if (parent.constructor === String) {\n          encoder.writeParentInfo(true);\n          encoder.writeString(parent);\n        } else if (parent.constructor === ID) {\n          encoder.writeParentInfo(false);\n          encoder.writeLeftID(parent);\n        } else {\n          unexpectedCase();\n        }\n        if (parentSub !== null) {\n          encoder.writeString(parentSub);\n        }\n      }\n      this.content.write(encoder, offset);\n    }\n  };\n  var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);\n  var contentRefs = [\n    () => {\n      unexpectedCase();\n    },\n    // GC is not ItemContent\n    readContentDeleted,\n    // 1\n    readContentJSON,\n    // 2\n    readContentBinary,\n    // 3\n    readContentString,\n    // 4\n    readContentEmbed,\n    // 5\n    readContentFormat,\n    // 6\n    readContentType,\n    // 7\n    readContentAny,\n    // 8\n    readContentDoc,\n    // 9\n    () => {\n      unexpectedCase();\n    }\n    // 10 - Skip is not ItemContent\n  ];\n  var structSkipRefNumber = 10;\n  var Skip = class extends AbstractStruct {\n    get deleted() {\n      return true;\n    }\n    delete() {\n    }\n    /**\n     * @param {Skip} right\n     * @return {boolean}\n     */\n    mergeWith(right) {\n      if (this.constructor !== right.constructor) {\n        return false;\n      }\n      this.length += right.length;\n      return true;\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {number} offset\n     */\n    integrate(transaction, offset) {\n      unexpectedCase();\n    }\n    /**\n     * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n     * @param {number} offset\n     */\n    write(encoder, offset) {\n      encoder.writeInfo(structSkipRefNumber);\n      writeVarUint(encoder.restEncoder, this.length - offset);\n    }\n    /**\n     * @param {Transaction} transaction\n     * @param {StructStore} store\n     * @return {null | number}\n     */\n    getMissing(transaction, store) {\n      return null;\n    }\n  };\n  var glo = (\n    /** @type {any} */\n    typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : {}\n  );\n  var importIdentifier = \"__ $YJS$ __\";\n  if (glo[importIdentifier] === true) {\n    console.error(\"Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438\");\n  }\n  glo[importIdentifier] = true;\n\n  // node_modules/y-protocols/awareness.js\n  var awareness_exports = {};\n  __export(awareness_exports, {\n    Awareness: () => Awareness,\n    applyAwarenessUpdate: () => applyAwarenessUpdate,\n    encodeAwarenessUpdate: () => encodeAwarenessUpdate,\n    modifyAwarenessUpdate: () => modifyAwarenessUpdate,\n    outdatedTimeout: () => outdatedTimeout,\n    removeAwarenessStates: () => removeAwarenessStates\n  });\n  var outdatedTimeout = 3e4;\n  var Awareness = class extends Observable {\n    /**\n     * @param {Y.Doc} doc\n     */\n    constructor(doc4) {\n      super();\n      this.doc = doc4;\n      this.clientID = doc4.clientID;\n      this.states = /* @__PURE__ */ new Map();\n      this.meta = /* @__PURE__ */ new Map();\n      this._checkInterval = /** @type {any} */\n      setInterval(() => {\n        const now = getUnixTime();\n        if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */\n        this.meta.get(this.clientID).lastUpdated) {\n          this.setLocalState(this.getLocalState());\n        }\n        const remove = [];\n        this.meta.forEach((meta, clientid) => {\n          if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {\n            remove.push(clientid);\n          }\n        });\n        if (remove.length > 0) {\n          removeAwarenessStates(this, remove, \"timeout\");\n        }\n      }, floor(outdatedTimeout / 10));\n      doc4.on(\"destroy\", () => {\n        this.destroy();\n      });\n      this.setLocalState({});\n    }\n    destroy() {\n      this.emit(\"destroy\", [this]);\n      this.setLocalState(null);\n      super.destroy();\n      clearInterval(this._checkInterval);\n    }\n    /**\n     * @return {Object<string,any>|null}\n     */\n    getLocalState() {\n      return this.states.get(this.clientID) || null;\n    }\n    /**\n     * @param {Object<string,any>|null} state\n     */\n    setLocalState(state) {\n      const clientID = this.clientID;\n      const currLocalMeta = this.meta.get(clientID);\n      const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;\n      const prevState = this.states.get(clientID);\n      if (state === null) {\n        this.states.delete(clientID);\n      } else {\n        this.states.set(clientID, state);\n      }\n      this.meta.set(clientID, {\n        clock,\n        lastUpdated: getUnixTime()\n      });\n      const added = [];\n      const updated = [];\n      const filteredUpdated = [];\n      const removed = [];\n      if (state === null) {\n        removed.push(clientID);\n      } else if (prevState == null) {\n        if (state != null) {\n          added.push(clientID);\n        }\n      } else {\n        updated.push(clientID);\n        if (!equalityDeep(prevState, state)) {\n          filteredUpdated.push(clientID);\n        }\n      }\n      if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n        this.emit(\"change\", [{ added, updated: filteredUpdated, removed }, \"local\"]);\n      }\n      this.emit(\"update\", [{ added, updated, removed }, \"local\"]);\n    }\n    /**\n     * @param {string} field\n     * @param {any} value\n     */\n    setLocalStateField(field, value) {\n      const state = this.getLocalState();\n      if (state !== null) {\n        this.setLocalState({\n          ...state,\n          [field]: value\n        });\n      }\n    }\n    /**\n     * @return {Map<number,Object<string,any>>}\n     */\n    getStates() {\n      return this.states;\n    }\n  };\n  var removeAwarenessStates = (awareness, clients, origin) => {\n    const removed = [];\n    for (let i = 0; i < clients.length; i++) {\n      const clientID = clients[i];\n      if (awareness.states.has(clientID)) {\n        awareness.states.delete(clientID);\n        if (clientID === awareness.clientID) {\n          const curMeta = (\n            /** @type {MetaClientState} */\n            awareness.meta.get(clientID)\n          );\n          awareness.meta.set(clientID, {\n            clock: curMeta.clock + 1,\n            lastUpdated: getUnixTime()\n          });\n        }\n        removed.push(clientID);\n      }\n    }\n    if (removed.length > 0) {\n      awareness.emit(\"change\", [{ added: [], updated: [], removed }, origin]);\n      awareness.emit(\"update\", [{ added: [], updated: [], removed }, origin]);\n    }\n  };\n  var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {\n    const len = clients.length;\n    const encoder = createEncoder();\n    writeVarUint(encoder, len);\n    for (let i = 0; i < len; i++) {\n      const clientID = clients[i];\n      const state = states.get(clientID) || null;\n      const clock = (\n        /** @type {MetaClientState} */\n        awareness.meta.get(clientID).clock\n      );\n      writeVarUint(encoder, clientID);\n      writeVarUint(encoder, clock);\n      writeVarString(encoder, JSON.stringify(state));\n    }\n    return toUint8Array(encoder);\n  };\n  var modifyAwarenessUpdate = (update, modify) => {\n    const decoder = createDecoder(update);\n    const encoder = createEncoder();\n    const len = readVarUint(decoder);\n    writeVarUint(encoder, len);\n    for (let i = 0; i < len; i++) {\n      const clientID = readVarUint(decoder);\n      const clock = readVarUint(decoder);\n      const state = JSON.parse(readVarString(decoder));\n      const modifiedState = modify(state);\n      writeVarUint(encoder, clientID);\n      writeVarUint(encoder, clock);\n      writeVarString(encoder, JSON.stringify(modifiedState));\n    }\n    return toUint8Array(encoder);\n  };\n  var applyAwarenessUpdate = (awareness, update, origin) => {\n    const decoder = createDecoder(update);\n    const timestamp = getUnixTime();\n    const added = [];\n    const updated = [];\n    const filteredUpdated = [];\n    const removed = [];\n    const len = readVarUint(decoder);\n    for (let i = 0; i < len; i++) {\n      const clientID = readVarUint(decoder);\n      let clock = readVarUint(decoder);\n      const state = JSON.parse(readVarString(decoder));\n      const clientMeta = awareness.meta.get(clientID);\n      const prevState = awareness.states.get(clientID);\n      const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;\n      if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {\n        if (state === null) {\n          if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n            clock++;\n          } else {\n            awareness.states.delete(clientID);\n          }\n        } else {\n          awareness.states.set(clientID, state);\n        }\n        awareness.meta.set(clientID, {\n          clock,\n          lastUpdated: timestamp\n        });\n        if (clientMeta === void 0 && state !== null) {\n          added.push(clientID);\n        } else if (clientMeta !== void 0 && state === null) {\n          removed.push(clientID);\n        } else if (state !== null) {\n          if (!equalityDeep(state, prevState)) {\n            filteredUpdated.push(clientID);\n          }\n          updated.push(clientID);\n        }\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      awareness.emit(\"change\", [{\n        added,\n        updated: filteredUpdated,\n        removed\n      }, origin]);\n    }\n    if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n      awareness.emit(\"update\", [{\n        added,\n        updated,\n        removed\n      }, origin]);\n    }\n  };\n\n  // node_modules/lib0/mutex.js\n  var createMutex = () => {\n    let token = true;\n    return (f, g) => {\n      if (token) {\n        token = false;\n        try {\n          f();\n        } finally {\n          token = true;\n        }\n      } else if (g !== void 0) {\n        g();\n      }\n    };\n  };\n\n  // node_modules/lib0/diff.js\n  var highSurrogateRegex = /[\\uD800-\\uDBFF]/;\n  var lowSurrogateRegex = /[\\uDC00-\\uDFFF]/;\n  var simpleDiffString = (a, b) => {\n    let left = 0;\n    let right = 0;\n    while (left < a.length && left < b.length && a[left] === b[left]) {\n      left++;\n    }\n    if (left > 0 && highSurrogateRegex.test(a[left - 1])) left--;\n    while (right + left < a.length && right + left < b.length && a[a.length - right - 1] === b[b.length - right - 1]) {\n      right++;\n    }\n    if (right > 0 && lowSurrogateRegex.test(a[a.length - right])) right--;\n    return {\n      index: left,\n      remove: a.length - left - right,\n      insert: b.slice(left, b.length - right)\n    };\n  };\n  var simpleDiff = simpleDiffString;\n\n  // node_modules/y-prosemirror/src/plugins/keys.js\n  var ySyncPluginKey = new PluginKey(\"y-sync\");\n  var yUndoPluginKey = new PluginKey(\"y-undo\");\n  var yCursorPluginKey = new PluginKey(\"yjs-cursor\");\n\n  // node_modules/lib0/hash/sha256.js\n  var rotr = (w, shift2) => w >>> shift2 | w << 32 - shift2;\n  var sum0to256 = (x) => rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);\n  var sum1to256 = (x) => rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);\n  var sigma0to256 = (x) => rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;\n  var sigma1to256 = (x) => rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;\n  var K = new Uint32Array([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  var HINIT = new Uint32Array([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n  ]);\n  var Hasher = class {\n    constructor() {\n      const buf = new ArrayBuffer(64 + 64 * 4);\n      this._H = new Uint32Array(buf, 0, 8);\n      this._H.set(HINIT);\n      this._W = new Uint32Array(buf, 64, 64);\n    }\n    _updateHash() {\n      const H = this._H;\n      const W = this._W;\n      for (let t = 16; t < 64; t++) {\n        W[t] = sigma1to256(W[t - 2]) + W[t - 7] + sigma0to256(W[t - 15]) + W[t - 16];\n      }\n      let a = H[0];\n      let b = H[1];\n      let c = H[2];\n      let d = H[3];\n      let e = H[4];\n      let f = H[5];\n      let g = H[6];\n      let h = H[7];\n      for (let tt = 0, T1, T2; tt < 64; tt++) {\n        T1 = h + sum1to256(e) + (e & f ^ ~e & g) + K[tt] + W[tt] >>> 0;\n        T2 = sum0to256(a) + (a & b ^ a & c ^ b & c) >>> 0;\n        h = g;\n        g = f;\n        f = e;\n        e = d + T1 >>> 0;\n        d = c;\n        c = b;\n        b = a;\n        a = T1 + T2 >>> 0;\n      }\n      H[0] += a;\n      H[1] += b;\n      H[2] += c;\n      H[3] += d;\n      H[4] += e;\n      H[5] += f;\n      H[6] += g;\n      H[7] += h;\n    }\n    /**\n     * Returns a 32-byte hash.\n     *\n     * @param {Uint8Array} data\n     */\n    digest(data) {\n      let i = 0;\n      for (; i + 56 <= data.length; ) {\n        let j2 = 0;\n        for (; j2 < 16 && i + 3 < data.length; j2++) {\n          this._W[j2] = data[i++] << 24 | data[i++] << 16 | data[i++] << 8 | data[i++];\n        }\n        if (i % 64 !== 0) {\n          this._W.fill(0, j2, 16);\n          while (i < data.length) {\n            this._W[j2] |= data[i] << (3 - i % 4) * 8;\n            i++;\n          }\n          this._W[j2] |= BIT8 << (3 - i % 4) * 8;\n        }\n        this._updateHash();\n      }\n      const isPaddedWith1 = i % 64 !== 0;\n      this._W.fill(0, 0, 16);\n      let j = 0;\n      for (; i < data.length; j++) {\n        for (let ci = 3; ci >= 0 && i < data.length; ci--) {\n          this._W[j] |= data[i++] << ci * 8;\n        }\n      }\n      if (!isPaddedWith1) {\n        this._W[j - (i % 4 === 0 ? 0 : 1)] |= BIT8 << (3 - i % 4) * 8;\n      }\n      this._W[14] = data.byteLength / BIT30;\n      this._W[15] = data.byteLength * 8;\n      this._updateHash();\n      const dv = new Uint8Array(32);\n      for (let i2 = 0; i2 < this._H.length; i2++) {\n        for (let ci = 0; ci < 4; ci++) {\n          dv[i2 * 4 + ci] = this._H[i2] >>> (3 - ci) * 8;\n        }\n      }\n      return dv;\n    }\n  };\n  var digest = (data) => new Hasher().digest(data);\n\n  // node_modules/y-prosemirror/src/utils.js\n  var _convolute = (digest2) => {\n    const N = 6;\n    for (let i = N; i < digest2.length; i++) {\n      digest2[i % N] = digest2[i % N] ^ digest2[i];\n    }\n    return digest2.slice(0, N);\n  };\n  var hashOfJSON = (json) => toBase64(_convolute(digest(encodeAny(json))));\n\n  // node_modules/y-prosemirror/src/plugins/sync-plugin.js\n  var isVisible2 = (item, snapshot2) => snapshot2 === void 0 ? !item.deleted : snapshot2.sv.has(item.id.client) && /** @type {number} */\n  snapshot2.sv.get(item.id.client) > item.id.clock && !isDeleted(snapshot2.ds, item.id);\n  var defaultColors = [{ light: \"#ecd44433\", dark: \"#ecd444\" }];\n  var getUserColor = (colorMapping, colors, user) => {\n    if (!colorMapping.has(user)) {\n      if (colorMapping.size < colors.length) {\n        const usedColors = create2();\n        colorMapping.forEach((color) => usedColors.add(color));\n        colors = colors.filter((color) => !usedColors.has(color));\n      }\n      colorMapping.set(user, oneOf(colors));\n    }\n    return (\n      /** @type {ColorDef} */\n      colorMapping.get(user)\n    );\n  };\n  var ySyncPlugin = (yXmlFragment, {\n    colors = defaultColors,\n    colorMapping = /* @__PURE__ */ new Map(),\n    permanentUserData = null,\n    onFirstRender = () => {\n    },\n    mapping\n  } = {}) => {\n    let initialContentChanged = false;\n    const binding = new ProsemirrorBinding(yXmlFragment, mapping);\n    const plugin = new Plugin({\n      props: {\n        editable: (state) => {\n          const syncState = ySyncPluginKey.getState(state);\n          return syncState.snapshot == null && syncState.prevSnapshot == null;\n        }\n      },\n      key: ySyncPluginKey,\n      state: {\n        /**\n         * @returns {any}\n         */\n        init: (_initargs, _state) => {\n          return {\n            type: yXmlFragment,\n            doc: yXmlFragment.doc,\n            binding,\n            snapshot: null,\n            prevSnapshot: null,\n            isChangeOrigin: false,\n            isUndoRedoOperation: false,\n            addToHistory: true,\n            colors,\n            colorMapping,\n            permanentUserData\n          };\n        },\n        apply: (tr, pluginState) => {\n          const change = tr.getMeta(ySyncPluginKey);\n          if (change !== void 0) {\n            pluginState = Object.assign({}, pluginState);\n            for (const key in change) {\n              pluginState[key] = change[key];\n            }\n          }\n          pluginState.addToHistory = tr.getMeta(\"addToHistory\") !== false;\n          pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;\n          pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;\n          if (binding.prosemirrorView !== null) {\n            if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {\n              timeout(0, () => {\n                if (binding.prosemirrorView == null) {\n                  return;\n                }\n                if (change.restore == null) {\n                  binding._renderSnapshot(\n                    change.snapshot,\n                    change.prevSnapshot,\n                    pluginState\n                  );\n                } else {\n                  binding._renderSnapshot(\n                    change.snapshot,\n                    change.snapshot,\n                    pluginState\n                  );\n                  delete pluginState.restore;\n                  delete pluginState.snapshot;\n                  delete pluginState.prevSnapshot;\n                  binding.mux(() => {\n                    binding._prosemirrorChanged(\n                      binding.prosemirrorView.state.doc\n                    );\n                  });\n                }\n              });\n            }\n          }\n          return pluginState;\n        }\n      },\n      view: (view) => {\n        binding.initView(view);\n        if (mapping == null) {\n          binding._forceRerender();\n        }\n        onFirstRender();\n        return {\n          update: () => {\n            const pluginState = plugin.getState(view.state);\n            if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {\n              if (\n                // If the content doesn't change initially, we don't render anything to Yjs\n                // If the content was cleared by a user action, we want to catch the change and\n                // represent it in Yjs\n                initialContentChanged || view.state.doc.content.findDiffStart(\n                  view.state.doc.type.createAndFill().content\n                ) !== null\n              ) {\n                initialContentChanged = true;\n                if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {\n                  const yUndoPluginState = yUndoPluginKey.getState(view.state);\n                  const um = yUndoPluginState && yUndoPluginState.undoManager;\n                  if (um) {\n                    um.stopCapturing();\n                  }\n                }\n                binding.mux(() => {\n                  pluginState.doc.transact((tr) => {\n                    tr.meta.set(\"addToHistory\", pluginState.addToHistory);\n                    binding._prosemirrorChanged(view.state.doc);\n                  }, ySyncPluginKey);\n                });\n              }\n            }\n          },\n          destroy: () => {\n            binding.destroy();\n          }\n        };\n      }\n    });\n    return plugin;\n  };\n  var restoreRelativeSelection = (tr, relSel, binding) => {\n    if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n      if (relSel.type === \"all\") {\n        tr.setSelection(new AllSelection(tr.doc));\n      } else if (relSel.type === \"node\") {\n        const anchor = relativePositionToAbsolutePosition(\n          binding.doc,\n          binding.type,\n          relSel.anchor,\n          binding.mapping\n        );\n        tr.setSelection(NodeSelection.create(tr.doc, anchor));\n      } else {\n        const anchor = relativePositionToAbsolutePosition(\n          binding.doc,\n          binding.type,\n          relSel.anchor,\n          binding.mapping\n        );\n        const head = relativePositionToAbsolutePosition(\n          binding.doc,\n          binding.type,\n          relSel.head,\n          binding.mapping\n        );\n        if (anchor !== null && head !== null) {\n          const sel = TextSelection.between(tr.doc.resolve(anchor), tr.doc.resolve(head));\n          tr.setSelection(sel);\n        }\n      }\n    }\n  };\n  var getRelativeSelection = (pmbinding, state) => ({\n    type: (\n      /** @type {any} */\n      state.selection.jsonID\n    ),\n    anchor: absolutePositionToRelativePosition(\n      state.selection.anchor,\n      pmbinding.type,\n      pmbinding.mapping\n    ),\n    head: absolutePositionToRelativePosition(\n      state.selection.head,\n      pmbinding.type,\n      pmbinding.mapping\n    )\n  });\n  var ProsemirrorBinding = class {\n    /**\n     * @param {Y.XmlFragment} yXmlFragment The bind source\n     * @param {ProsemirrorMapping} mapping\n     */\n    constructor(yXmlFragment, mapping = /* @__PURE__ */ new Map()) {\n      this.type = yXmlFragment;\n      this.prosemirrorView = null;\n      this.mux = createMutex();\n      this.mapping = mapping;\n      this.isOMark = /* @__PURE__ */ new Map();\n      this._observeFunction = this._typeChanged.bind(this);\n      this.doc = yXmlFragment.doc;\n      this.beforeTransactionSelection = null;\n      this.beforeAllTransactions = () => {\n        if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {\n          this.beforeTransactionSelection = getRelativeSelection(\n            this,\n            this.prosemirrorView.state\n          );\n        }\n      };\n      this.afterAllTransactions = () => {\n        this.beforeTransactionSelection = null;\n      };\n      this._domSelectionInView = null;\n    }\n    /**\n     * Create a transaction for changing the prosemirror state.\n     *\n     * @returns\n     */\n    get _tr() {\n      return this.prosemirrorView.state.tr.setMeta(\"addToHistory\", false);\n    }\n    _isLocalCursorInView() {\n      if (!this.prosemirrorView.hasFocus()) return false;\n      if (isBrowser && this._domSelectionInView === null) {\n        timeout(0, () => {\n          this._domSelectionInView = null;\n        });\n        this._domSelectionInView = this._isDomSelectionInView();\n      }\n      return this._domSelectionInView;\n    }\n    _isDomSelectionInView() {\n      const selection = this.prosemirrorView._root.getSelection();\n      if (selection == null || selection.anchorNode == null) return false;\n      const range = this.prosemirrorView._root.createRange();\n      range.setStart(selection.anchorNode, selection.anchorOffset);\n      range.setEnd(selection.focusNode, selection.focusOffset);\n      const rects = range.getClientRects();\n      if (rects.length === 0) {\n        if (range.startContainer && range.collapsed) {\n          range.selectNodeContents(range.startContainer);\n        }\n      }\n      const bounding = range.getBoundingClientRect();\n      const documentElement = doc3.documentElement;\n      return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);\n    }\n    /**\n     * @param {Y.Snapshot} snapshot\n     * @param {Y.Snapshot} prevSnapshot\n     */\n    renderSnapshot(snapshot2, prevSnapshot) {\n      if (!prevSnapshot) {\n        prevSnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());\n      }\n      this.prosemirrorView.dispatch(\n        this._tr.setMeta(ySyncPluginKey, { snapshot: snapshot2, prevSnapshot })\n      );\n    }\n    unrenderSnapshot() {\n      this.mapping.clear();\n      this.mux(() => {\n        const fragmentContent = this.type.toArray().map(\n          (t) => createNodeFromYElement(\n            /** @type {Y.XmlElement} */\n            t,\n            this.prosemirrorView.state.schema,\n            this\n          )\n        ).filter((n) => n !== null);\n        const tr = this._tr.replace(\n          0,\n          this.prosemirrorView.state.doc.content.size,\n          new Slice(Fragment.from(fragmentContent), 0, 0)\n        );\n        tr.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });\n        this.prosemirrorView.dispatch(tr);\n      });\n    }\n    _forceRerender() {\n      this.mapping.clear();\n      this.mux(() => {\n        const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection;\n        const fragmentContent = this.type.toArray().map(\n          (t) => createNodeFromYElement(\n            /** @type {Y.XmlElement} */\n            t,\n            this.prosemirrorView.state.schema,\n            this\n          )\n        ).filter((n) => n !== null);\n        const tr = this._tr.replace(\n          0,\n          this.prosemirrorView.state.doc.content.size,\n          new Slice(Fragment.from(fragmentContent), 0, 0)\n        );\n        if (sel) {\n          const clampedAnchor = min(max(sel.anchor, 0), tr.doc.content.size);\n          const clampedHead = min(max(sel.head, 0), tr.doc.content.size);\n          tr.setSelection(TextSelection.create(tr.doc, clampedAnchor, clampedHead));\n        }\n        this.prosemirrorView.dispatch(\n          tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, binding: this })\n        );\n      });\n    }\n    /**\n     * @param {Y.Snapshot|Uint8Array} snapshot\n     * @param {Y.Snapshot|Uint8Array} prevSnapshot\n     * @param {Object} pluginState\n     */\n    _renderSnapshot(snapshot2, prevSnapshot, pluginState) {\n      let historyDoc = this.doc;\n      let historyType = this.type;\n      if (!snapshot2) {\n        snapshot2 = snapshot(this.doc);\n      }\n      if (snapshot2 instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {\n        if (!(snapshot2 instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {\n          unexpectedCase();\n        }\n        historyDoc = new Doc({ gc: false });\n        applyUpdateV2(historyDoc, prevSnapshot);\n        prevSnapshot = snapshot(historyDoc);\n        applyUpdateV2(historyDoc, snapshot2);\n        snapshot2 = snapshot(historyDoc);\n        if (historyType._item === null) {\n          const rootKey = Array.from(this.doc.share.keys()).find(\n            (key) => this.doc.share.get(key) === this.type\n          );\n          historyType = historyDoc.getXmlFragment(rootKey);\n        } else {\n          const historyStructs = historyDoc.store.clients.get(historyType._item.id.client) ?? [];\n          const itemIndex = findIndexSS(\n            historyStructs,\n            historyType._item.id.clock\n          );\n          const item = (\n            /** @type {Y.Item} */\n            historyStructs[itemIndex]\n          );\n          const content = (\n            /** @type {Y.ContentType} */\n            item.content\n          );\n          historyType = /** @type {Y.XmlFragment} */\n          content.type;\n        }\n      }\n      this.mapping.clear();\n      this.mux(() => {\n        historyDoc.transact((transaction) => {\n          const pud = pluginState.permanentUserData;\n          if (pud) {\n            pud.dss.forEach((ds) => {\n              iterateDeletedStructs(transaction, ds, (_item) => {\n              });\n            });\n          }\n          const computeYChange = (type, id2) => {\n            const user = type === \"added\" ? pud.getUserByClientId(id2.client) : pud.getUserByDeletedId(id2);\n            return {\n              user,\n              type,\n              color: getUserColor(\n                pluginState.colorMapping,\n                pluginState.colors,\n                user\n              )\n            };\n          };\n          const fragmentContent = typeListToArraySnapshot(\n            historyType,\n            new Snapshot(prevSnapshot.ds, snapshot2.sv)\n          ).map((t) => {\n            if (!t._item.deleted || isVisible2(t._item, snapshot2) || isVisible2(t._item, prevSnapshot)) {\n              return createNodeFromYElement(\n                t,\n                this.prosemirrorView.state.schema,\n                { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },\n                snapshot2,\n                prevSnapshot,\n                computeYChange\n              );\n            } else {\n              return null;\n            }\n          }).filter((n) => n !== null);\n          const tr = this._tr.replace(\n            0,\n            this.prosemirrorView.state.doc.content.size,\n            new Slice(Fragment.from(fragmentContent), 0, 0)\n          );\n          this.prosemirrorView.dispatch(\n            tr.setMeta(ySyncPluginKey, { isChangeOrigin: true })\n          );\n        }, ySyncPluginKey);\n      });\n    }\n    /**\n     * @param {Array<Y.YEvent<any>>} events\n     * @param {Y.Transaction} transaction\n     */\n    _typeChanged(events, transaction) {\n      if (this.prosemirrorView == null) return;\n      const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);\n      if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {\n        this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);\n        return;\n      }\n      this.mux(() => {\n        const delType = (_, type) => this.mapping.delete(type);\n        iterateDeletedStructs(\n          transaction,\n          transaction.deleteSet,\n          (struct) => {\n            if (struct.constructor === Item2) {\n              const type = (\n                /** @type {Y.ContentType} */\n                /** @type {Y.Item} */\n                struct.content.type\n              );\n              type && this.mapping.delete(type);\n            }\n          }\n        );\n        transaction.changed.forEach(delType);\n        transaction.changedParentTypes.forEach(delType);\n        const fragmentContent = this.type.toArray().map(\n          (t) => createNodeIfNotExists(\n            /** @type {Y.XmlElement | Y.XmlHook} */\n            t,\n            this.prosemirrorView.state.schema,\n            this\n          )\n        ).filter((n) => n !== null);\n        let tr = this._tr.replace(\n          0,\n          this.prosemirrorView.state.doc.content.size,\n          new Slice(Fragment.from(fragmentContent), 0, 0)\n        );\n        restoreRelativeSelection(tr, this.beforeTransactionSelection, this);\n        tr = tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof UndoManager });\n        if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {\n          tr.scrollIntoView();\n        }\n        this.prosemirrorView.dispatch(tr);\n      });\n    }\n    /**\n     * @param {import('prosemirror-model').Node} doc\n     */\n    _prosemirrorChanged(doc4) {\n      this.doc.transact(() => {\n        updateYFragment(this.doc, this.type, doc4, this);\n        this.beforeTransactionSelection = getRelativeSelection(\n          this,\n          this.prosemirrorView.state\n        );\n      }, ySyncPluginKey);\n    }\n    /**\n     * View is ready to listen to changes. Register observers.\n     * @param {any} prosemirrorView\n     */\n    initView(prosemirrorView) {\n      if (this.prosemirrorView != null) this.destroy();\n      this.prosemirrorView = prosemirrorView;\n      this.doc.on(\"beforeAllTransactions\", this.beforeAllTransactions);\n      this.doc.on(\"afterAllTransactions\", this.afterAllTransactions);\n      this.type.observeDeep(this._observeFunction);\n    }\n    destroy() {\n      if (this.prosemirrorView == null) return;\n      this.prosemirrorView = null;\n      this.type.unobserveDeep(this._observeFunction);\n      this.doc.off(\"beforeAllTransactions\", this.beforeAllTransactions);\n      this.doc.off(\"afterAllTransactions\", this.afterAllTransactions);\n    }\n  };\n  var createNodeIfNotExists = (el, schema2, meta, snapshot2, prevSnapshot, computeYChange) => {\n    const node = (\n      /** @type {PModel.Node} */\n      meta.mapping.get(el)\n    );\n    if (node === void 0) {\n      if (el instanceof YXmlElement) {\n        return createNodeFromYElement(\n          el,\n          schema2,\n          meta,\n          snapshot2,\n          prevSnapshot,\n          computeYChange\n        );\n      } else {\n        throw methodUnimplemented();\n      }\n    }\n    return node;\n  };\n  var createNodeFromYElement = (el, schema2, meta, snapshot2, prevSnapshot, computeYChange) => {\n    const children = [];\n    const createChildren = (type) => {\n      if (type instanceof YXmlElement) {\n        const n = createNodeIfNotExists(\n          type,\n          schema2,\n          meta,\n          snapshot2,\n          prevSnapshot,\n          computeYChange\n        );\n        if (n !== null) {\n          children.push(n);\n        }\n      } else {\n        const nextytext = (\n          /** @type {Y.ContentType} */\n          type._item.right?.content?.type\n        );\n        if (nextytext instanceof YText && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {\n          type.applyDelta([\n            { retain: type.length },\n            ...nextytext.toDelta()\n          ]);\n          nextytext.doc.transact((tr) => {\n            nextytext._item.delete(tr);\n          });\n        }\n        const ns = createTextNodesFromYText(\n          type,\n          schema2,\n          meta,\n          snapshot2,\n          prevSnapshot,\n          computeYChange\n        );\n        if (ns !== null) {\n          ns.forEach((textchild) => {\n            if (textchild !== null) {\n              children.push(textchild);\n            }\n          });\n        }\n      }\n    };\n    if (snapshot2 === void 0 || prevSnapshot === void 0) {\n      el.toArray().forEach(createChildren);\n    } else {\n      typeListToArraySnapshot(el, new Snapshot(prevSnapshot.ds, snapshot2.sv)).forEach(createChildren);\n    }\n    try {\n      const attrs = el.getAttributes(snapshot2);\n      if (snapshot2 !== void 0) {\n        if (!isVisible2(\n          /** @type {Y.Item} */\n          el._item,\n          snapshot2\n        )) {\n          attrs.ychange = computeYChange ? computeYChange(\n            \"removed\",\n            /** @type {Y.Item} */\n            el._item.id\n          ) : { type: \"removed\" };\n        } else if (!isVisible2(\n          /** @type {Y.Item} */\n          el._item,\n          prevSnapshot\n        )) {\n          attrs.ychange = computeYChange ? computeYChange(\n            \"added\",\n            /** @type {Y.Item} */\n            el._item.id\n          ) : { type: \"added\" };\n        }\n      }\n      const node = schema2.node(el.nodeName, attrs, children);\n      meta.mapping.set(el, node);\n      return node;\n    } catch (e) {\n      el.doc.transact((transaction) => {\n        el._item.delete(transaction);\n      }, ySyncPluginKey);\n      meta.mapping.delete(el);\n      return null;\n    }\n  };\n  var createTextNodesFromYText = (text2, schema2, _meta, snapshot2, prevSnapshot, computeYChange) => {\n    const nodes2 = [];\n    const deltas = text2.toDelta(snapshot2, prevSnapshot, computeYChange);\n    try {\n      for (let i = 0; i < deltas.length; i++) {\n        const delta = deltas[i];\n        nodes2.push(schema2.text(delta.insert, attributesToMarks(delta.attributes, schema2)));\n      }\n    } catch (e) {\n      text2.doc.transact((transaction) => {\n        text2._item.delete(transaction);\n      }, ySyncPluginKey);\n      return null;\n    }\n    return nodes2;\n  };\n  var createTypeFromTextNodes = (nodes2, meta) => {\n    const type = new YXmlText();\n    const delta = nodes2.map((node) => ({\n      // @ts-ignore\n      insert: node.text,\n      attributes: marksToAttributes(node.marks, meta)\n    }));\n    type.applyDelta(delta);\n    meta.mapping.set(type, nodes2);\n    return type;\n  };\n  var createTypeFromElementNode = (node, meta) => {\n    const type = new YXmlElement(node.type.name);\n    for (const key in node.attrs) {\n      const val = node.attrs[key];\n      if (val !== null && key !== \"ychange\") {\n        type.setAttribute(key, val);\n      }\n    }\n    type.insert(\n      0,\n      normalizePNodeContent(node).map(\n        (n) => createTypeFromTextOrElementNode(n, meta)\n      )\n    );\n    meta.mapping.set(type, node);\n    return type;\n  };\n  var createTypeFromTextOrElementNode = (node, meta) => node instanceof Array ? createTypeFromTextNodes(node, meta) : createTypeFromElementNode(node, meta);\n  var isObject = (val) => typeof val === \"object\" && val !== null;\n  var equalAttrs2 = (pattrs, yattrs) => {\n    const keys4 = Object.keys(pattrs).filter((key) => pattrs[key] !== null);\n    let eq = keys4.length === (yattrs == null ? 0 : Object.keys(yattrs).filter((key) => yattrs[key] !== null).length);\n    for (let i = 0; i < keys4.length && eq; i++) {\n      const key = keys4[i];\n      const l = pattrs[key];\n      const r = yattrs[key];\n      eq = key === \"ychange\" || l === r || isObject(l) && isObject(r) && equalAttrs2(l, r);\n    }\n    return eq;\n  };\n  var normalizePNodeContent = (pnode) => {\n    const c = pnode.content.content;\n    const res = [];\n    for (let i = 0; i < c.length; i++) {\n      const n = c[i];\n      if (n.isText) {\n        const textNodes = [];\n        for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {\n          textNodes.push(tnode);\n        }\n        i--;\n        res.push(textNodes);\n      } else {\n        res.push(n);\n      }\n    }\n    return res;\n  };\n  var equalYTextPText = (ytext, ptexts) => {\n    const delta = ytext.toDelta();\n    return delta.length === ptexts.length && delta.every(\n      /** @type {(d:any,i:number) => boolean} */\n      (d, i) => d.insert === /** @type {any} */\n      ptexts[i].text && keys2(d.attributes || {}).length === ptexts[i].marks.length && every(d.attributes, (attr, yattrname) => {\n        const markname = yattr2markname(yattrname);\n        const pmarks = ptexts[i].marks;\n        return equalAttrs2(attr, pmarks.find(\n          /** @param {any} mark */\n          (mark) => mark.type.name === markname\n        )?.attrs);\n      })\n    );\n  };\n  var equalYTypePNode = (ytype, pnode) => {\n    if (ytype instanceof YXmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {\n      const normalizedContent = normalizePNodeContent(pnode);\n      return ytype._length === normalizedContent.length && equalAttrs2(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(\n        (ychild, i) => equalYTypePNode(ychild, normalizedContent[i])\n      );\n    }\n    return ytype instanceof YXmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);\n  };\n  var mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(\n    (a, i) => pcontent[i] === a\n  );\n  var computeChildEqualityFactor = (ytype, pnode, meta) => {\n    const yChildren = ytype.toArray();\n    const pChildren = normalizePNodeContent(pnode);\n    const pChildCnt = pChildren.length;\n    const yChildCnt = yChildren.length;\n    const minCnt = min(yChildCnt, pChildCnt);\n    let left = 0;\n    let right = 0;\n    let foundMappedChild = false;\n    for (; left < minCnt; left++) {\n      const leftY = yChildren[left];\n      const leftP = pChildren[left];\n      if (mappedIdentity(meta.mapping.get(leftY), leftP)) {\n        foundMappedChild = true;\n      } else if (!equalYTypePNode(leftY, leftP)) {\n        break;\n      }\n    }\n    for (; left + right < minCnt; right++) {\n      const rightY = yChildren[yChildCnt - right - 1];\n      const rightP = pChildren[pChildCnt - right - 1];\n      if (mappedIdentity(meta.mapping.get(rightY), rightP)) {\n        foundMappedChild = true;\n      } else if (!equalYTypePNode(rightY, rightP)) {\n        break;\n      }\n    }\n    return {\n      equalityFactor: left + right,\n      foundMappedChild\n    };\n  };\n  var ytextTrans = (ytext) => {\n    let str = \"\";\n    let n = ytext._start;\n    const nAttrs = {};\n    while (n !== null) {\n      if (!n.deleted) {\n        if (n.countable && n.content instanceof ContentString) {\n          str += n.content.str;\n        } else if (n.content instanceof ContentFormat) {\n          nAttrs[n.content.key] = null;\n        }\n      }\n      n = n.right;\n    }\n    return {\n      str,\n      nAttrs\n    };\n  };\n  var updateYText = (ytext, ptexts, meta) => {\n    meta.mapping.set(ytext, ptexts);\n    const { nAttrs, str } = ytextTrans(ytext);\n    const content = ptexts.map((p) => ({\n      insert: (\n        /** @type {any} */\n        p.text\n      ),\n      attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks, meta))\n    }));\n    const { insert, remove, index } = simpleDiff(\n      str,\n      content.map((c) => c.insert).join(\"\")\n    );\n    ytext.delete(index, remove);\n    ytext.insert(index, insert);\n    ytext.applyDelta(\n      content.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))\n    );\n  };\n  var hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/;\n  var yattr2markname = (attrName) => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName;\n  var attributesToMarks = (attrs, schema2) => {\n    const marks2 = [];\n    for (const markName in attrs) {\n      marks2.push(schema2.mark(yattr2markname(markName), attrs[markName]));\n    }\n    return marks2;\n  };\n  var marksToAttributes = (marks2, meta) => {\n    const pattrs = {};\n    marks2.forEach((mark) => {\n      if (mark.type.name !== \"ychange\") {\n        const isOverlapping = setIfUndefined(meta.isOMark, mark.type, () => !mark.type.excludes(mark.type));\n        pattrs[isOverlapping ? `${mark.type.name}--${hashOfJSON(mark.toJSON())}` : mark.type.name] = mark.attrs;\n      }\n    });\n    return pattrs;\n  };\n  var updateYFragment = (y, yDomFragment, pNode, meta) => {\n    if (yDomFragment instanceof YXmlElement && yDomFragment.nodeName !== pNode.type.name) {\n      throw new Error(\"node name mismatch!\");\n    }\n    meta.mapping.set(yDomFragment, pNode);\n    if (yDomFragment instanceof YXmlElement) {\n      const yDomAttrs = yDomFragment.getAttributes();\n      const pAttrs = pNode.attrs;\n      for (const key in pAttrs) {\n        if (pAttrs[key] !== null) {\n          if (yDomAttrs[key] !== pAttrs[key] && key !== \"ychange\") {\n            yDomFragment.setAttribute(key, pAttrs[key]);\n          }\n        } else {\n          yDomFragment.removeAttribute(key);\n        }\n      }\n      for (const key in yDomAttrs) {\n        if (pAttrs[key] === void 0) {\n          yDomFragment.removeAttribute(key);\n        }\n      }\n    }\n    const pChildren = normalizePNodeContent(pNode);\n    const pChildCnt = pChildren.length;\n    const yChildren = yDomFragment.toArray();\n    const yChildCnt = yChildren.length;\n    const minCnt = min(pChildCnt, yChildCnt);\n    let left = 0;\n    let right = 0;\n    for (; left < minCnt; left++) {\n      const leftY = yChildren[left];\n      const leftP = pChildren[left];\n      if (!mappedIdentity(meta.mapping.get(leftY), leftP)) {\n        if (equalYTypePNode(leftY, leftP)) {\n          meta.mapping.set(leftY, leftP);\n        } else {\n          break;\n        }\n      }\n    }\n    for (; right + left < minCnt; right++) {\n      const rightY = yChildren[yChildCnt - right - 1];\n      const rightP = pChildren[pChildCnt - right - 1];\n      if (!mappedIdentity(meta.mapping.get(rightY), rightP)) {\n        if (equalYTypePNode(rightY, rightP)) {\n          meta.mapping.set(rightY, rightP);\n        } else {\n          break;\n        }\n      }\n    }\n    y.transact(() => {\n      while (yChildCnt - left - right > 0 && pChildCnt - left - right > 0) {\n        const leftY = yChildren[left];\n        const leftP = pChildren[left];\n        const rightY = yChildren[yChildCnt - right - 1];\n        const rightP = pChildren[pChildCnt - right - 1];\n        if (leftY instanceof YXmlText && leftP instanceof Array) {\n          if (!equalYTextPText(leftY, leftP)) {\n            updateYText(leftY, leftP, meta);\n          }\n          left += 1;\n        } else {\n          let updateLeft = leftY instanceof YXmlElement && matchNodeName(leftY, leftP);\n          let updateRight = rightY instanceof YXmlElement && matchNodeName(rightY, rightP);\n          if (updateLeft && updateRight) {\n            const equalityLeft = computeChildEqualityFactor(\n              /** @type {Y.XmlElement} */\n              leftY,\n              /** @type {PModel.Node} */\n              leftP,\n              meta\n            );\n            const equalityRight = computeChildEqualityFactor(\n              /** @type {Y.XmlElement} */\n              rightY,\n              /** @type {PModel.Node} */\n              rightP,\n              meta\n            );\n            if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {\n              updateRight = false;\n            } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {\n              updateLeft = false;\n            } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {\n              updateLeft = false;\n            } else {\n              updateRight = false;\n            }\n          }\n          if (updateLeft) {\n            updateYFragment(\n              y,\n              /** @type {Y.XmlFragment} */\n              leftY,\n              /** @type {PModel.Node} */\n              leftP,\n              meta\n            );\n            left += 1;\n          } else if (updateRight) {\n            updateYFragment(\n              y,\n              /** @type {Y.XmlFragment} */\n              rightY,\n              /** @type {PModel.Node} */\n              rightP,\n              meta\n            );\n            right += 1;\n          } else {\n            meta.mapping.delete(yDomFragment.get(left));\n            yDomFragment.delete(left, 1);\n            yDomFragment.insert(left, [\n              createTypeFromTextOrElementNode(leftP, meta)\n            ]);\n            left += 1;\n          }\n        }\n      }\n      const yDelLen = yChildCnt - left - right;\n      if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof YXmlText) {\n        meta.mapping.delete(yChildren[0]);\n        yChildren[0].delete(0, yChildren[0].length);\n      } else if (yDelLen > 0) {\n        yDomFragment.slice(left, left + yDelLen).forEach((type) => meta.mapping.delete(type));\n        yDomFragment.delete(left, yDelLen);\n      }\n      if (left + right < pChildCnt) {\n        const ins = [];\n        for (let i = left; i < pChildCnt - right; i++) {\n          ins.push(createTypeFromTextOrElementNode(pChildren[i], meta));\n        }\n        yDomFragment.insert(left, ins);\n      }\n    }, ySyncPluginKey);\n  };\n  var matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;\n\n  // node_modules/y-prosemirror/src/lib.js\n  var viewsToUpdate = null;\n  var updateMetas = () => {\n    const ups = (\n      /** @type {Map<EditorView, Map<any, any>>} */\n      viewsToUpdate\n    );\n    viewsToUpdate = null;\n    ups.forEach((metas, view) => {\n      const tr = view.state.tr;\n      const syncState = ySyncPluginKey.getState(view.state);\n      if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n        metas.forEach((val, key) => {\n          tr.setMeta(key, val);\n        });\n        view.dispatch(tr);\n      }\n    });\n  };\n  var setMeta = (view, key, value) => {\n    if (!viewsToUpdate) {\n      viewsToUpdate = /* @__PURE__ */ new Map();\n      timeout(0, updateMetas);\n    }\n    setIfUndefined(viewsToUpdate, view, create).set(key, value);\n  };\n  var absolutePositionToRelativePosition = (pos, type, mapping) => {\n    if (pos === 0) {\n      return createRelativePositionFromTypeIndex(type, 0, type.length === 0 ? -1 : 0);\n    }\n    let n = type._first === null ? null : (\n      /** @type {Y.ContentType} */\n      type._first.content.type\n    );\n    while (n !== null && type !== n) {\n      if (n instanceof YXmlText) {\n        if (n._length >= pos) {\n          return createRelativePositionFromTypeIndex(n, pos, type.length === 0 ? -1 : 0);\n        } else {\n          pos -= n._length;\n        }\n        if (n._item !== null && n._item.next !== null) {\n          n = /** @type {Y.ContentType} */\n          n._item.next.content.type;\n        } else {\n          do {\n            n = n._item === null ? null : n._item.parent;\n            pos--;\n          } while (n !== type && n !== null && n._item !== null && n._item.next === null);\n          if (n !== null && n !== type) {\n            n = n._item === null ? null : (\n              /** @type {Y.ContentType} */\n              /** @type Y.Item */\n              n._item.next.content.type\n            );\n          }\n        }\n      } else {\n        const pNodeSize = (\n          /** @type {any} */\n          (mapping.get(n) || { nodeSize: 0 }).nodeSize\n        );\n        if (n._first !== null && pos < pNodeSize) {\n          n = /** @type {Y.ContentType} */\n          n._first.content.type;\n          pos--;\n        } else {\n          if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n            return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);\n          }\n          pos -= pNodeSize;\n          if (n._item !== null && n._item.next !== null) {\n            n = /** @type {Y.ContentType} */\n            n._item.next.content.type;\n          } else {\n            if (pos === 0) {\n              n = n._item === null ? n : n._item.parent;\n              return new RelativePosition(n._item === null ? null : n._item.id, n._item === null ? findRootTypeKey(n) : null, null);\n            }\n            do {\n              n = /** @type {Y.Item} */\n              n._item.parent;\n              pos--;\n            } while (n !== type && /** @type {Y.Item} */\n            n._item.next === null);\n            if (n !== type) {\n              n = /** @type {Y.ContentType} */\n              /** @type {Y.Item} */\n              /** @type {Y.Item} */\n              n._item.next.content.type;\n            }\n          }\n        }\n      }\n      if (n === null) {\n        throw unexpectedCase();\n      }\n      if (pos === 0 && n.constructor !== YXmlText && n !== type) {\n        return createRelativePosition2(n._item.parent, n._item);\n      }\n    }\n    return createRelativePositionFromTypeIndex(type, type._length, type.length === 0 ? -1 : 0);\n  };\n  var createRelativePosition2 = (type, item) => {\n    let typeid = null;\n    let tname = null;\n    if (type._item === null) {\n      tname = findRootTypeKey(type);\n    } else {\n      typeid = createID(type._item.id.client, type._item.id.clock);\n    }\n    return new RelativePosition(typeid, tname, item.id);\n  };\n  var relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {\n    const decodedPos = createAbsolutePositionFromRelativePosition(relPos, y);\n    if (decodedPos === null || decodedPos.type !== documentType && !isParentOf(documentType, decodedPos.type._item)) {\n      return null;\n    }\n    let type = decodedPos.type;\n    let pos = 0;\n    if (type.constructor === YXmlText) {\n      pos = decodedPos.index;\n    } else if (type._item === null || !type._item.deleted) {\n      let n = type._first;\n      let i = 0;\n      while (i < type._length && i < decodedPos.index && n !== null) {\n        if (!n.deleted) {\n          const t = (\n            /** @type {Y.ContentType} */\n            n.content.type\n          );\n          i++;\n          if (t instanceof YXmlText) {\n            pos += t._length;\n          } else {\n            pos += /** @type {any} */\n            mapping.get(t).nodeSize;\n          }\n        }\n        n = /** @type {Y.Item} */\n        n.right;\n      }\n      pos += 1;\n    }\n    while (type !== documentType && type._item !== null) {\n      const parent = type._item.parent;\n      if (parent._item === null || !parent._item.deleted) {\n        pos += 1;\n        let n = (\n          /** @type {Y.AbstractType} */\n          parent._first\n        );\n        while (n !== null) {\n          const contentType = (\n            /** @type {Y.ContentType} */\n            n.content.type\n          );\n          if (contentType === type) {\n            break;\n          }\n          if (!n.deleted) {\n            if (contentType instanceof YXmlText) {\n              pos += contentType._length;\n            } else {\n              pos += /** @type {any} */\n              mapping.get(contentType).nodeSize;\n            }\n          }\n          n = n.right;\n        }\n      }\n      type = /** @type {Y.AbstractType} */\n      parent;\n    }\n    return pos - 1;\n  };\n  function prosemirrorToYXmlFragment(doc4, xmlFragment) {\n    const type = xmlFragment || new YXmlFragment();\n    const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(void 0) };\n    updateYFragment(ydoc, type, doc4, { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() });\n    return type;\n  }\n\n  // node_modules/y-prosemirror/src/plugins/cursor-plugin.js\n  var defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId;\n  var defaultCursorBuilder = (user) => {\n    const cursor = document.createElement(\"span\");\n    cursor.classList.add(\"ProseMirror-yjs-cursor\");\n    cursor.setAttribute(\"style\", `border-color: ${user.color}`);\n    const userDiv = document.createElement(\"div\");\n    userDiv.setAttribute(\"style\", `background-color: ${user.color}`);\n    userDiv.insertBefore(document.createTextNode(user.name), null);\n    const nonbreakingSpace1 = document.createTextNode(\"\\u2060\");\n    const nonbreakingSpace2 = document.createTextNode(\"\\u2060\");\n    cursor.insertBefore(nonbreakingSpace1, null);\n    cursor.insertBefore(userDiv, null);\n    cursor.insertBefore(nonbreakingSpace2, null);\n    return cursor;\n  };\n  var defaultSelectionBuilder = (user) => {\n    return {\n      style: `background-color: ${user.color}70`,\n      class: \"ProseMirror-yjs-selection\"\n    };\n  };\n  var rxValidColor = /^#[0-9a-fA-F]{6}$/;\n  var createDecorations = (state, awareness, awarenessFilter, createCursor, createSelection) => {\n    const ystate = ySyncPluginKey.getState(state);\n    const y = ystate.doc;\n    const decorations = [];\n    if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding.mapping.size === 0) {\n      return DecorationSet.create(state.doc, []);\n    }\n    awareness.getStates().forEach((aw, clientId) => {\n      if (!awarenessFilter(y.clientID, clientId, aw)) {\n        return;\n      }\n      if (aw.cursor != null) {\n        const user = aw.user || {};\n        if (user.color == null) {\n          user.color = \"#ffa500\";\n        } else if (!rxValidColor.test(user.color)) {\n          console.warn(\"A user uses an unsupported color format\", user);\n        }\n        if (user.name == null) {\n          user.name = `User: ${clientId}`;\n        }\n        let anchor = relativePositionToAbsolutePosition(\n          y,\n          ystate.type,\n          createRelativePositionFromJSON(aw.cursor.anchor),\n          ystate.binding.mapping\n        );\n        let head = relativePositionToAbsolutePosition(\n          y,\n          ystate.type,\n          createRelativePositionFromJSON(aw.cursor.head),\n          ystate.binding.mapping\n        );\n        if (anchor !== null && head !== null) {\n          const maxsize = max(state.doc.content.size - 1, 0);\n          anchor = min(anchor, maxsize);\n          head = min(head, maxsize);\n          decorations.push(\n            Decoration.widget(head, () => createCursor(user, clientId), {\n              key: clientId + \"\",\n              side: 10\n            })\n          );\n          const from4 = min(anchor, head);\n          const to = max(anchor, head);\n          decorations.push(\n            Decoration.inline(from4, to, createSelection(user, clientId), {\n              inclusiveEnd: true,\n              inclusiveStart: false\n            })\n          );\n        }\n      }\n    });\n    return DecorationSet.create(state.doc, decorations);\n  };\n  var yCursorPlugin = (awareness, {\n    awarenessStateFilter = defaultAwarenessStateFilter,\n    cursorBuilder = defaultCursorBuilder,\n    selectionBuilder = defaultSelectionBuilder,\n    getSelection: getSelection2 = (state) => state.selection\n  } = {}, cursorStateField = \"cursor\") => new Plugin({\n    key: yCursorPluginKey,\n    state: {\n      init(_, state) {\n        return createDecorations(\n          state,\n          awareness,\n          awarenessStateFilter,\n          cursorBuilder,\n          selectionBuilder\n        );\n      },\n      apply(tr, prevState, _oldState, newState) {\n        const ystate = ySyncPluginKey.getState(newState);\n        const yCursorState = tr.getMeta(yCursorPluginKey);\n        if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {\n          return createDecorations(\n            newState,\n            awareness,\n            awarenessStateFilter,\n            cursorBuilder,\n            selectionBuilder\n          );\n        }\n        return prevState.map(tr.mapping, tr.doc);\n      }\n    },\n    props: {\n      decorations: (state) => {\n        return yCursorPluginKey.getState(state);\n      }\n    },\n    view: (view) => {\n      const awarenessListener = () => {\n        if (view.docView) {\n          setMeta(view, yCursorPluginKey, { awarenessUpdated: true });\n        }\n      };\n      const updateCursorInfo = () => {\n        const ystate = ySyncPluginKey.getState(view.state);\n        const current = awareness.getLocalState() || {};\n        if (view.hasFocus()) {\n          const selection = getSelection2(view.state);\n          const anchor = absolutePositionToRelativePosition(\n            selection.anchor,\n            ystate.type,\n            ystate.binding.mapping\n          );\n          const head = absolutePositionToRelativePosition(\n            selection.head,\n            ystate.type,\n            ystate.binding.mapping\n          );\n          if (current.cursor == null || !compareRelativePositions(\n            createRelativePositionFromJSON(current.cursor.anchor),\n            anchor\n          ) || !compareRelativePositions(\n            createRelativePositionFromJSON(current.cursor.head),\n            head\n          )) {\n            awareness.setLocalStateField(cursorStateField, {\n              anchor,\n              head\n            });\n          }\n        } else if (current.cursor != null && relativePositionToAbsolutePosition(\n          ystate.doc,\n          ystate.type,\n          createRelativePositionFromJSON(current.cursor.anchor),\n          ystate.binding.mapping\n        ) !== null) {\n          awareness.setLocalStateField(cursorStateField, null);\n        }\n      };\n      awareness.on(\"change\", awarenessListener);\n      view.dom.addEventListener(\"focusin\", updateCursorInfo);\n      view.dom.addEventListener(\"focusout\", updateCursorInfo);\n      return {\n        update: updateCursorInfo,\n        destroy: () => {\n          view.dom.removeEventListener(\"focusin\", updateCursorInfo);\n          view.dom.removeEventListener(\"focusout\", updateCursorInfo);\n          awareness.off(\"change\", awarenessListener);\n          awareness.setLocalStateField(cursorStateField, null);\n        }\n      };\n    }\n  });\n\n  // node_modules/y-prosemirror/src/plugins/undo-plugin.js\n  var defaultProtectedNodes = /* @__PURE__ */ new Set([\"paragraph\"]);\n  var defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Item2) || !(item.content instanceof ContentType) || !(item.content.type instanceof YText || item.content.type instanceof YXmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;\n  var yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({\n    key: yUndoPluginKey,\n    state: {\n      init: (initargs, state) => {\n        const ystate = ySyncPluginKey.getState(state);\n        const _undoManager = undoManager || new UndoManager(ystate.type, {\n          trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),\n          deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),\n          captureTransaction: (tr) => tr.meta.get(\"addToHistory\") !== false\n        });\n        return {\n          undoManager: _undoManager,\n          prevSel: null,\n          hasUndoOps: _undoManager.undoStack.length > 0,\n          hasRedoOps: _undoManager.redoStack.length > 0\n        };\n      },\n      apply: (tr, val, oldState, state) => {\n        const binding = ySyncPluginKey.getState(state).binding;\n        const undoManager2 = val.undoManager;\n        const hasUndoOps = undoManager2.undoStack.length > 0;\n        const hasRedoOps = undoManager2.redoStack.length > 0;\n        if (binding) {\n          return {\n            undoManager: undoManager2,\n            prevSel: getRelativeSelection(binding, oldState),\n            hasUndoOps,\n            hasRedoOps\n          };\n        } else {\n          if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n            return Object.assign({}, val, {\n              hasUndoOps: undoManager2.undoStack.length > 0,\n              hasRedoOps: undoManager2.redoStack.length > 0\n            });\n          } else {\n            return val;\n          }\n        }\n      }\n    },\n    view: (view) => {\n      const ystate = ySyncPluginKey.getState(view.state);\n      const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;\n      undoManager2.on(\"stack-item-added\", ({ stackItem }) => {\n        const binding = ystate.binding;\n        if (binding) {\n          stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);\n        }\n      });\n      undoManager2.on(\"stack-item-popped\", ({ stackItem }) => {\n        const binding = ystate.binding;\n        if (binding) {\n          binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;\n        }\n      });\n      return {\n        destroy: () => {\n          undoManager2.destroy();\n        }\n      };\n    }\n  });\n\n  // node_modules/@hocuspocus/common/dist/hocuspocus-common.esm.js\n  var floor2 = Math.floor;\n  var min2 = (a, b) => a < b ? a : b;\n  var max2 = (a, b) => a > b ? a : b;\n  var BIT82 = 128;\n  var BITS72 = 127;\n  var MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER;\n  var _encodeUtf8Polyfill2 = (str) => {\n    const encodedString = unescape(encodeURIComponent(str));\n    const len = encodedString.length;\n    const buf = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      buf[i] = /** @type {number} */\n      encodedString.codePointAt(i);\n    }\n    return buf;\n  };\n  var utf8TextEncoder2 = (\n    /** @type {TextEncoder} */\n    typeof TextEncoder !== \"undefined\" ? new TextEncoder() : null\n  );\n  var _encodeUtf8Native2 = (str) => utf8TextEncoder2.encode(str);\n  var encodeUtf82 = utf8TextEncoder2 ? _encodeUtf8Native2 : _encodeUtf8Polyfill2;\n  var utf8TextDecoder2 = typeof TextDecoder === \"undefined\" ? null : new TextDecoder(\"utf-8\", { fatal: true, ignoreBOM: true });\n  if (utf8TextDecoder2 && utf8TextDecoder2.decode(new Uint8Array()).length === 1) {\n    utf8TextDecoder2 = null;\n  }\n  var write2 = (encoder, num) => {\n    const bufferLen = encoder.cbuf.length;\n    if (encoder.cpos === bufferLen) {\n      encoder.bufs.push(encoder.cbuf);\n      encoder.cbuf = new Uint8Array(bufferLen * 2);\n      encoder.cpos = 0;\n    }\n    encoder.cbuf[encoder.cpos++] = num;\n  };\n  var writeVarUint2 = (encoder, num) => {\n    while (num > BITS72) {\n      write2(encoder, BIT82 | BITS72 & num);\n      num = floor2(num / 128);\n    }\n    write2(encoder, BITS72 & num);\n  };\n  var _strBuffer2 = new Uint8Array(3e4);\n  var _maxStrBSize2 = _strBuffer2.length / 3;\n  var _writeVarStringNative2 = (encoder, str) => {\n    if (str.length < _maxStrBSize2) {\n      const written = utf8TextEncoder2.encodeInto(str, _strBuffer2).written || 0;\n      writeVarUint2(encoder, written);\n      for (let i = 0; i < written; i++) {\n        write2(encoder, _strBuffer2[i]);\n      }\n    } else {\n      writeVarUint8Array2(encoder, encodeUtf82(str));\n    }\n  };\n  var _writeVarStringPolyfill2 = (encoder, str) => {\n    const encodedString = unescape(encodeURIComponent(str));\n    const len = encodedString.length;\n    writeVarUint2(encoder, len);\n    for (let i = 0; i < len; i++) {\n      write2(\n        encoder,\n        /** @type {number} */\n        encodedString.codePointAt(i)\n      );\n    }\n  };\n  var writeVarString2 = utf8TextEncoder2 && /** @type {any} */\n  utf8TextEncoder2.encodeInto ? _writeVarStringNative2 : _writeVarStringPolyfill2;\n  var writeUint8Array2 = (encoder, uint8Array) => {\n    const bufferLen = encoder.cbuf.length;\n    const cpos = encoder.cpos;\n    const leftCopyLen = min2(bufferLen - cpos, uint8Array.length);\n    const rightCopyLen = uint8Array.length - leftCopyLen;\n    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n    encoder.cpos += leftCopyLen;\n    if (rightCopyLen > 0) {\n      encoder.bufs.push(encoder.cbuf);\n      encoder.cbuf = new Uint8Array(max2(bufferLen * 2, rightCopyLen));\n      encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n      encoder.cpos = rightCopyLen;\n    }\n  };\n  var writeVarUint8Array2 = (encoder, uint8Array) => {\n    writeVarUint2(encoder, uint8Array.byteLength);\n    writeUint8Array2(encoder, uint8Array);\n  };\n  var create7 = (s) => new Error(s);\n  var errorUnexpectedEndOfArray2 = create7(\"Unexpected end of array\");\n  var errorIntegerOutOfRange2 = create7(\"Integer out of Range\");\n  var readUint8Array2 = (decoder, len) => {\n    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n    decoder.pos += len;\n    return view;\n  };\n  var readVarUint8Array2 = (decoder) => readUint8Array2(decoder, readVarUint2(decoder));\n  var readUint82 = (decoder) => decoder.arr[decoder.pos++];\n  var readVarUint2 = (decoder) => {\n    let num = 0;\n    let mult = 1;\n    const len = decoder.arr.length;\n    while (decoder.pos < len) {\n      const r = decoder.arr[decoder.pos++];\n      num = num + (r & BITS72) * mult;\n      mult *= 128;\n      if (r < BIT82) {\n        return num;\n      }\n      if (num > MAX_SAFE_INTEGER2) {\n        throw errorIntegerOutOfRange2;\n      }\n    }\n    throw errorUnexpectedEndOfArray2;\n  };\n  var _readVarStringPolyfill2 = (decoder) => {\n    let remainingLen = readVarUint2(decoder);\n    if (remainingLen === 0) {\n      return \"\";\n    } else {\n      let encodedString = String.fromCodePoint(readUint82(decoder));\n      if (--remainingLen < 100) {\n        while (remainingLen--) {\n          encodedString += String.fromCodePoint(readUint82(decoder));\n        }\n      } else {\n        while (remainingLen > 0) {\n          const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;\n          const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n          decoder.pos += nextLen;\n          encodedString += String.fromCodePoint.apply(\n            null,\n            /** @type {any} */\n            bytes\n          );\n          remainingLen -= nextLen;\n        }\n      }\n      return decodeURIComponent(escape(encodedString));\n    }\n  };\n  var _readVarStringNative2 = (decoder) => (\n    /** @type any */\n    utf8TextDecoder2.decode(readVarUint8Array2(decoder))\n  );\n  var readVarString2 = utf8TextDecoder2 ? _readVarStringNative2 : _readVarStringPolyfill2;\n  var AuthMessageType;\n  (function(AuthMessageType2) {\n    AuthMessageType2[AuthMessageType2[\"Token\"] = 0] = \"Token\";\n    AuthMessageType2[AuthMessageType2[\"PermissionDenied\"] = 1] = \"PermissionDenied\";\n    AuthMessageType2[AuthMessageType2[\"Authenticated\"] = 2] = \"Authenticated\";\n  })(AuthMessageType || (AuthMessageType = {}));\n  var writeAuthentication = (encoder, auth) => {\n    writeVarUint2(encoder, AuthMessageType.Token);\n    writeVarString2(encoder, auth);\n  };\n  var readAuthMessage = (decoder, sendToken, permissionDeniedHandler, authenticatedHandler) => {\n    switch (readVarUint2(decoder)) {\n      case AuthMessageType.Token: {\n        sendToken();\n        break;\n      }\n      case AuthMessageType.PermissionDenied: {\n        permissionDeniedHandler(readVarString2(decoder));\n        break;\n      }\n      case AuthMessageType.Authenticated: {\n        authenticatedHandler(readVarString2(decoder));\n        break;\n      }\n    }\n  };\n  var awarenessStatesToArray = (states) => {\n    return Array.from(states.entries()).map(([key, value]) => {\n      return {\n        clientId: key,\n        ...value\n      };\n    });\n  };\n  var WsReadyStates;\n  (function(WsReadyStates2) {\n    WsReadyStates2[WsReadyStates2[\"Connecting\"] = 0] = \"Connecting\";\n    WsReadyStates2[WsReadyStates2[\"Open\"] = 1] = \"Open\";\n    WsReadyStates2[WsReadyStates2[\"Closing\"] = 2] = \"Closing\";\n    WsReadyStates2[WsReadyStates2[\"Closed\"] = 3] = \"Closed\";\n  })(WsReadyStates || (WsReadyStates = {}));\n\n  // node_modules/@lifeomic/attempt/dist/es6/src/index.js\n  function applyDefaults(options) {\n    if (!options) {\n      options = {};\n    }\n    return {\n      delay: options.delay === void 0 ? 200 : options.delay,\n      initialDelay: options.initialDelay === void 0 ? 0 : options.initialDelay,\n      minDelay: options.minDelay === void 0 ? 0 : options.minDelay,\n      maxDelay: options.maxDelay === void 0 ? 0 : options.maxDelay,\n      factor: options.factor === void 0 ? 0 : options.factor,\n      maxAttempts: options.maxAttempts === void 0 ? 3 : options.maxAttempts,\n      timeout: options.timeout === void 0 ? 0 : options.timeout,\n      jitter: options.jitter === true,\n      initialJitter: options.initialJitter === true,\n      handleError: options.handleError === void 0 ? null : options.handleError,\n      handleTimeout: options.handleTimeout === void 0 ? null : options.handleTimeout,\n      beforeAttempt: options.beforeAttempt === void 0 ? null : options.beforeAttempt,\n      calculateDelay: options.calculateDelay === void 0 ? null : options.calculateDelay\n    };\n  }\n  async function sleep(delay) {\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  }\n  function defaultCalculateDelay(context, options) {\n    let delay = options.delay;\n    if (delay === 0) {\n      return 0;\n    }\n    if (options.factor) {\n      delay *= Math.pow(options.factor, context.attemptNum - 1);\n      if (options.maxDelay !== 0) {\n        delay = Math.min(delay, options.maxDelay);\n      }\n    }\n    if (options.jitter) {\n      const min4 = Math.ceil(options.minDelay);\n      const max4 = Math.floor(delay);\n      delay = Math.floor(Math.random() * (max4 - min4 + 1)) + min4;\n    }\n    return Math.round(delay);\n  }\n  async function retry(attemptFunc, attemptOptions) {\n    const options = applyDefaults(attemptOptions);\n    for (const prop of [\n      \"delay\",\n      \"initialDelay\",\n      \"minDelay\",\n      \"maxDelay\",\n      \"maxAttempts\",\n      \"timeout\"\n    ]) {\n      const value = options[prop];\n      if (!Number.isInteger(value) || value < 0) {\n        throw new Error(`Value for ${prop} must be an integer greater than or equal to 0`);\n      }\n    }\n    if (options.factor.constructor !== Number || options.factor < 0) {\n      throw new Error(`Value for factor must be a number greater than or equal to 0`);\n    }\n    if (options.delay < options.minDelay) {\n      throw new Error(`delay cannot be less than minDelay (delay: ${options.delay}, minDelay: ${options.minDelay}`);\n    }\n    const context = {\n      attemptNum: 0,\n      attemptsRemaining: options.maxAttempts ? options.maxAttempts : -1,\n      aborted: false,\n      abort() {\n        context.aborted = true;\n      }\n    };\n    const calculateDelay = options.calculateDelay || defaultCalculateDelay;\n    async function makeAttempt() {\n      if (options.beforeAttempt) {\n        options.beforeAttempt(context, options);\n      }\n      if (context.aborted) {\n        const err = new Error(`Attempt aborted`);\n        err.code = \"ATTEMPT_ABORTED\";\n        throw err;\n      }\n      const onError = async (err) => {\n        if (options.handleError) {\n          await options.handleError(err, context, options);\n        }\n        if (context.aborted || context.attemptsRemaining === 0) {\n          throw err;\n        }\n        context.attemptNum++;\n        const delay = calculateDelay(context, options);\n        if (delay) {\n          await sleep(delay);\n        }\n        return makeAttempt();\n      };\n      if (context.attemptsRemaining > 0) {\n        context.attemptsRemaining--;\n      }\n      if (options.timeout) {\n        return new Promise((resolve, reject) => {\n          const timer = setTimeout(() => {\n            if (options.handleTimeout) {\n              try {\n                resolve(options.handleTimeout(context, options));\n              } catch (e) {\n                reject(e);\n              }\n            } else {\n              const err = new Error(`Retry timeout (attemptNum: ${context.attemptNum}, timeout: ${options.timeout})`);\n              err.code = \"ATTEMPT_TIMEOUT\";\n              reject(err);\n            }\n          }, options.timeout);\n          attemptFunc(context, options).then((result) => {\n            clearTimeout(timer);\n            resolve(result);\n          }).catch((err) => {\n            clearTimeout(timer);\n            onError(err).then(resolve).catch(reject);\n          });\n        });\n      } else {\n        return attemptFunc(context, options).catch(onError);\n      }\n    }\n    const initialDelay = options.calculateDelay ? options.calculateDelay(context, options) : options.initialDelay;\n    if (initialDelay) {\n      await sleep(initialDelay);\n    }\n    if (context.attemptNum < 1 && options.initialJitter) {\n      const delay = calculateDelay(context, options);\n      if (delay) {\n        await sleep(delay);\n      }\n    }\n    return makeAttempt();\n  }\n\n  // node_modules/@hocuspocus/provider/dist/hocuspocus-provider.esm.js\n  var floor3 = Math.floor;\n  var min3 = (a, b) => a < b ? a : b;\n  var max3 = (a, b) => a > b ? a : b;\n  var BIT72 = 64;\n  var BIT83 = 128;\n  var BITS62 = 63;\n  var BITS73 = 127;\n  var MAX_SAFE_INTEGER3 = Number.MAX_SAFE_INTEGER;\n  var create$2 = () => /* @__PURE__ */ new Set();\n  var from3 = Array.from;\n  var _encodeUtf8Polyfill3 = (str) => {\n    const encodedString = unescape(encodeURIComponent(str));\n    const len = encodedString.length;\n    const buf = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n      buf[i] = /** @type {number} */\n      encodedString.codePointAt(i);\n    }\n    return buf;\n  };\n  var utf8TextEncoder3 = (\n    /** @type {TextEncoder} */\n    typeof TextEncoder !== \"undefined\" ? new TextEncoder() : null\n  );\n  var _encodeUtf8Native3 = (str) => utf8TextEncoder3.encode(str);\n  var encodeUtf83 = utf8TextEncoder3 ? _encodeUtf8Native3 : _encodeUtf8Polyfill3;\n  var utf8TextDecoder3 = typeof TextDecoder === \"undefined\" ? null : new TextDecoder(\"utf-8\", { fatal: true, ignoreBOM: true });\n  if (utf8TextDecoder3 && utf8TextDecoder3.decode(new Uint8Array()).length === 1) {\n    utf8TextDecoder3 = null;\n  }\n  var Encoder2 = class {\n    constructor() {\n      this.cpos = 0;\n      this.cbuf = new Uint8Array(100);\n      this.bufs = [];\n    }\n  };\n  var createEncoder2 = () => new Encoder2();\n  var length$1 = (encoder) => {\n    let len = encoder.cpos;\n    for (let i = 0; i < encoder.bufs.length; i++) {\n      len += encoder.bufs[i].length;\n    }\n    return len;\n  };\n  var toUint8Array2 = (encoder) => {\n    const uint8arr = new Uint8Array(length$1(encoder));\n    let curPos = 0;\n    for (let i = 0; i < encoder.bufs.length; i++) {\n      const d = encoder.bufs[i];\n      uint8arr.set(d, curPos);\n      curPos += d.length;\n    }\n    uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);\n    return uint8arr;\n  };\n  var write3 = (encoder, num) => {\n    const bufferLen = encoder.cbuf.length;\n    if (encoder.cpos === bufferLen) {\n      encoder.bufs.push(encoder.cbuf);\n      encoder.cbuf = new Uint8Array(bufferLen * 2);\n      encoder.cpos = 0;\n    }\n    encoder.cbuf[encoder.cpos++] = num;\n  };\n  var writeVarUint3 = (encoder, num) => {\n    while (num > BITS73) {\n      write3(encoder, BIT83 | BITS73 & num);\n      num = floor3(num / 128);\n    }\n    write3(encoder, BITS73 & num);\n  };\n  var _strBuffer3 = new Uint8Array(3e4);\n  var _maxStrBSize3 = _strBuffer3.length / 3;\n  var _writeVarStringNative3 = (encoder, str) => {\n    if (str.length < _maxStrBSize3) {\n      const written = utf8TextEncoder3.encodeInto(str, _strBuffer3).written || 0;\n      writeVarUint3(encoder, written);\n      for (let i = 0; i < written; i++) {\n        write3(encoder, _strBuffer3[i]);\n      }\n    } else {\n      writeVarUint8Array3(encoder, encodeUtf83(str));\n    }\n  };\n  var _writeVarStringPolyfill3 = (encoder, str) => {\n    const encodedString = unescape(encodeURIComponent(str));\n    const len = encodedString.length;\n    writeVarUint3(encoder, len);\n    for (let i = 0; i < len; i++) {\n      write3(\n        encoder,\n        /** @type {number} */\n        encodedString.codePointAt(i)\n      );\n    }\n  };\n  var writeVarString3 = utf8TextEncoder3 && /** @type {any} */\n  utf8TextEncoder3.encodeInto ? _writeVarStringNative3 : _writeVarStringPolyfill3;\n  var writeUint8Array3 = (encoder, uint8Array) => {\n    const bufferLen = encoder.cbuf.length;\n    const cpos = encoder.cpos;\n    const leftCopyLen = min3(bufferLen - cpos, uint8Array.length);\n    const rightCopyLen = uint8Array.length - leftCopyLen;\n    encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);\n    encoder.cpos += leftCopyLen;\n    if (rightCopyLen > 0) {\n      encoder.bufs.push(encoder.cbuf);\n      encoder.cbuf = new Uint8Array(max3(bufferLen * 2, rightCopyLen));\n      encoder.cbuf.set(uint8Array.subarray(leftCopyLen));\n      encoder.cpos = rightCopyLen;\n    }\n  };\n  var writeVarUint8Array3 = (encoder, uint8Array) => {\n    writeVarUint3(encoder, uint8Array.byteLength);\n    writeUint8Array3(encoder, uint8Array);\n  };\n  var create$1 = (s) => new Error(s);\n  var errorUnexpectedEndOfArray3 = create$1(\"Unexpected end of array\");\n  var errorIntegerOutOfRange3 = create$1(\"Integer out of Range\");\n  var Decoder2 = class {\n    /**\n     * @param {Uint8Array} uint8Array Binary data to decode\n     */\n    constructor(uint8Array) {\n      this.arr = uint8Array;\n      this.pos = 0;\n    }\n  };\n  var createDecoder2 = (uint8Array) => new Decoder2(uint8Array);\n  var readUint8Array3 = (decoder, len) => {\n    const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);\n    decoder.pos += len;\n    return view;\n  };\n  var readVarUint8Array3 = (decoder) => readUint8Array3(decoder, readVarUint3(decoder));\n  var readUint83 = (decoder) => decoder.arr[decoder.pos++];\n  var readVarUint3 = (decoder) => {\n    let num = 0;\n    let mult = 1;\n    const len = decoder.arr.length;\n    while (decoder.pos < len) {\n      const r = decoder.arr[decoder.pos++];\n      num = num + (r & BITS73) * mult;\n      mult *= 128;\n      if (r < BIT83) {\n        return num;\n      }\n      if (num > MAX_SAFE_INTEGER3) {\n        throw errorIntegerOutOfRange3;\n      }\n    }\n    throw errorUnexpectedEndOfArray3;\n  };\n  var readVarInt2 = (decoder) => {\n    let r = decoder.arr[decoder.pos++];\n    let num = r & BITS62;\n    let mult = 64;\n    const sign = (r & BIT72) > 0 ? -1 : 1;\n    if ((r & BIT83) === 0) {\n      return sign * num;\n    }\n    const len = decoder.arr.length;\n    while (decoder.pos < len) {\n      r = decoder.arr[decoder.pos++];\n      num = num + (r & BITS73) * mult;\n      mult *= 128;\n      if (r < BIT83) {\n        return sign * num;\n      }\n      if (num > MAX_SAFE_INTEGER3) {\n        throw errorIntegerOutOfRange3;\n      }\n    }\n    throw errorUnexpectedEndOfArray3;\n  };\n  var _readVarStringPolyfill3 = (decoder) => {\n    let remainingLen = readVarUint3(decoder);\n    if (remainingLen === 0) {\n      return \"\";\n    } else {\n      let encodedString = String.fromCodePoint(readUint83(decoder));\n      if (--remainingLen < 100) {\n        while (remainingLen--) {\n          encodedString += String.fromCodePoint(readUint83(decoder));\n        }\n      } else {\n        while (remainingLen > 0) {\n          const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;\n          const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);\n          decoder.pos += nextLen;\n          encodedString += String.fromCodePoint.apply(\n            null,\n            /** @type {any} */\n            bytes\n          );\n          remainingLen -= nextLen;\n        }\n      }\n      return decodeURIComponent(escape(encodedString));\n    }\n  };\n  var _readVarStringNative3 = (decoder) => (\n    /** @type any */\n    utf8TextDecoder3.decode(readVarUint8Array3(decoder))\n  );\n  var readVarString3 = utf8TextDecoder3 ? _readVarStringNative3 : _readVarStringPolyfill3;\n  var peekVarString = (decoder) => {\n    const pos = decoder.pos;\n    const s = readVarString3(decoder);\n    decoder.pos = pos;\n    return s;\n  };\n  var getUnixTime2 = Date.now;\n  var create8 = () => /* @__PURE__ */ new Map();\n  var setIfUndefined2 = (map3, key, createT) => {\n    let set = map3.get(key);\n    if (set === void 0) {\n      map3.set(key, set = createT());\n    }\n    return set;\n  };\n  var Observable2 = class {\n    constructor() {\n      this._observers = create8();\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n    on(name, f) {\n      setIfUndefined2(this._observers, name, create$2).add(f);\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n    once(name, f) {\n      const _f = (...args2) => {\n        this.off(name, _f);\n        f(...args2);\n      };\n      this.on(name, _f);\n    }\n    /**\n     * @param {N} name\n     * @param {function} f\n     */\n    off(name, f) {\n      const observers = this._observers.get(name);\n      if (observers !== void 0) {\n        observers.delete(f);\n        if (observers.size === 0) {\n          this._observers.delete(name);\n        }\n      }\n    }\n    /**\n     * Emit a named event. All registered event listeners that listen to the\n     * specified name will receive the event.\n     *\n     * @todo This should catch exceptions\n     *\n     * @param {N} name The event name.\n     * @param {Array<any>} args The arguments that are applied to the event listener.\n     */\n    emit(name, args2) {\n      return from3((this._observers.get(name) || create8()).values()).forEach((f) => f(...args2));\n    }\n    destroy() {\n      this._observers = create8();\n    }\n  };\n  var keys3 = Object.keys;\n  var length3 = (obj) => keys3(obj).length;\n  var hasProperty2 = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);\n  var equalityStrict = (a, b) => a === b;\n  var equalityDeep2 = (a, b) => {\n    if (a == null || b == null) {\n      return equalityStrict(a, b);\n    }\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n    if (a === b) {\n      return true;\n    }\n    switch (a.constructor) {\n      case ArrayBuffer:\n        a = new Uint8Array(a);\n        b = new Uint8Array(b);\n      // eslint-disable-next-line no-fallthrough\n      case Uint8Array: {\n        if (a.byteLength !== b.byteLength) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          if (a[i] !== b[i]) {\n            return false;\n          }\n        }\n        break;\n      }\n      case Set: {\n        if (a.size !== b.size) {\n          return false;\n        }\n        for (const value of a) {\n          if (!b.has(value)) {\n            return false;\n          }\n        }\n        break;\n      }\n      case Map: {\n        if (a.size !== b.size) {\n          return false;\n        }\n        for (const key of a.keys()) {\n          if (!b.has(key) || !equalityDeep2(a.get(key), b.get(key))) {\n            return false;\n          }\n        }\n        break;\n      }\n      case Object:\n        if (length3(a) !== length3(b)) {\n          return false;\n        }\n        for (const key in a) {\n          if (!hasProperty2(a, key) || !equalityDeep2(a[key], b[key])) {\n            return false;\n          }\n        }\n        break;\n      case Array:\n        if (a.length !== b.length) {\n          return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n          if (!equalityDeep2(a[i], b[i])) {\n            return false;\n          }\n        }\n        break;\n      default:\n        return false;\n    }\n    return true;\n  };\n  var outdatedTimeout2 = 3e4;\n  var Awareness2 = class extends Observable2 {\n    /**\n     * @param {Y.Doc} doc\n     */\n    constructor(doc4) {\n      super();\n      this.doc = doc4;\n      this.clientID = doc4.clientID;\n      this.states = /* @__PURE__ */ new Map();\n      this.meta = /* @__PURE__ */ new Map();\n      this._checkInterval = /** @type {any} */\n      setInterval(() => {\n        const now = getUnixTime2();\n        if (this.getLocalState() !== null && outdatedTimeout2 / 2 <= now - /** @type {{lastUpdated:number}} */\n        this.meta.get(this.clientID).lastUpdated) {\n          this.setLocalState(this.getLocalState());\n        }\n        const remove = [];\n        this.meta.forEach((meta, clientid) => {\n          if (clientid !== this.clientID && outdatedTimeout2 <= now - meta.lastUpdated && this.states.has(clientid)) {\n            remove.push(clientid);\n          }\n        });\n        if (remove.length > 0) {\n          removeAwarenessStates2(this, remove, \"timeout\");\n        }\n      }, floor3(outdatedTimeout2 / 10));\n      doc4.on(\"destroy\", () => {\n        this.destroy();\n      });\n      this.setLocalState({});\n    }\n    destroy() {\n      this.emit(\"destroy\", [this]);\n      this.setLocalState(null);\n      super.destroy();\n      clearInterval(this._checkInterval);\n    }\n    /**\n     * @return {Object<string,any>|null}\n     */\n    getLocalState() {\n      return this.states.get(this.clientID) || null;\n    }\n    /**\n     * @param {Object<string,any>|null} state\n     */\n    setLocalState(state) {\n      const clientID = this.clientID;\n      const currLocalMeta = this.meta.get(clientID);\n      const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;\n      const prevState = this.states.get(clientID);\n      if (state === null) {\n        this.states.delete(clientID);\n      } else {\n        this.states.set(clientID, state);\n      }\n      this.meta.set(clientID, {\n        clock,\n        lastUpdated: getUnixTime2()\n      });\n      const added = [];\n      const updated = [];\n      const filteredUpdated = [];\n      const removed = [];\n      if (state === null) {\n        removed.push(clientID);\n      } else if (prevState == null) {\n        if (state != null) {\n          added.push(clientID);\n        }\n      } else {\n        updated.push(clientID);\n        if (!equalityDeep2(prevState, state)) {\n          filteredUpdated.push(clientID);\n        }\n      }\n      if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n        this.emit(\"change\", [{ added, updated: filteredUpdated, removed }, \"local\"]);\n      }\n      this.emit(\"update\", [{ added, updated, removed }, \"local\"]);\n    }\n    /**\n     * @param {string} field\n     * @param {any} value\n     */\n    setLocalStateField(field, value) {\n      const state = this.getLocalState();\n      if (state !== null) {\n        this.setLocalState({\n          ...state,\n          [field]: value\n        });\n      }\n    }\n    /**\n     * @return {Map<number,Object<string,any>>}\n     */\n    getStates() {\n      return this.states;\n    }\n  };\n  var removeAwarenessStates2 = (awareness, clients, origin) => {\n    const removed = [];\n    for (let i = 0; i < clients.length; i++) {\n      const clientID = clients[i];\n      if (awareness.states.has(clientID)) {\n        awareness.states.delete(clientID);\n        if (clientID === awareness.clientID) {\n          const curMeta = (\n            /** @type {MetaClientState} */\n            awareness.meta.get(clientID)\n          );\n          awareness.meta.set(clientID, {\n            clock: curMeta.clock + 1,\n            lastUpdated: getUnixTime2()\n          });\n        }\n        removed.push(clientID);\n      }\n    }\n    if (removed.length > 0) {\n      awareness.emit(\"change\", [{ added: [], updated: [], removed }, origin]);\n      awareness.emit(\"update\", [{ added: [], updated: [], removed }, origin]);\n    }\n  };\n  var encodeAwarenessUpdate2 = (awareness, clients, states = awareness.states) => {\n    const len = clients.length;\n    const encoder = createEncoder2();\n    writeVarUint3(encoder, len);\n    for (let i = 0; i < len; i++) {\n      const clientID = clients[i];\n      const state = states.get(clientID) || null;\n      const clock = (\n        /** @type {MetaClientState} */\n        awareness.meta.get(clientID).clock\n      );\n      writeVarUint3(encoder, clientID);\n      writeVarUint3(encoder, clock);\n      writeVarString3(encoder, JSON.stringify(state));\n    }\n    return toUint8Array2(encoder);\n  };\n  var applyAwarenessUpdate2 = (awareness, update, origin) => {\n    const decoder = createDecoder2(update);\n    const timestamp = getUnixTime2();\n    const added = [];\n    const updated = [];\n    const filteredUpdated = [];\n    const removed = [];\n    const len = readVarUint3(decoder);\n    for (let i = 0; i < len; i++) {\n      const clientID = readVarUint3(decoder);\n      let clock = readVarUint3(decoder);\n      const state = JSON.parse(readVarString3(decoder));\n      const clientMeta = awareness.meta.get(clientID);\n      const prevState = awareness.states.get(clientID);\n      const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;\n      if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {\n        if (state === null) {\n          if (clientID === awareness.clientID && awareness.getLocalState() != null) {\n            clock++;\n          } else {\n            awareness.states.delete(clientID);\n          }\n        } else {\n          awareness.states.set(clientID, state);\n        }\n        awareness.meta.set(clientID, {\n          clock,\n          lastUpdated: timestamp\n        });\n        if (clientMeta === void 0 && state !== null) {\n          added.push(clientID);\n        } else if (clientMeta !== void 0 && state === null) {\n          removed.push(clientID);\n        } else if (state !== null) {\n          if (!equalityDeep2(state, prevState)) {\n            filteredUpdated.push(clientID);\n          }\n          updated.push(clientID);\n        }\n      }\n    }\n    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {\n      awareness.emit(\"change\", [{\n        added,\n        updated: filteredUpdated,\n        removed\n      }, origin]);\n    }\n    if (added.length > 0 || updated.length > 0 || removed.length > 0) {\n      awareness.emit(\"update\", [{\n        added,\n        updated,\n        removed\n      }, origin]);\n    }\n  };\n  var EventEmitter = class {\n    constructor() {\n      this.callbacks = {};\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    on(event, fn) {\n      if (!this.callbacks[event]) {\n        this.callbacks[event] = [];\n      }\n      this.callbacks[event].push(fn);\n      return this;\n    }\n    emit(event, ...args2) {\n      const callbacks = this.callbacks[event];\n      if (callbacks) {\n        callbacks.forEach((callback) => callback.apply(this, args2));\n      }\n      return this;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    off(event, fn) {\n      const callbacks = this.callbacks[event];\n      if (callbacks) {\n        if (fn) {\n          this.callbacks[event] = callbacks.filter((callback) => callback !== fn);\n        } else {\n          delete this.callbacks[event];\n        }\n      }\n      return this;\n    }\n    removeAllListeners() {\n      this.callbacks = {};\n    }\n  };\n  var IncomingMessage = class {\n    constructor(data) {\n      this.data = data;\n      this.encoder = createEncoder2();\n      this.decoder = createDecoder2(new Uint8Array(this.data));\n    }\n    peekVarString() {\n      return peekVarString(this.decoder);\n    }\n    readVarUint() {\n      return readVarUint3(this.decoder);\n    }\n    readVarString() {\n      return readVarString3(this.decoder);\n    }\n    readVarUint8Array() {\n      return readVarUint8Array3(this.decoder);\n    }\n    writeVarUint(type) {\n      return writeVarUint3(this.encoder, type);\n    }\n    writeVarString(string) {\n      return writeVarString3(this.encoder, string);\n    }\n    writeVarUint8Array(data) {\n      return writeVarUint8Array3(this.encoder, data);\n    }\n    length() {\n      return length$1(this.encoder);\n    }\n  };\n  var MessageType;\n  (function(MessageType2) {\n    MessageType2[MessageType2[\"Sync\"] = 0] = \"Sync\";\n    MessageType2[MessageType2[\"Awareness\"] = 1] = \"Awareness\";\n    MessageType2[MessageType2[\"Auth\"] = 2] = \"Auth\";\n    MessageType2[MessageType2[\"QueryAwareness\"] = 3] = \"QueryAwareness\";\n    MessageType2[MessageType2[\"Stateless\"] = 5] = \"Stateless\";\n    MessageType2[MessageType2[\"CLOSE\"] = 7] = \"CLOSE\";\n    MessageType2[MessageType2[\"SyncStatus\"] = 8] = \"SyncStatus\";\n  })(MessageType || (MessageType = {}));\n  var WebSocketStatus;\n  (function(WebSocketStatus2) {\n    WebSocketStatus2[\"Connecting\"] = \"connecting\";\n    WebSocketStatus2[\"Connected\"] = \"connected\";\n    WebSocketStatus2[\"Disconnected\"] = \"disconnected\";\n  })(WebSocketStatus || (WebSocketStatus = {}));\n  var OutgoingMessage = class {\n    constructor() {\n      this.encoder = createEncoder2();\n    }\n    get(args2) {\n      return args2.encoder;\n    }\n    toUint8Array() {\n      return toUint8Array2(this.encoder);\n    }\n  };\n  var CloseMessage = class extends OutgoingMessage {\n    constructor() {\n      super(...arguments);\n      this.type = MessageType.CLOSE;\n      this.description = \"Ask the server to close the connection\";\n    }\n    get(args2) {\n      writeVarString3(this.encoder, args2.documentName);\n      writeVarUint3(this.encoder, this.type);\n      return this.encoder;\n    }\n  };\n  var HocuspocusProviderWebsocket = class extends EventEmitter {\n    constructor(configuration) {\n      super();\n      this.messageQueue = [];\n      this.configuration = {\n        url: \"\",\n        autoConnect: true,\n        // @ts-ignore\n        document: void 0,\n        WebSocketPolyfill: void 0,\n        // TODO: this should depend on awareness.outdatedTime\n        messageReconnectTimeout: 3e4,\n        // 1 second\n        delay: 1e3,\n        // instant\n        initialDelay: 0,\n        // double the delay each time\n        factor: 2,\n        // unlimited retries\n        maxAttempts: 0,\n        // wait at least 1 second\n        minDelay: 1e3,\n        // at least every 30 seconds\n        maxDelay: 3e4,\n        // randomize\n        jitter: true,\n        // retry forever\n        timeout: 0,\n        onOpen: () => null,\n        onConnect: () => null,\n        onMessage: () => null,\n        onOutgoingMessage: () => null,\n        onStatus: () => null,\n        onDisconnect: () => null,\n        onClose: () => null,\n        onDestroy: () => null,\n        onAwarenessUpdate: () => null,\n        onAwarenessChange: () => null,\n        handleTimeout: null,\n        providerMap: /* @__PURE__ */ new Map()\n      };\n      this.webSocket = null;\n      this.webSocketHandlers = {};\n      this.shouldConnect = true;\n      this.status = WebSocketStatus.Disconnected;\n      this.lastMessageReceived = 0;\n      this.identifier = 0;\n      this.intervals = {\n        connectionChecker: null\n      };\n      this.connectionAttempt = null;\n      this.receivedOnOpenPayload = void 0;\n      this.closeTries = 0;\n      this.setConfiguration(configuration);\n      this.configuration.WebSocketPolyfill = configuration.WebSocketPolyfill ? configuration.WebSocketPolyfill : WebSocket;\n      this.on(\"open\", this.configuration.onOpen);\n      this.on(\"open\", this.onOpen.bind(this));\n      this.on(\"connect\", this.configuration.onConnect);\n      this.on(\"message\", this.configuration.onMessage);\n      this.on(\"outgoingMessage\", this.configuration.onOutgoingMessage);\n      this.on(\"status\", this.configuration.onStatus);\n      this.on(\"disconnect\", this.configuration.onDisconnect);\n      this.on(\"close\", this.configuration.onClose);\n      this.on(\"destroy\", this.configuration.onDestroy);\n      this.on(\"awarenessUpdate\", this.configuration.onAwarenessUpdate);\n      this.on(\"awarenessChange\", this.configuration.onAwarenessChange);\n      this.on(\"close\", this.onClose.bind(this));\n      this.on(\"message\", this.onMessage.bind(this));\n      this.intervals.connectionChecker = setInterval(this.checkConnection.bind(this), this.configuration.messageReconnectTimeout / 10);\n      if (this.shouldConnect) {\n        this.connect();\n      }\n    }\n    async onOpen(event) {\n      this.status = WebSocketStatus.Connected;\n      this.emit(\"status\", { status: WebSocketStatus.Connected });\n      this.cancelWebsocketRetry = void 0;\n      this.receivedOnOpenPayload = event;\n    }\n    attach(provider) {\n      this.configuration.providerMap.set(provider.configuration.name, provider);\n      if (this.status === WebSocketStatus.Disconnected && this.shouldConnect) {\n        this.connect();\n      }\n      if (this.receivedOnOpenPayload && this.status === WebSocketStatus.Connected) {\n        provider.onOpen(this.receivedOnOpenPayload);\n      }\n    }\n    detach(provider) {\n      if (this.configuration.providerMap.has(provider.configuration.name)) {\n        provider.send(CloseMessage, {\n          documentName: provider.configuration.name\n        });\n        this.configuration.providerMap.delete(provider.configuration.name);\n      }\n    }\n    setConfiguration(configuration = {}) {\n      this.configuration = { ...this.configuration, ...configuration };\n      if (!this.configuration.autoConnect) {\n        this.shouldConnect = false;\n      }\n    }\n    async connect() {\n      if (this.status === WebSocketStatus.Connected) {\n        return;\n      }\n      if (this.cancelWebsocketRetry) {\n        this.cancelWebsocketRetry();\n        this.cancelWebsocketRetry = void 0;\n      }\n      this.receivedOnOpenPayload = void 0;\n      this.shouldConnect = true;\n      const abortableRetry = () => {\n        let cancelAttempt = false;\n        const retryPromise2 = retry(this.createWebSocketConnection.bind(this), {\n          delay: this.configuration.delay,\n          initialDelay: this.configuration.initialDelay,\n          factor: this.configuration.factor,\n          maxAttempts: this.configuration.maxAttempts,\n          minDelay: this.configuration.minDelay,\n          maxDelay: this.configuration.maxDelay,\n          jitter: this.configuration.jitter,\n          timeout: this.configuration.timeout,\n          handleTimeout: this.configuration.handleTimeout,\n          beforeAttempt: (context) => {\n            if (!this.shouldConnect || cancelAttempt) {\n              context.abort();\n            }\n          }\n        }).catch((error) => {\n          if (error && error.code !== \"ATTEMPT_ABORTED\") {\n            throw error;\n          }\n        });\n        return {\n          retryPromise: retryPromise2,\n          cancelFunc: () => {\n            cancelAttempt = true;\n          }\n        };\n      };\n      const { retryPromise, cancelFunc } = abortableRetry();\n      this.cancelWebsocketRetry = cancelFunc;\n      return retryPromise;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    attachWebSocketListeners(ws, reject) {\n      const { identifier } = ws;\n      const onMessageHandler = (payload) => this.emit(\"message\", payload);\n      const onCloseHandler = (payload) => this.emit(\"close\", { event: payload });\n      const onOpenHandler = (payload) => this.emit(\"open\", payload);\n      const onErrorHandler = (err) => {\n        reject(err);\n      };\n      this.webSocketHandlers[identifier] = {\n        message: onMessageHandler,\n        close: onCloseHandler,\n        open: onOpenHandler,\n        error: onErrorHandler\n      };\n      const handlers2 = this.webSocketHandlers[ws.identifier];\n      Object.keys(handlers2).forEach((name) => {\n        ws.addEventListener(name, handlers2[name]);\n      });\n    }\n    cleanupWebSocket() {\n      if (!this.webSocket) {\n        return;\n      }\n      const { identifier } = this.webSocket;\n      const handlers2 = this.webSocketHandlers[identifier];\n      Object.keys(handlers2).forEach((name) => {\n        var _a;\n        (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.removeEventListener(name, handlers2[name]);\n        delete this.webSocketHandlers[identifier];\n      });\n      this.webSocket.close();\n      this.webSocket = null;\n    }\n    createWebSocketConnection() {\n      return new Promise((resolve, reject) => {\n        if (this.webSocket) {\n          this.messageQueue = [];\n          this.cleanupWebSocket();\n        }\n        this.lastMessageReceived = 0;\n        this.identifier += 1;\n        const ws = new this.configuration.WebSocketPolyfill(this.url);\n        ws.binaryType = \"arraybuffer\";\n        ws.identifier = this.identifier;\n        this.attachWebSocketListeners(ws, reject);\n        this.webSocket = ws;\n        this.status = WebSocketStatus.Connecting;\n        this.emit(\"status\", { status: WebSocketStatus.Connecting });\n        this.connectionAttempt = {\n          resolve,\n          reject\n        };\n      });\n    }\n    onMessage(event) {\n      var _a;\n      this.resolveConnectionAttempt();\n      this.lastMessageReceived = getUnixTime2();\n      const message = new IncomingMessage(event.data);\n      const documentName = message.peekVarString();\n      (_a = this.configuration.providerMap.get(documentName)) === null || _a === void 0 ? void 0 : _a.onMessage(event);\n    }\n    resolveConnectionAttempt() {\n      if (this.connectionAttempt) {\n        this.connectionAttempt.resolve();\n        this.connectionAttempt = null;\n        this.status = WebSocketStatus.Connected;\n        this.emit(\"status\", { status: WebSocketStatus.Connected });\n        this.emit(\"connect\");\n        this.messageQueue.forEach((message) => this.send(message));\n        this.messageQueue = [];\n      }\n    }\n    stopConnectionAttempt() {\n      this.connectionAttempt = null;\n    }\n    rejectConnectionAttempt() {\n      var _a;\n      (_a = this.connectionAttempt) === null || _a === void 0 ? void 0 : _a.reject();\n      this.connectionAttempt = null;\n    }\n    checkConnection() {\n      var _a;\n      if (this.status !== WebSocketStatus.Connected) {\n        return;\n      }\n      if (!this.lastMessageReceived) {\n        return;\n      }\n      if (this.configuration.messageReconnectTimeout >= getUnixTime2() - this.lastMessageReceived) {\n        return;\n      }\n      this.closeTries += 1;\n      if (this.closeTries > 2) {\n        this.onClose({\n          event: {\n            code: 4408,\n            reason: \"forced\"\n          }\n        });\n        this.closeTries = 0;\n      } else {\n        (_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.close();\n        this.messageQueue = [];\n      }\n    }\n    // Ensure that the URL never ends with /\n    get serverUrl() {\n      while (this.configuration.url[this.configuration.url.length - 1] === \"/\") {\n        return this.configuration.url.slice(0, this.configuration.url.length - 1);\n      }\n      return this.configuration.url;\n    }\n    get url() {\n      return this.serverUrl;\n    }\n    disconnect() {\n      this.shouldConnect = false;\n      if (this.webSocket === null) {\n        return;\n      }\n      try {\n        this.webSocket.close();\n        this.messageQueue = [];\n      } catch (e) {\n        console.error(e);\n      }\n    }\n    send(message) {\n      var _a;\n      if (((_a = this.webSocket) === null || _a === void 0 ? void 0 : _a.readyState) === WsReadyStates.Open) {\n        this.webSocket.send(message);\n      } else {\n        this.messageQueue.push(message);\n      }\n    }\n    onClose({ event }) {\n      this.closeTries = 0;\n      this.cleanupWebSocket();\n      if (this.connectionAttempt) {\n        this.rejectConnectionAttempt();\n      }\n      this.status = WebSocketStatus.Disconnected;\n      this.emit(\"status\", { status: WebSocketStatus.Disconnected });\n      this.emit(\"disconnect\", { event });\n      if (!this.cancelWebsocketRetry && this.shouldConnect) {\n        setTimeout(() => {\n          this.connect();\n        }, this.configuration.delay);\n      }\n    }\n    destroy() {\n      this.emit(\"destroy\");\n      clearInterval(this.intervals.connectionChecker);\n      this.stopConnectionAttempt();\n      this.disconnect();\n      this.removeAllListeners();\n      this.cleanupWebSocket();\n    }\n  };\n  var messageYjsSyncStep1 = 0;\n  var messageYjsSyncStep2 = 1;\n  var messageYjsUpdate = 2;\n  var writeSyncStep1 = (encoder, doc4) => {\n    writeVarUint3(encoder, messageYjsSyncStep1);\n    const sv = encodeStateVector(doc4);\n    writeVarUint8Array3(encoder, sv);\n  };\n  var writeSyncStep2 = (encoder, doc4, encodedStateVector) => {\n    writeVarUint3(encoder, messageYjsSyncStep2);\n    writeVarUint8Array3(encoder, encodeStateAsUpdate(doc4, encodedStateVector));\n  };\n  var readSyncStep1 = (decoder, encoder, doc4) => writeSyncStep2(encoder, doc4, readVarUint8Array3(decoder));\n  var readSyncStep2 = (decoder, doc4, transactionOrigin) => {\n    try {\n      applyUpdate(doc4, readVarUint8Array3(decoder), transactionOrigin);\n    } catch (error) {\n      console.error(\"Caught error while handling a Yjs update\", error);\n    }\n  };\n  var writeUpdate = (encoder, update) => {\n    writeVarUint3(encoder, messageYjsUpdate);\n    writeVarUint8Array3(encoder, update);\n  };\n  var readUpdate2 = readSyncStep2;\n  var readSyncMessage = (decoder, encoder, doc4, transactionOrigin) => {\n    const messageType = readVarUint3(decoder);\n    switch (messageType) {\n      case messageYjsSyncStep1:\n        readSyncStep1(decoder, encoder, doc4);\n        break;\n      case messageYjsSyncStep2:\n        readSyncStep2(decoder, doc4, transactionOrigin);\n        break;\n      case messageYjsUpdate:\n        readUpdate2(decoder, doc4, transactionOrigin);\n        break;\n      default:\n        throw new Error(\"Unknown message type\");\n    }\n    return messageType;\n  };\n  var MessageReceiver = class {\n    constructor(message) {\n      this.message = message;\n    }\n    apply(provider, emitSynced) {\n      const { message } = this;\n      const type = message.readVarUint();\n      const emptyMessageLength = message.length();\n      switch (type) {\n        case MessageType.Sync:\n          this.applySyncMessage(provider, emitSynced);\n          break;\n        case MessageType.Awareness:\n          this.applyAwarenessMessage(provider);\n          break;\n        case MessageType.Auth:\n          this.applyAuthMessage(provider);\n          break;\n        case MessageType.QueryAwareness:\n          this.applyQueryAwarenessMessage(provider);\n          break;\n        case MessageType.Stateless:\n          provider.receiveStateless(readVarString3(message.decoder));\n          break;\n        case MessageType.SyncStatus:\n          this.applySyncStatusMessage(provider, readVarInt2(message.decoder) === 1);\n          break;\n        case MessageType.CLOSE:\n          const event = {\n            code: 1e3,\n            reason: readVarString3(message.decoder),\n            // @ts-ignore\n            target: provider.configuration.websocketProvider.webSocket,\n            type: \"close\"\n          };\n          provider.onClose();\n          provider.configuration.onClose({ event });\n          provider.forwardClose(event);\n          break;\n        default:\n          throw new Error(`Can\\u2019t apply message of unknown type: ${type}`);\n      }\n      if (message.length() > emptyMessageLength + 1) {\n        provider.send(OutgoingMessage, { encoder: message.encoder });\n      }\n    }\n    applySyncMessage(provider, emitSynced) {\n      const { message } = this;\n      message.writeVarUint(MessageType.Sync);\n      const syncMessageType = readSyncMessage(message.decoder, message.encoder, provider.document, provider);\n      if (emitSynced && syncMessageType === messageYjsSyncStep2) {\n        provider.synced = true;\n      }\n    }\n    applySyncStatusMessage(provider, applied) {\n      if (applied) {\n        provider.decrementUnsyncedChanges();\n      }\n    }\n    applyAwarenessMessage(provider) {\n      if (!provider.awareness)\n        return;\n      const { message } = this;\n      applyAwarenessUpdate2(provider.awareness, message.readVarUint8Array(), provider);\n    }\n    applyAuthMessage(provider) {\n      const { message } = this;\n      readAuthMessage(message.decoder, provider.sendToken.bind(provider), provider.permissionDeniedHandler.bind(provider), provider.authenticatedHandler.bind(provider));\n    }\n    applyQueryAwarenessMessage(provider) {\n      if (!provider.awareness)\n        return;\n      const { message } = this;\n      message.writeVarUint(MessageType.Awareness);\n      message.writeVarUint8Array(encodeAwarenessUpdate2(provider.awareness, Array.from(provider.awareness.getStates().keys())));\n    }\n  };\n  var MessageSender = class {\n    constructor(Message, args2 = {}) {\n      this.message = new Message();\n      this.encoder = this.message.get(args2);\n    }\n    create() {\n      return toUint8Array2(this.encoder);\n    }\n    send(webSocket) {\n      webSocket === null || webSocket === void 0 ? void 0 : webSocket.send(this.create());\n    }\n  };\n  var AuthenticationMessage = class extends OutgoingMessage {\n    constructor() {\n      super(...arguments);\n      this.type = MessageType.Auth;\n      this.description = \"Authentication\";\n    }\n    get(args2) {\n      if (typeof args2.token === \"undefined\") {\n        throw new Error(\"The authentication message requires `token` as an argument.\");\n      }\n      writeVarString3(this.encoder, args2.documentName);\n      writeVarUint3(this.encoder, this.type);\n      writeAuthentication(this.encoder, args2.token);\n      return this.encoder;\n    }\n  };\n  var AwarenessMessage = class extends OutgoingMessage {\n    constructor() {\n      super(...arguments);\n      this.type = MessageType.Awareness;\n      this.description = \"Awareness states update\";\n    }\n    get(args2) {\n      if (typeof args2.awareness === \"undefined\") {\n        throw new Error(\"The awareness message requires awareness as an argument\");\n      }\n      if (typeof args2.clients === \"undefined\") {\n        throw new Error(\"The awareness message requires clients as an argument\");\n      }\n      writeVarString3(this.encoder, args2.documentName);\n      writeVarUint3(this.encoder, this.type);\n      let awarenessUpdate;\n      if (args2.states === void 0) {\n        awarenessUpdate = encodeAwarenessUpdate2(args2.awareness, args2.clients);\n      } else {\n        awarenessUpdate = encodeAwarenessUpdate2(args2.awareness, args2.clients, args2.states);\n      }\n      writeVarUint8Array3(this.encoder, awarenessUpdate);\n      return this.encoder;\n    }\n  };\n  var StatelessMessage = class extends OutgoingMessage {\n    constructor() {\n      super(...arguments);\n      this.type = MessageType.Stateless;\n      this.description = \"A stateless message\";\n    }\n    get(args2) {\n      var _a;\n      writeVarString3(this.encoder, args2.documentName);\n      writeVarUint3(this.encoder, this.type);\n      writeVarString3(this.encoder, (_a = args2.payload) !== null && _a !== void 0 ? _a : \"\");\n      return this.encoder;\n    }\n  };\n  var SyncStepOneMessage = class extends OutgoingMessage {\n    constructor() {\n      super(...arguments);\n      this.type = MessageType.Sync;\n      this.description = \"First sync step\";\n    }\n    get(args2) {\n      if (typeof args2.document === \"undefined\") {\n        throw new Error(\"The sync step one message requires document as an argument\");\n      }\n      writeVarString3(this.encoder, args2.documentName);\n      writeVarUint3(this.encoder, this.type);\n      writeSyncStep1(this.encoder, args2.document);\n      return this.encoder;\n    }\n  };\n  var UpdateMessage = class extends OutgoingMessage {\n    constructor() {\n      super(...arguments);\n      this.type = MessageType.Sync;\n      this.description = \"A document update\";\n    }\n    get(args2) {\n      writeVarString3(this.encoder, args2.documentName);\n      writeVarUint3(this.encoder, this.type);\n      writeUpdate(this.encoder, args2.update);\n      return this.encoder;\n    }\n  };\n  var AwarenessError = class extends Error {\n    constructor() {\n      super(...arguments);\n      this.code = 1001;\n    }\n  };\n  var HocuspocusProvider = class extends EventEmitter {\n    constructor(configuration) {\n      var _a, _b, _c;\n      super();\n      this.configuration = {\n        name: \"\",\n        // @ts-ignore\n        document: void 0,\n        // @ts-ignore\n        awareness: void 0,\n        token: null,\n        forceSyncInterval: false,\n        onAuthenticated: () => null,\n        onAuthenticationFailed: () => null,\n        onOpen: () => null,\n        onConnect: () => null,\n        onMessage: () => null,\n        onOutgoingMessage: () => null,\n        onSynced: () => null,\n        onStatus: () => null,\n        onDisconnect: () => null,\n        onClose: () => null,\n        onDestroy: () => null,\n        onAwarenessUpdate: () => null,\n        onAwarenessChange: () => null,\n        onStateless: () => null,\n        onUnsyncedChanges: () => null\n      };\n      this.isSynced = false;\n      this.unsyncedChanges = 0;\n      this.isAuthenticated = false;\n      this.authorizedScope = void 0;\n      this.manageSocket = false;\n      this._isAttached = false;\n      this.intervals = {\n        forceSync: null\n      };\n      this.boundDocumentUpdateHandler = this.documentUpdateHandler.bind(this);\n      this.boundAwarenessUpdateHandler = this.awarenessUpdateHandler.bind(this);\n      this.boundPageHide = this.pageHide.bind(this);\n      this.boundOnOpen = this.onOpen.bind(this);\n      this.boundOnClose = this.onClose.bind(this);\n      this.forwardConnect = () => this.emit(\"connect\");\n      this.forwardStatus = (e) => this.emit(\"status\", e);\n      this.forwardClose = (e) => this.emit(\"close\", e);\n      this.forwardDisconnect = (e) => this.emit(\"disconnect\", e);\n      this.forwardDestroy = () => this.emit(\"destroy\");\n      this.setConfiguration(configuration);\n      this.configuration.document = configuration.document ? configuration.document : new Doc();\n      this.configuration.awareness = configuration.awareness !== void 0 ? configuration.awareness : new Awareness2(this.document);\n      this.on(\"open\", this.configuration.onOpen);\n      this.on(\"message\", this.configuration.onMessage);\n      this.on(\"outgoingMessage\", this.configuration.onOutgoingMessage);\n      this.on(\"synced\", this.configuration.onSynced);\n      this.on(\"destroy\", this.configuration.onDestroy);\n      this.on(\"awarenessUpdate\", this.configuration.onAwarenessUpdate);\n      this.on(\"awarenessChange\", this.configuration.onAwarenessChange);\n      this.on(\"stateless\", this.configuration.onStateless);\n      this.on(\"unsyncedChanges\", this.configuration.onUnsyncedChanges);\n      this.on(\"authenticated\", this.configuration.onAuthenticated);\n      this.on(\"authenticationFailed\", this.configuration.onAuthenticationFailed);\n      (_a = this.awareness) === null || _a === void 0 ? void 0 : _a.on(\"update\", () => {\n        this.emit(\"awarenessUpdate\", {\n          states: awarenessStatesToArray(this.awareness.getStates())\n        });\n      });\n      (_b = this.awareness) === null || _b === void 0 ? void 0 : _b.on(\"change\", () => {\n        this.emit(\"awarenessChange\", {\n          states: awarenessStatesToArray(this.awareness.getStates())\n        });\n      });\n      this.document.on(\"update\", this.boundDocumentUpdateHandler);\n      (_c = this.awareness) === null || _c === void 0 ? void 0 : _c.on(\"update\", this.boundAwarenessUpdateHandler);\n      this.registerEventListeners();\n      if (this.configuration.forceSyncInterval && typeof this.configuration.forceSyncInterval === \"number\") {\n        this.intervals.forceSync = setInterval(this.forceSync.bind(this), this.configuration.forceSyncInterval);\n      }\n      if (this.manageSocket) {\n        this.attach();\n      }\n    }\n    setConfiguration(configuration = {}) {\n      if (!configuration.websocketProvider) {\n        const websocketProviderConfig = configuration;\n        this.manageSocket = true;\n        this.configuration.websocketProvider = new HocuspocusProviderWebsocket({\n          url: websocketProviderConfig.url\n        });\n      }\n      this.configuration = { ...this.configuration, ...configuration };\n    }\n    get document() {\n      return this.configuration.document;\n    }\n    get isAttached() {\n      return this._isAttached;\n    }\n    get awareness() {\n      return this.configuration.awareness;\n    }\n    get hasUnsyncedChanges() {\n      return this.unsyncedChanges > 0;\n    }\n    resetUnsyncedChanges() {\n      this.unsyncedChanges = 1;\n      this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    incrementUnsyncedChanges() {\n      this.unsyncedChanges += 1;\n      this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    decrementUnsyncedChanges() {\n      if (this.unsyncedChanges > 0) {\n        this.unsyncedChanges -= 1;\n      }\n      if (this.unsyncedChanges === 0) {\n        this.synced = true;\n      }\n      this.emit(\"unsyncedChanges\", { number: this.unsyncedChanges });\n    }\n    forceSync() {\n      this.resetUnsyncedChanges();\n      this.send(SyncStepOneMessage, {\n        document: this.document,\n        documentName: this.configuration.name\n      });\n    }\n    pageHide() {\n      if (this.awareness) {\n        removeAwarenessStates2(this.awareness, [this.document.clientID], \"page hide\");\n      }\n    }\n    registerEventListeners() {\n      if (typeof window === \"undefined\" || !(\"addEventListener\" in window)) {\n        return;\n      }\n      window.addEventListener(\"pagehide\", this.boundPageHide);\n    }\n    sendStateless(payload) {\n      this.send(StatelessMessage, {\n        documentName: this.configuration.name,\n        payload\n      });\n    }\n    async sendToken() {\n      let token;\n      try {\n        token = await this.getToken();\n      } catch (error) {\n        this.permissionDeniedHandler(`Failed to get token during sendToken(): ${error}`);\n        return;\n      }\n      this.send(AuthenticationMessage, {\n        token: token !== null && token !== void 0 ? token : \"\",\n        documentName: this.configuration.name\n      });\n    }\n    documentUpdateHandler(update, origin) {\n      if (origin === this) {\n        return;\n      }\n      this.incrementUnsyncedChanges();\n      this.send(UpdateMessage, { update, documentName: this.configuration.name });\n    }\n    awarenessUpdateHandler({ added, updated, removed }, origin) {\n      const changedClients = added.concat(updated).concat(removed);\n      this.send(AwarenessMessage, {\n        awareness: this.awareness,\n        clients: changedClients,\n        documentName: this.configuration.name\n      });\n    }\n    /**\n     * Indicates whether a first handshake with the server has been established\n     *\n     * Note: this does not mean all updates from the client have been persisted to the backend. For this,\n     * use `hasUnsyncedChanges`.\n     */\n    get synced() {\n      return this.isSynced;\n    }\n    set synced(state) {\n      if (this.isSynced === state) {\n        return;\n      }\n      this.isSynced = state;\n      if (state) {\n        this.emit(\"synced\", { state });\n      }\n    }\n    receiveStateless(payload) {\n      this.emit(\"stateless\", { payload });\n    }\n    // not needed, but provides backward compatibility with e.g. lexical/yjs\n    async connect() {\n      if (this.manageSocket) {\n        return this.configuration.websocketProvider.connect();\n      }\n      console.warn(\"HocuspocusProvider::connect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.\");\n    }\n    disconnect() {\n      if (this.manageSocket) {\n        return this.configuration.websocketProvider.disconnect();\n      }\n      console.warn(\"HocuspocusProvider::disconnect() is deprecated and does not do anything. Please connect/disconnect on the websocketProvider, or attach/deattach providers.\");\n    }\n    async onOpen(event) {\n      this.isAuthenticated = false;\n      this.emit(\"open\", { event });\n      await this.sendToken();\n      this.startSync();\n    }\n    async getToken() {\n      if (typeof this.configuration.token === \"function\") {\n        const token = await this.configuration.token();\n        return token;\n      }\n      return this.configuration.token;\n    }\n    startSync() {\n      this.resetUnsyncedChanges();\n      this.send(SyncStepOneMessage, {\n        document: this.document,\n        documentName: this.configuration.name\n      });\n      if (this.awareness && this.awareness.getLocalState() !== null) {\n        this.send(AwarenessMessage, {\n          awareness: this.awareness,\n          clients: [this.document.clientID],\n          documentName: this.configuration.name\n        });\n      }\n    }\n    send(message, args2) {\n      if (!this._isAttached)\n        return;\n      const messageSender = new MessageSender(message, args2);\n      this.emit(\"outgoingMessage\", { message: messageSender.message });\n      messageSender.send(this.configuration.websocketProvider);\n    }\n    onMessage(event) {\n      const message = new IncomingMessage(event.data);\n      const documentName = message.readVarString();\n      message.writeVarString(documentName);\n      this.emit(\"message\", { event, message: new IncomingMessage(event.data) });\n      new MessageReceiver(message).apply(this, true);\n    }\n    onClose() {\n      this.isAuthenticated = false;\n      this.synced = false;\n      if (this.awareness) {\n        removeAwarenessStates2(this.awareness, Array.from(this.awareness.getStates().keys()).filter((client) => client !== this.document.clientID), this);\n      }\n    }\n    destroy() {\n      this.emit(\"destroy\");\n      if (this.intervals.forceSync) {\n        clearInterval(this.intervals.forceSync);\n      }\n      if (this.awareness) {\n        removeAwarenessStates2(this.awareness, [this.document.clientID], \"provider destroy\");\n        this.awareness.off(\"update\", this.boundAwarenessUpdateHandler);\n        this.awareness.destroy();\n      }\n      this.document.off(\"update\", this.boundDocumentUpdateHandler);\n      this.removeAllListeners();\n      this.detach();\n      if (this.manageSocket) {\n        this.configuration.websocketProvider.destroy();\n      }\n      if (typeof window === \"undefined\" || !(\"removeEventListener\" in window)) {\n        return;\n      }\n      window.removeEventListener(\"pagehide\", this.boundPageHide);\n    }\n    detach() {\n      this.configuration.websocketProvider.off(\"connect\", this.configuration.onConnect);\n      this.configuration.websocketProvider.off(\"connect\", this.forwardConnect);\n      this.configuration.websocketProvider.off(\"status\", this.forwardStatus);\n      this.configuration.websocketProvider.off(\"status\", this.configuration.onStatus);\n      this.configuration.websocketProvider.off(\"open\", this.boundOnOpen);\n      this.configuration.websocketProvider.off(\"close\", this.boundOnClose);\n      this.configuration.websocketProvider.off(\"close\", this.configuration.onClose);\n      this.configuration.websocketProvider.off(\"close\", this.forwardClose);\n      this.configuration.websocketProvider.off(\"disconnect\", this.configuration.onDisconnect);\n      this.configuration.websocketProvider.off(\"disconnect\", this.forwardDisconnect);\n      this.configuration.websocketProvider.off(\"destroy\", this.configuration.onDestroy);\n      this.configuration.websocketProvider.off(\"destroy\", this.forwardDestroy);\n      this.configuration.websocketProvider.detach(this);\n      this._isAttached = false;\n    }\n    attach() {\n      if (this._isAttached)\n        return;\n      this.configuration.websocketProvider.on(\"connect\", this.configuration.onConnect);\n      this.configuration.websocketProvider.on(\"connect\", this.forwardConnect);\n      this.configuration.websocketProvider.on(\"status\", this.configuration.onStatus);\n      this.configuration.websocketProvider.on(\"status\", this.forwardStatus);\n      this.configuration.websocketProvider.on(\"open\", this.boundOnOpen);\n      this.configuration.websocketProvider.on(\"close\", this.boundOnClose);\n      this.configuration.websocketProvider.on(\"close\", this.configuration.onClose);\n      this.configuration.websocketProvider.on(\"close\", this.forwardClose);\n      this.configuration.websocketProvider.on(\"disconnect\", this.configuration.onDisconnect);\n      this.configuration.websocketProvider.on(\"disconnect\", this.forwardDisconnect);\n      this.configuration.websocketProvider.on(\"destroy\", this.configuration.onDestroy);\n      this.configuration.websocketProvider.on(\"destroy\", this.forwardDestroy);\n      this.configuration.websocketProvider.attach(this);\n      this._isAttached = true;\n    }\n    permissionDeniedHandler(reason) {\n      this.emit(\"authenticationFailed\", { reason });\n      this.isAuthenticated = false;\n    }\n    authenticatedHandler(scope) {\n      this.isAuthenticated = true;\n      this.authorizedScope = scope;\n      this.emit(\"authenticated\", { scope });\n    }\n    setAwarenessField(key, value) {\n      if (!this.awareness) {\n        throw new AwarenessError(`Cannot set awareness field \"${key}\" to ${JSON.stringify(value)}. You have disabled Awareness for this provider by explicitly passing awareness: null in the provider configuration.`);\n      }\n      this.awareness.setLocalStateField(key, value);\n    }\n  };\n\n  // assets/prosemirror-collab-plugin.js\n  var collabKey = new PluginKey(\"collab\");\n  var CollabConnection = class {\n    constructor(socket, docId, userId, userName) {\n      this.socket = socket;\n      this.docId = docId;\n      this.userId = userId;\n      this.userName = userName;\n      this.version = 0;\n      this.doc = null;\n      this.users = /* @__PURE__ */ new Map();\n      this.pendingSteps = [];\n      this.view = null;\n      this.isConnected = false;\n      this.setupSocketHandlers();\n    }\n    setupSocketHandlers() {\n      this.socket.on(\"init\", ({ version, doc: doc4, users }) => {\n        console.log(\"[Collab] Received initial state, version:\", version);\n        this.version = version;\n        this.doc = doc4;\n        users.forEach((user) => {\n          this.users.set(user.id, user);\n        });\n        this.isConnected = true;\n        if (this.view && doc4) {\n          this.updateEditorDoc(doc4);\n        }\n      });\n      this.socket.on(\"steps\", ({ steps, clientID, version }) => {\n        console.log(\"[Collab] Received\", steps.length, \"steps from\", clientID);\n        if (this.view) {\n          this.receiveSteps(steps, clientID);\n        }\n        this.version = version;\n      });\n      this.socket.on(\"steps-rejected\", ({ currentVersion, steps }) => {\n        console.log(\"[Collab] Steps rejected, need to rebase from version\", currentVersion);\n        this.version = currentVersion;\n        if (this.pendingSteps.length > 0) {\n          this.sendSteps(this.pendingSteps);\n        }\n      });\n      this.socket.on(\"steps-accepted\", ({ version }) => {\n        console.log(\"[Collab] Steps accepted, new version:\", version);\n        this.version = version;\n        this.pendingSteps = [];\n      });\n      this.socket.on(\"user-joined\", ({ userId, userName, userColor }) => {\n        console.log(\"[Collab] User joined:\", userName);\n        this.users.set(userId, { id: userId, name: userName, color: userColor });\n        if (this.view) {\n          this.view.dispatch(this.view.state.tr);\n        }\n      });\n      this.socket.on(\"user-left\", ({ userId }) => {\n        console.log(\"[Collab] User left:\", userId);\n        this.users.delete(userId);\n        if (this.view) {\n          this.view.dispatch(this.view.state.tr);\n        }\n      });\n      this.socket.on(\"selection\", ({ userId, userName, userColor, from: from4, to }) => {\n        if (this.view && userId !== this.userId) {\n          this.updateUserCursor(userId, userName, userColor, from4, to);\n        }\n      });\n      this.socket.on(\"error\", (error) => {\n        console.error(\"[Collab] Socket error:\", error);\n        this.isConnected = false;\n      });\n      this.socket.on(\"disconnect\", () => {\n        console.log(\"[Collab] Disconnected from server\");\n        this.isConnected = false;\n      });\n    }\n    connect(view) {\n      this.view = view;\n      this.socket.emit(\"join-document\", {\n        documentId: this.docId,\n        clientName: this.userName,\n        initialDoc: view.state.doc.toJSON()\n      });\n    }\n    disconnect() {\n      if (this.socket.connected) {\n        this.socket.disconnect();\n      }\n      this.view = null;\n      this.isConnected = false;\n    }\n    sendSteps(steps) {\n      if (!this.isConnected) {\n        console.warn(\"[Collab] Not connected, queuing steps\");\n        this.pendingSteps.push(...steps);\n        return;\n      }\n      const serializedSteps = steps.map((step) => step.toJSON());\n      console.log(\"[Collab] Sending\", steps.length, \"steps, version:\", this.version);\n      this.socket.emit(\"send-steps\", {\n        version: this.version,\n        steps: serializedSteps,\n        clientID: this.userId\n      });\n      this.pendingSteps = steps;\n    }\n    receiveSteps(stepsJSON, clientID) {\n      if (!this.view) return;\n      try {\n        const { state, dispatch } = this.view;\n        const steps = stepsJSON.map((json) => Step.fromJSON(state.schema, json));\n        let tr = state.tr;\n        steps.forEach((step) => {\n          const result = step.apply(tr.doc);\n          if (result.failed) {\n            console.error(\"[Collab] Failed to apply step:\", result.failed);\n            return;\n          }\n          tr.step(step);\n        });\n        tr.setMeta(\"collab\", {\n          isRemote: true,\n          clientID\n        });\n        dispatch(tr);\n      } catch (error) {\n        console.error(\"[Collab] Error applying received steps:\", error);\n      }\n    }\n    updateEditorDoc(docJSON) {\n      if (!this.view) return;\n      try {\n        const { state, dispatch } = this.view;\n        const doc4 = state.schema.nodeFromJSON(docJSON);\n        const tr = state.tr.replaceWith(0, state.doc.content.size, doc4.content);\n        tr.setMeta(\"collab\", { isRemote: true, isInit: true });\n        dispatch(tr);\n      } catch (error) {\n        console.error(\"[Collab] Error updating document:\", error);\n      }\n    }\n    sendSelection(from4, to) {\n      if (!this.isConnected) return;\n      this.socket.emit(\"selection-changed\", { from: from4, to });\n    }\n    updateUserCursor(userId, userName, userColor, from4, to) {\n      if (!this.view) return;\n      const { state, dispatch } = this.view;\n      let tr = state.tr;\n      tr.setMeta(\"collab\", {\n        cursorUpdate: {\n          userId,\n          userName,\n          userColor,\n          from: from4,\n          to\n        }\n      });\n      dispatch(tr);\n    }\n  };\n  function createCollabPlugin(connection) {\n    return new Plugin({\n      key: collabKey,\n      state: {\n        init() {\n          return {\n            connection,\n            cursors: /* @__PURE__ */ new Map(),\n            decorations: DecorationSet.empty\n          };\n        },\n        apply(tr, value, oldState, newState) {\n          const cursorUpdate = tr.getMeta(\"collab\")?.cursorUpdate;\n          if (cursorUpdate) {\n            value.cursors.set(cursorUpdate.userId, cursorUpdate);\n            const decorations = [];\n            value.cursors.forEach((cursor, userId) => {\n              if (userId !== value.connection.userId) {\n                if (cursor.from === cursor.to) {\n                  const deco = Decoration.widget(cursor.from, () => {\n                    const cursorEl = document.createElement(\"span\");\n                    cursorEl.className = \"collab-cursor\";\n                    cursorEl.style.borderLeftColor = cursor.userColor;\n                    cursorEl.style.borderLeft = `2px solid ${cursor.userColor}`;\n                    cursorEl.style.marginLeft = \"-1px\";\n                    cursorEl.style.marginRight = \"-1px\";\n                    const labelEl = document.createElement(\"span\");\n                    labelEl.className = \"collab-cursor-label\";\n                    labelEl.textContent = cursor.userName;\n                    labelEl.style.backgroundColor = cursor.userColor;\n                    labelEl.style.color = \"white\";\n                    labelEl.style.fontSize = \"11px\";\n                    labelEl.style.padding = \"2px 4px\";\n                    labelEl.style.borderRadius = \"3px\";\n                    labelEl.style.position = \"absolute\";\n                    labelEl.style.bottom = \"100%\";\n                    labelEl.style.left = \"-2px\";\n                    labelEl.style.whiteSpace = \"nowrap\";\n                    labelEl.style.pointerEvents = \"none\";\n                    cursorEl.appendChild(labelEl);\n                    return cursorEl;\n                  }, {\n                    side: 1,\n                    key: `cursor-${userId}`\n                  });\n                  decorations.push(deco);\n                } else {\n                  const deco = Decoration.inline(\n                    cursor.from,\n                    cursor.to,\n                    {\n                      style: `background-color: ${cursor.userColor}33;`,\n                      // 33 = 20% opacity\n                      class: \"collab-selection\"\n                    },\n                    { key: `selection-${userId}` }\n                  );\n                  decorations.push(deco);\n                }\n              }\n            });\n            value.decorations = DecorationSet.create(newState.doc, decorations);\n          }\n          const isRemote = tr.getMeta(\"collab\")?.isRemote;\n          if (!isRemote && tr.docChanged) {\n            const steps = [];\n            for (let i = 0; i < tr.steps.length; i++) {\n              steps.push(tr.steps[i]);\n            }\n            if (steps.length > 0) {\n              value.connection.sendSteps(steps);\n            }\n          }\n          return value;\n        }\n      },\n      props: {\n        decorations(state) {\n          const pluginState = collabKey.getState(state);\n          return pluginState?.decorations || DecorationSet.empty;\n        }\n      },\n      view(view) {\n        const pluginState = collabKey.getState(view.state);\n        const connection2 = pluginState?.connection;\n        if (connection2) {\n          connection2.connect(view);\n          let selectionTimeout;\n          const handleSelectionChange = () => {\n            clearTimeout(selectionTimeout);\n            selectionTimeout = setTimeout(() => {\n              const { from: from4, to } = view.state.selection;\n              connection2.sendSelection(from4, to);\n            }, 100);\n          };\n          const originalUpdateState = view.updateState.bind(view);\n          view.updateState = function(state) {\n            originalUpdateState(state);\n            handleSelectionChange();\n          };\n        }\n        return {\n          destroy() {\n            if (connection2) {\n              connection2.disconnect();\n            }\n          }\n        };\n      }\n    });\n  }\n  function initializeCollaboration(socket, docId, userId, userName) {\n    const connection = new CollabConnection(socket, docId, userId, userName);\n    const plugin = createCollabPlugin(connection);\n    return {\n      connection,\n      plugin\n    };\n  }\n  if (typeof window !== \"undefined\") {\n    window.ProseMirrorCollab = {\n      CollabConnection,\n      createCollabPlugin,\n      initializeCollaboration\n    };\n  }\n\n  // assets/prosemirror-bundle-src.js\n  var mySchema = new Schema({\n    nodes: addListNodes(schema.spec.nodes, \"paragraph block*\", \"block\").addToEnd(\"geoMark\", {\n      inline: true,\n      group: \"inline\",\n      content: \"text*\",\n      attrs: {\n        geoId: { default: null },\n        placeName: { default: \"\" },\n        lat: { default: \"\" },\n        lng: { default: \"\" },\n        colorIndex: { default: 0 },\n        coordSource: { default: \"manual\" },\n        description: { default: null },\n        transportFrom: { default: null },\n        transportProfile: { default: null },\n        waypoints: { default: null },\n        visitDocument: { default: null },\n        photoName: { default: null }\n      },\n      parseDOM: [{\n        tag: \"span.geo-mark\",\n        getAttrs(dom) {\n          return {\n            geoId: dom.getAttribute(\"data-geo-id\"),\n            placeName: dom.getAttribute(\"data-place-name\"),\n            lat: dom.getAttribute(\"data-lat\"),\n            lng: dom.getAttribute(\"data-lng\"),\n            colorIndex: parseInt(dom.getAttribute(\"data-color-index\") || \"0\"),\n            coordSource: dom.getAttribute(\"data-coord-source\") || \"manual\"\n          };\n        }\n      }],\n      toDOM(node) {\n        return [\"span\", {\n          class: \"geo-mark\",\n          \"data-geo-id\": node.attrs.geoId,\n          \"data-place-name\": node.attrs.placeName,\n          \"data-lat\": node.attrs.lat,\n          \"data-lng\": node.attrs.lng,\n          \"data-color-index\": node.attrs.colorIndex,\n          \"data-coord-source\": node.attrs.coordSource\n        }, 0];\n      }\n    }),\n    marks: schema.spec.marks.addToEnd(\"comment\", {\n      attrs: {\n        commentId: { default: null },\n        userId: { default: null },\n        userName: { default: \"\" },\n        content: { default: \"\" },\n        createdAt: { default: null },\n        resolved: { default: false },\n        replies: { default: null },\n        aiReply: { default: null }\n      },\n      inclusive: false,\n      parseDOM: [{\n        tag: \"span.comment-mark\",\n        getAttrs(dom) {\n          const repliesStr = dom.getAttribute(\"data-replies\");\n          let replies = null;\n          if (repliesStr) {\n            try {\n              replies = JSON.parse(repliesStr);\n            } catch (e) {\n              console.error(\"Failed to parse replies:\", e);\n            }\n          }\n          return {\n            commentId: dom.getAttribute(\"data-comment-id\"),\n            userId: dom.getAttribute(\"data-user-id\"),\n            userName: dom.getAttribute(\"data-user-name\") || \"\",\n            content: dom.getAttribute(\"data-content\") || \"\",\n            createdAt: dom.getAttribute(\"data-created-at\"),\n            resolved: dom.getAttribute(\"data-resolved\") === \"true\",\n            replies\n          };\n        }\n      }],\n      toDOM(mark) {\n        const attrs = {\n          class: \"comment-mark\",\n          \"data-comment\": \"true\",\n          style: \"background-color: rgba(251, 191, 36, 0.3); border-bottom: 2px solid rgba(251, 191, 36, 0.6); cursor: pointer; padding: 1px 0;\"\n        };\n        if (mark.attrs.commentId) attrs[\"data-comment-id\"] = mark.attrs.commentId;\n        if (mark.attrs.userId) attrs[\"data-user-id\"] = mark.attrs.userId;\n        if (mark.attrs.userName) attrs[\"data-user-name\"] = mark.attrs.userName;\n        if (mark.attrs.content) attrs[\"data-content\"] = mark.attrs.content;\n        if (mark.attrs.createdAt) attrs[\"data-created-at\"] = mark.attrs.createdAt;\n        if (mark.attrs.resolved !== void 0) attrs[\"data-resolved\"] = mark.attrs.resolved.toString();\n        if (mark.attrs.replies) attrs[\"data-replies\"] = JSON.stringify(mark.attrs.replies);\n        if (mark.attrs.resolved) {\n          attrs.style = \"background-color: rgba(156, 163, 175, 0.2); border-bottom: 2px solid rgba(156, 163, 175, 0.4); cursor: pointer; padding: 1px 0; text-decoration: line-through;\";\n        }\n        return [\"span\", attrs, 0];\n      }\n    })\n  });\n  window.PM = {\n    state: { EditorState, TextSelection, Plugin, PluginKey },\n    view: { EditorView, Decoration, DecorationSet },\n    model: { Schema, DOMParser: DOMParser2, DOMSerializer },\n    transform: { Step },\n    schema: mySchema,\n    keymap,\n    history: { history, undo, redo },\n    commands: { baseKeymap },\n    collab: { CollabConnection, createCollabPlugin, initializeCollaboration },\n    // Y.js exports for CRDT collaboration\n    Y: yjs_exports,\n    yProsemirror: { ySyncPlugin, yCursorPlugin, yUndoPlugin, prosemirrorToYXmlFragment },\n    Awareness,\n    awarenessProtocol: awareness_exports,\n    // Hocuspocus provider for WebSocket collaboration\n    HocuspocusProvider\n  };\n  console.log(\"[ProseMirror Bundle] Loaded successfully with Y.js and Hocuspocus support\");\n})();\n\n  </script>\n\n  <script>\n    console.log('[WebView] [v4-fixed] Checking if ProseMirror loaded...');\n    console.log('[WebView] window.PM exists:', typeof window.PM !== 'undefined');\n    console.log('[WebView] PM contents:', window.PM);\n\n    if (typeof window.PM === 'undefined') {\n      setStatus('ERROR: ProseMirror failed to load', true);\n      sendMessageToNative({\n        type: 'error',\n        message: 'ProseMirror bundle did not load'\n      });\n    } else {\n      setStatus('ProseMirror loaded successfully!');\n\n      // Initialize editor\n      const { EditorState, Plugin, PluginKey } = window.PM.state;\n      const { EditorView, Decoration, DecorationSet } = window.PM.view;\n      const { schema } = window.PM;\n      const { keymap } = window.PM;\n      const { history, undo, redo } = window.PM.history;\n      const { baseKeymap } = window.PM.commands;\n      const { Step } = window.PM.transform;\n\n      console.log('[WebView] Creating editor state...');\n\n      let editorView = null;\n      let collabConnection = null;\n      let collabPlugin = null;\n      let socket = null;\n\n      // Y.js collaboration variables\n      let ydoc = null;\n      let yXmlFragment = null;\n      let awareness = null;\n      let yProvider = null; // Supabase Y.js provider\n\n      // Buffer for Y.js updates received before collaboration is initialized\n      let pendingYjsUpdates = [];\n\n      // WebView Y.js Provider for Supabase Realtime\n      class YWebViewProvider {\n        constructor(ydoc, { supabase, documentId, userId, userName, debug = false }) {\n          this.ydoc = ydoc;\n          this.supabase = supabase;\n          this.documentId = documentId;\n          this.userId = userId;\n          this.userName = userName;\n          this.debug = debug;\n          this.channel = null;\n          this.synced = false;\n\n          this.log('YWebViewProvider initialized for document:', this.documentId);\n        }\n\n        log(...args) {\n          if (this.debug) {\n            console.log('[YWebViewProvider]', ...args);\n          }\n        }\n\n        async connect() {\n          this.log('Connecting to channel:', `doc:${this.documentId}`);\n\n          // Create trip-specific channel using injected Supabase client\n          this.channel = this.supabase.channel(`doc:${this.documentId}`, {\n            config: {\n              broadcast: { self: false }, // Don't receive our own broadcasts\n            },\n          });\n\n          // Listen for Y.js updates from other clients\n          this.channel.on('broadcast', { event: 'yjs-update' }, (payload) => {\n            this.log('Received yjs-update from remote');\n            try {\n              let update;\n\n              // Handle both base64 (new) and array (old) formats\n              const updateData = payload.payload?.update || payload.update;\n\n              if (!updateData) {\n                console.error('[YWebViewProvider] No update in payload:', payload);\n                return;\n              }\n\n              if (typeof updateData === 'string') {\n                // Base64 format\n                update = this.base64ToUint8Array(updateData);\n              } else if (Array.isArray(updateData)) {\n                // Array format (backward compatibility)\n                update = new Uint8Array(updateData);\n              } else {\n                console.error('[YWebViewProvider] Unknown update format:', typeof updateData);\n                return;\n              }\n\n              window.PM.Y.applyUpdate(this.ydoc, update, 'remote');\n              this.log('Applied remote update, size:', update.length);\n            } catch (error) {\n              console.error('[YWebViewProvider] Error applying update:', error);\n            }\n          });\n\n          // Subscribe to channel with timeout\n          await new Promise((resolve, reject) => {\n            // Add timeout to detect hanging\n            const timeout = setTimeout(() => {\n              console.error('[YWebViewProvider] Channel subscription timeout after 10 seconds');\n              reject(new Error('Channel subscription timeout'));\n            }, 10000);\n\n            try {\n              const subscription = this.channel.subscribe(async (status) => {\n                this.log('Channel status:', status);\n\n                if (status === 'SUBSCRIBED') {\n                  clearTimeout(timeout);\n                  this.log('Channel subscribed, loading initial state...');\n                  try {\n                    await this.loadInitialState();\n                    this.synced = true;\n                    this.log('Sync complete, provider ready');\n                    resolve();\n                  } catch (error) {\n                    reject(error);\n                  }\n                }\n\n                if (status === 'CLOSED') {\n                  this.log('Channel closed');\n                  this.synced = false;\n                }\n\n                if (status === 'CHANNEL_ERROR') {\n                  clearTimeout(timeout);\n                  reject(new Error('Channel subscription failed'));\n                }\n              });\n\n              this.log('Subscribe method returned:', subscription);\n\n              // Check if subscription returned an error\n              if (subscription && subscription.error) {\n                clearTimeout(timeout);\n                console.error('[YWebViewProvider] Subscribe error:', subscription.error);\n                reject(subscription.error);\n              }\n            } catch (error) {\n              clearTimeout(timeout);\n              console.error('[YWebViewProvider] Error calling subscribe:', error);\n              reject(error);\n            }\n          });\n\n          // Broadcast local Y.js updates\n          this.ydoc.on('update', this.handleLocalUpdate);\n\n          this.log('Connected and synced');\n        }\n\n        handleLocalUpdate = (update, origin) => {\n          // Don't broadcast updates that came from remote\n          if (origin === 'remote') return;\n\n          this.log('Broadcasting local update, size:', update.length);\n\n          if (this.channel) {\n            this.channel.send({\n              type: 'broadcast',\n              event: 'yjs-update',\n              payload: {\n                update: this.uint8ArrayToBase64(update),\n              },\n            });\n          }\n        };\n\n        async loadInitialState() {\n          this.log('Loading initial state from database');\n\n          try {\n            this.log('Querying trips table for document:', this.documentId);\n\n            // Use injected Supabase client to load initial state\n            const { data, error } = await this.supabase\n              .from('trips')\n              .select('yjs_state, yjs_clock')\n              .eq('id', this.documentId)\n              .single();\n\n            this.log('Query result:', { hasData: !!data, hasError: !!error });\n\n            if (error) {\n              console.error('[YWebViewProvider] Error loading state:', error);\n              // Don't throw - just continue with empty state\n              this.log('Continuing with empty state');\n              return;\n            }\n\n            if (data?.yjs_state) {\n              this.log('Applying initial state, clock:', data.yjs_clock);\n\n              let state;\n\n              if (data.yjs_state instanceof Uint8Array) {\n                state = data.yjs_state;\n              } else if (Array.isArray(data.yjs_state)) {\n                state = new Uint8Array(data.yjs_state);\n              } else if (typeof data.yjs_state === 'string') {\n                // Handle hex or base64\n                if (data.yjs_state.startsWith('\\\\x')) {\n                  // PostgreSQL bytea format\n                  const hex = data.yjs_state.substring(2);\n                  const bytes = new Uint8Array(hex.length / 2);\n                  for (let i = 0; i < hex.length; i += 2) {\n                    bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);\n                  }\n                  state = bytes;\n                } else {\n                  // Base64\n                  state = this.base64ToUint8Array(data.yjs_state);\n                }\n              } else {\n                console.error('[YWebViewProvider] Unknown yjs_state format:', typeof data.yjs_state);\n                throw new Error('Unknown yjs_state format');\n              }\n\n              this.log('Applying Y.js state, size:', state.length);\n              window.PM.Y.applyUpdate(this.ydoc, state, 'remote');\n            } else {\n              this.log('No initial state found, document is empty');\n            }\n          } catch (error) {\n            console.error('[YWebViewProvider] Error in loadInitialState:', error);\n            throw error;\n          }\n        }\n\n        async destroy() {\n          this.log('Destroying provider');\n\n          // Remove event listeners\n          this.ydoc.off('update', this.handleLocalUpdate);\n\n          // Unsubscribe from channel\n          if (this.channel) {\n            await this.supabase.removeChannel(this.channel);\n            this.channel = null;\n          }\n\n          this.synced = false;\n          this.log('Provider destroyed');\n        }\n\n        uint8ArrayToBase64(bytes) {\n          let binary = '';\n          for (let i = 0; i < bytes.byteLength; i++) {\n            binary += String.fromCharCode(bytes[i]);\n          }\n          return btoa(binary);\n        }\n\n        base64ToUint8Array(base64) {\n          const binary = atob(base64);\n          const bytes = new Uint8Array(binary.length);\n          for (let i = 0; i < binary.length; i++) {\n            bytes[i] = binary.charCodeAt(i);\n          }\n          return bytes;\n        }\n      }\n\n      // Create initial document - empty, content will be sent from React Native\n      const { DOMParser: PMDOMParser } = window.PM.model;\n\n      // Start with empty document\n      const doc = schema.node('doc', null, [\n        schema.node('paragraph', null, [])\n      ]);\n\n      // Create initial editor state\n      let editorState = EditorState.create({\n        doc: doc,\n        schema: schema,\n        plugins: [\n          history(),\n          keymap({ 'Mod-z': undo, 'Mod-y': redo }),\n          keymap(baseKeymap)\n        ]\n      });\n\n      console.log('[WebView] Creating editor view...');\n\n      // Color palette for geo-marks\n      const COLORS = [\n        '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',\n        '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'\n      ];\n\n      // NodeView for geo-marks\n      function createGeoMarkNodeView(node) {\n        const span = document.createElement('span');\n        span.className = 'geo-mark';\n\n        // Apply background color based on colorIndex\n        const colorIndex = node.attrs.colorIndex || 0;\n        const color = COLORS[colorIndex % COLORS.length];\n        span.style.backgroundColor = color + '33'; // 33 = 20% opacity\n        span.style.padding = '2px 4px';\n        span.style.borderRadius = '3px';\n        span.style.cursor = 'pointer';\n        span.style.transition = 'all 0.2s ease';\n        span.style.textDecoration = 'none';\n        span.style.border = 'none';\n        span.style.borderBottom = 'none';\n\n        // Store attributes as data attributes for click handling\n        if (node.attrs.geoId) span.setAttribute('data-geo-id', node.attrs.geoId);\n        if (node.attrs.placeName) span.setAttribute('data-place-name', node.attrs.placeName);\n        if (node.attrs.lat) span.setAttribute('data-lat', node.attrs.lat);\n        if (node.attrs.lng) span.setAttribute('data-lng', node.attrs.lng);\n        if (node.attrs.colorIndex !== undefined) span.setAttribute('data-color-index', node.attrs.colorIndex);\n        if (node.attrs.coordSource) span.setAttribute('data-coord-source', node.attrs.coordSource);\n\n        console.log('[WebView] Created geo-mark NodeView with color:', color, 'for:', node.attrs.placeName);\n\n        return {\n          dom: span,\n          contentDOM: span\n        };\n      }\n\n      // Typing cursor management\n      const typingCursor = document.getElementById('typing-cursor');\n      let isTypingActive = false;\n\n      function updateTypingCursor() {\n        if (!isTypingActive || !editorView) {\n          typingCursor.classList.remove('visible');\n          return;\n        }\n\n        const { state } = editorView;\n        const { selection } = state;\n        const { from } = selection;\n\n        // Get the coordinates of the cursor position\n        try {\n          const coords = editorView.coordsAtPos(from);\n          const editorContainer = document.querySelector('#editor-container');\n          const editorRect = editorContainer.getBoundingClientRect();\n\n          // Calculate cursor height based on line height\n          const cursorHeight = coords.bottom - coords.top;\n\n          // Position and size the cursor indicator\n          typingCursor.style.left = (coords.left - editorRect.left) + 'px';\n          typingCursor.style.top = (coords.top - editorRect.top) + 'px';\n          typingCursor.style.height = cursorHeight + 'px';\n          typingCursor.classList.add('visible');\n\n          console.log('[WebView] Cursor updated: height =', cursorHeight);\n        } catch (e) {\n          console.warn('[WebView] Could not get cursor coordinates:', e);\n          typingCursor.classList.remove('visible');\n        }\n      }\n\n      function showTypingCursor() {\n        isTypingActive = true;\n        updateTypingCursor();\n        console.log('[WebView] Typing cursor shown');\n      }\n\n      function hideTypingCursor() {\n        isTypingActive = false;\n        typingCursor.classList.remove('visible');\n        console.log('[WebView] Typing cursor hidden');\n      }\n\n      // Expose for native to control\n      window.showTypingCursor = showTypingCursor;\n      window.hideTypingCursor = hideTypingCursor;\n\n      // Helper functions for toolbar state (must be defined before EditorView)\n      // Helper function to update collaboration users display\n      function updateCollabUsers() {\n        if (!collabConnection) return;\n\n        const usersEl = document.getElementById('collab-users');\n        usersEl.innerHTML = '';\n\n        collabConnection.users.forEach((user, userId) => {\n          if (userId !== collabConnection.userId) {\n            const userEl = document.createElement('div');\n            userEl.className = 'collab-user';\n            userEl.style.backgroundColor = user.color;\n            userEl.textContent = user.name;\n            usersEl.appendChild(userEl);\n          }\n        });\n      }\n\n      function isNodeTypeActive(state, nodeType, attrs = {}) {\n        const { $from } = state.selection;\n        const node = $from.parent;\n\n        if (node.type.name !== nodeType.name) {\n          return false;\n        }\n\n        // Check attributes match\n        for (let key in attrs) {\n          if (node.attrs[key] !== attrs[key]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      function isMarkActive(state, markType) {\n        const { from, to } = state.selection;\n        return state.doc.rangeHasMark(from, to, markType);\n      }\n\n      // Get current toolbar state based on selection\n      function getToolbarState() {\n        const state = editorView.state;\n        return {\n          paragraph: isNodeTypeActive(state, schema.nodes.paragraph),\n          h1: isNodeTypeActive(state, schema.nodes.heading, { level: 1 }),\n          h2: isNodeTypeActive(state, schema.nodes.heading, { level: 2 }),\n          h3: isNodeTypeActive(state, schema.nodes.heading, { level: 3 }),\n          bold: schema.marks.strong ? isMarkActive(state, schema.marks.strong) : false,\n          italic: schema.marks.em ? isMarkActive(state, schema.marks.em) : false\n        };\n      }\n\n      // Create editor view\n      editorView = new EditorView(document.querySelector('#editor-container'), {\n        state: editorState,\n        nodeViews: {\n          geoMark: createGeoMarkNodeView\n        },\n        attributes: {\n          spellcheck: 'false',\n          autocorrect: 'off',\n          autocapitalize: 'off'\n        },\n        dispatchTransaction(transaction) {\n          const oldState = editorView.state;\n          const newState = oldState.apply(transaction);\n          editorView.updateState(newState);\n\n          // Update typing cursor position on any change\n          if (isTypingActive) {\n            updateTypingCursor();\n          }\n\n          // Send document changes to native\n          // NOTE: Skip during Y.js collaboration - sync happens via Y.js, not local storage\n          if (transaction.docChanged && !yProvider) {\n            const docJSON = newState.doc.toJSON();\n            console.log('[WebView] Document changed, sending to native:', JSON.stringify(docJSON));\n            sendMessageToNative({\n              type: 'documentChange',\n              doc: docJSON\n            });\n          } else if (transaction.docChanged && yProvider) {\n            console.log('[WebView] Document changed via Y.js, skipping native sync');\n          }\n\n          // Send selection changes to native\n          const oldSelection = oldState.selection;\n          const newSelection = newState.selection;\n          if (!oldSelection.eq(newSelection)) {\n            console.log('[WebView] Selection changed, empty:', newSelection.empty);\n            sendMessageToNative({\n              type: 'selectionChange',\n              empty: newSelection.empty\n            });\n\n            // Send toolbar state update\n            const toolbarState = getToolbarState();\n            sendMessageToNative({\n              type: 'toolbarStateChange',\n              state: toolbarState\n            });\n          }\n        }\n      });\n\n      console.log('[WebView] Editor created successfully');\n      setStatus('Editor ready');\n\n      // Add click handler for geo-marks and comments\n      document.querySelector('#editor-container').addEventListener('click', function(e) {\n        if (e.target.classList.contains('geo-mark')) {\n          const attrs = {\n            geoId: e.target.getAttribute('data-geo-id'),\n            placeName: e.target.getAttribute('data-place-name'),\n            lat: e.target.getAttribute('data-lat'),\n            lng: e.target.getAttribute('data-lng'),\n            colorIndex: parseInt(e.target.getAttribute('data-color-index') || '0'),\n            coordSource: e.target.getAttribute('data-coord-source')\n          };\n          console.log('[WebView] Geo-mark clicked:', attrs);\n          sendMessageToNative({\n            type: 'geoMarkNavigate',\n            attrs: attrs\n          });\n        }\n\n        if (e.target.classList.contains('comment-mark')) {\n          const repliesStr = e.target.getAttribute('data-replies');\n          let replies = null;\n          if (repliesStr) {\n            try {\n              replies = JSON.parse(repliesStr);\n            } catch (err) {\n              console.error('[WebView] Error parsing replies:', err);\n            }\n          }\n\n          const attrs = {\n            commentId: e.target.getAttribute('data-comment-id'),\n            userId: e.target.getAttribute('data-user-id'),\n            userName: e.target.getAttribute('data-user-name') || '',\n            content: e.target.getAttribute('data-content') || '',\n            createdAt: e.target.getAttribute('data-created-at'),\n            resolved: e.target.getAttribute('data-resolved') === 'true',\n            replies: replies\n          };\n          console.log('[WebView] Comment clicked:', attrs);\n          sendMessageToNative({\n            type: 'commentClick',\n            attrs: attrs\n          });\n        }\n      });\n\n      // Send ready message\n      sendMessageToNative({\n        type: 'ready',\n        message: 'ProseMirror editor initialized'\n      });\n\n      // Send initial toolbar state\n      const initialToolbarState = getToolbarState();\n      sendMessageToNative({\n        type: 'toolbarStateChange',\n        state: initialToolbarState\n      });\n\n      // Listen for iOS custom menu actions\n      // iOS will trigger this when custom menu items are selected\n      document.addEventListener('selectionchange', function() {\n        console.log('[WebView] Selection changed via DOM');\n        const selection = window.getSelection();\n        if (selection && !selection.isCollapsed) {\n          const selectedText = selection.toString();\n          console.log('[WebView] Selected text from DOM:', selectedText);\n        }\n      });\n\n      // Intercept iOS UIMenuItem actions via a hidden input trick\n      // When iOS menu items are clicked, we can detect it through focus/blur events\n      let lastSelectedText = '';\n      let pendingGeoMarkCreation = false;\n\n      // Store selection when text is selected\n      document.addEventListener('selectionchange', function() {\n        const selection = window.getSelection();\n        if (selection && !selection.isCollapsed) {\n          lastSelectedText = selection.toString();\n          console.log('[WebView] Stored selected text:', lastSelectedText);\n        }\n      });\n\n      // Create a global function that iOS can call\n      window.createLocationFromSelection = function() {\n        console.log('[WebView] createLocationFromSelection called!');\n        const { state } = editorView;\n        const { selection } = state;\n\n        if (selection.empty) {\n          console.warn('[WebView] No text selected');\n          return;\n        }\n\n        const selectedText = state.doc.textBetween(\n          selection.from,\n          selection.to,\n          ' '\n        );\n\n        console.log('[WebView] Creating location from iOS menu for:', selectedText);\n\n        // Send request to show geo-mark editor\n        sendMessageToNative({\n          type: 'showGeoMarkEditor',\n          data: {\n            placeName: selectedText,\n            from: selection.from,\n            to: selection.to\n          },\n          existingLocations: []\n        });\n      };\n\n      // Expose to window for iOS to call\n      window.handleCreateLocation = window.createLocationFromSelection;\n\n      // Y.js helper functions\n      function setupYjsListeners() {\n        if (!ydoc || !awareness) {\n          console.error('[WebView] Cannot setup Y.js listeners - missing ydoc or awareness');\n          return;\n        }\n\n        console.log('[WebView] Setting up Y.js listeners');\n\n        // Forward Y.js updates to React Native\n        ydoc.on('update', (update, origin) => {\n          if (origin !== 'remote') {\n            console.log('[WebView] Y.js update detected, forwarding to native');\n            sendMessageToNative({\n              type: 'yjsUpdate',\n              update: Array.from(update)\n            });\n          }\n        });\n\n        // Forward awareness changes\n        awareness.on('change', () => {\n          const update = window.PM.awarenessProtocol.encodeAwarenessUpdate(\n            awareness,\n            Array.from(awareness.getStates().keys())\n          );\n          console.log('[WebView] Awareness update detected, forwarding to native');\n          sendMessageToNative({\n            type: 'awarenessUpdate',\n            update: Array.from(update)\n          });\n        });\n\n        console.log('[WebView] Y.js listeners setup complete');\n      }\n\n      function getRandomColor() {\n        const colors = [\n          '#3B82F6', '#8B5CF6', '#10B981', '#F59E0B', '#EF4444',\n          '#EC4899', '#06B6D4', '#84CC16', '#F97316', '#6366F1'\n        ];\n        return colors[Math.floor(Math.random() * colors.length)];\n      }\n\n      // Listen for messages from React Native and native iOS menu\n      window.addEventListener('message', function(event) {\n        // Verbose logging removed - messages are frequent\n\n        // Handle native iOS menu actions\n        if (event.data && event.data.source === 'nativeMenu') {\n          console.log('[WebView] Native menu action:', event.data.action);\n\n          if (event.data.action === 'createLocation') {\n            console.log('[WebView] Create location from native menu:', event.data.data.selectedText);\n            // Trigger the create location function\n            if (window.createLocationFromSelection) {\n              window.createLocationFromSelection();\n            }\n            return;\n          }\n\n          if (event.data.action === 'addNote') {\n            console.log('[WebView] Add note from native menu:', event.data.data.selectedText);\n            // Handle add note action\n            return;\n          }\n        }\n\n        try {\n          const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;\n\n          switch (data.type) {\n            case 'evalScript':\n              console.log('[WebView] Executing script via postMessage');\n              try {\n                eval(data.script);\n              } catch (evalError) {\n                console.error('[WebView] Error executing script:', evalError);\n              }\n              break;\n\n            case 'supabaseConfig':\n              console.log('[WebView] Received Supabase config via postMessage');\n              // Store config globally for use during collaboration\n              window.__supabaseConfig = data.config;\n              break;\n\n            case 'setContent':\n              console.log('[WebView] Setting content:', JSON.stringify(data.content));\n              if (data.content && editorView) {\n                try {\n                  const doc = schema.nodeFromJSON(data.content);\n                  console.log('[WebView] Created doc from JSON:', doc.toString());\n                  console.log('[WebView] Doc content:', doc.content.toString());\n\n                  // Check for headings in the document\n                  let hasHeadings = false;\n                  doc.descendants((node) => {\n                    if (node.type.name === 'heading') {\n                      console.log('[WebView] Found heading node, level:', node.attrs.level);\n                      hasHeadings = true;\n                    }\n                  });\n                  console.log('[WebView] Document has headings:', hasHeadings);\n\n                  // Create new state with fresh plugins\n                  const newState = EditorState.create({\n                    doc: doc,\n                    schema: schema,\n                    plugins: [\n                      history(),\n                      keymap({ 'Mod-z': undo, 'Mod-y': redo }),\n                      keymap(baseKeymap)\n                    ]\n                  });\n                  editorView.updateState(newState);\n                  editorState = newState;\n\n                  // Send updated toolbar state after loading content\n                  const toolbarState = getToolbarState();\n                  sendMessageToNative({\n                    type: 'toolbarStateChange',\n                    state: toolbarState\n                  });\n                } catch (e) {\n                  console.error('[WebView] Error creating doc from JSON:', e);\n                  console.error('[WebView] Content was:', JSON.stringify(data.content));\n                }\n              }\n              break;\n\n            case 'setEditable':\n              console.log('[WebView] Setting editable:', data.editable);\n              if (editorView) {\n                editorView.setProps({ editable: () => data.editable });\n              }\n              break;\n\n            case 'getState':\n              // Verbose logging removed - state requests are frequent\n              if (editorView) {\n                sendMessageToNative({\n                  type: 'stateResponse',\n                  state: editorView.state.doc.toJSON()\n                });\n              }\n              break;\n\n            case 'createGeoMarkFromRecent':\n              console.log('[WebView] Creating geo-mark from recent text:', data.geoMarkData);\n              if (editorView && data.geoMarkData && data.textLength) {\n                const { state, dispatch } = editorView;\n                // Select the recently typed text by going backwards from current position\n                const currentPos = state.selection.to;\n                const from = Math.max(0, currentPos - data.textLength);\n                const to = currentPos;\n\n                // Create selection\n                const newSelection = TextSelection.create(state.doc, from, to);\n                let tr = state.tr.setSelection(newSelection);\n                dispatch(tr);\n\n                // Now create the geo-mark with the selected text\n                const selectedText = state.doc.textBetween(from, to, ' ');\n                const geoMarkType = schema.nodes.geoMark;\n                if (!geoMarkType) {\n                  console.error('[WebView] geoMark node type not found in schema');\n                  break;\n                }\n\n                const geoMarkNode = geoMarkType.create(\n                  {\n                    geoId: data.geoMarkData.geoId,\n                    placeName: data.geoMarkData.placeName,\n                    lat: data.geoMarkData.lat,\n                    lng: data.geoMarkData.lng,\n                    colorIndex: data.geoMarkData.colorIndex || 0,\n                    coordSource: data.geoMarkData.coordSource || 'manual',\n                    description: data.geoMarkData.description || null,\n                    transportFrom: data.geoMarkData.transportFrom || null,\n                    transportProfile: data.geoMarkData.transportProfile || null,\n                    waypoints: data.geoMarkData.waypoints || null,\n                    visitDocument: data.geoMarkData.visitDocument || null,\n                    photoName: data.geoMarkData.photoName || null,\n                  },\n                  schema.text(selectedText)\n                );\n\n                // Replace the selection with the geo-mark node\n                const tr2 = editorView.state.tr.replaceSelectionWith(geoMarkNode);\n                dispatch(tr2);\n                console.log('[WebView] Geo-mark created from recent text');\n              }\n              break;\n\n            case 'createGeoMark':\n              console.log('[WebView] Creating geo-mark with data:', data.geoMarkData);\n              sendMessageToNative({\n                type: 'debug',\n                message: '[WebView DEBUG] Received createGeoMark message'\n              });\n\n              try {\n                if (!editorView) {\n                  throw new Error('editorView is null');\n                }\n                if (!data.geoMarkData) {\n                  throw new Error('geoMarkData is missing');\n                }\n                console.log('[WebView] Step 1: editorView and geoMarkData validated');\n\n                const { state, dispatch } = editorView;\n                console.log('[WebView] Step 2: Got state and dispatch from editorView');\n\n                const { selection } = state;\n                const { from, to } = selection;\n                console.log('[WebView] Step 3: Selection bounds:', { from, to });\n\n                sendMessageToNative({\n                  type: 'debug',\n                  message: `[WebView DEBUG] Selection from ${from} to ${to}, selected text: \"${state.doc.textBetween(from, to, ' ')}\"`\n                });\n\n                // Create a geoMark NODE (not mark) with the location data\n                const geoMarkType = schema.nodes.geoMark;\n                if (!geoMarkType) {\n                  throw new Error('geoMark node type not found in schema');\n                }\n                console.log('[WebView] Step 4: geoMarkType found in schema');\n\n                // Get the selected text\n                const selectedText = state.doc.textBetween(from, to, ' ');\n                console.log('[WebView] Step 5: Selected text:', selectedText);\n\n                // Create geoMark node with text content and all attributes\n                const geoMarkNode = geoMarkType.create(\n                  {\n                    geoId: data.geoMarkData.geoId,\n                    placeName: data.geoMarkData.placeName,\n                    lat: data.geoMarkData.lat,\n                    lng: data.geoMarkData.lng,\n                    colorIndex: data.geoMarkData.colorIndex || 0,\n                    coordSource: data.geoMarkData.coordSource || 'manual',\n                    description: data.geoMarkData.description || null,\n                    transportFrom: data.geoMarkData.transportFrom || null,\n                    transportProfile: data.geoMarkData.transportProfile || null,\n                    waypoints: data.geoMarkData.waypoints || null,\n                    visitDocument: data.geoMarkData.visitDocument || null,\n                    photoName: data.geoMarkData.photoName || null\n                  },\n                  schema.text(selectedText)\n                );\n                console.log('[WebView] Step 6: geoMarkNode created:', geoMarkNode);\n\n                // Replace the selected text with the geo-mark node\n                const tr = state.tr.replaceSelectionWith(geoMarkNode);\n                console.log('[WebView] Step 7: Transaction created');\n\n                dispatch(tr);\n                console.log('[WebView] Step 8: Transaction dispatched');\n\n                console.log('[WebView] Geo-mark NODE created successfully');\n                sendMessageToNative({\n                  type: 'info',\n                  message: 'Location created: ' + data.geoMarkData.placeName\n                });\n              } catch (error) {\n                console.error('[WebView] ERROR in createGeoMark:', error);\n                console.error('[WebView] Error stack:', error.stack);\n                sendMessageToNative({\n                  type: 'error',\n                  message: `Failed to create geo-mark: ${error.message}`\n                });\n              }\n              break;\n\n            case 'command':\n              console.log('[WebView] Executing command:', data.command, data.params);\n              if (!editorView) {\n                console.warn('[WebView] Editor view not available');\n                break;\n              }\n\n              const { state, dispatch } = editorView;\n              const { selection } = state;\n              const { from, to } = selection;\n\n              switch (data.command) {\n                case 'setParagraph':\n                  console.log('[WebView] Setting paragraph');\n                  const paragraphTr = state.tr.setBlockType(from, to, schema.nodes.paragraph);\n                  dispatch(paragraphTr);\n                  editorView.focus();\n                  break;\n\n                case 'setHeading':\n                  const level = data.params?.level || 1;\n                  console.log('[WebView] Setting heading level:', level);\n                  // Get the current cursor position\n                  const cursorPos = state.selection.$from.pos;\n                  // Find the bounds of the current block (paragraph)\n                  const $pos = state.doc.resolve(cursorPos);\n                  const blockStart = $pos.before($pos.depth);\n                  const blockEnd = $pos.after($pos.depth);\n                  // Only set heading for the current block\n                  const headingTr = state.tr.setBlockType(blockStart, blockEnd, schema.nodes.heading, { level });\n                  dispatch(headingTr);\n                  console.log('[WebView] Set heading from', blockStart, 'to', blockEnd);\n                  editorView.focus();\n                  break;\n\n                case 'toggleBold':\n                  console.log('[WebView] Toggling bold');\n                  if (schema.marks.strong) {\n                    const hasBold = state.doc.rangeHasMark(from, to, schema.marks.strong);\n                    if (hasBold) {\n                      dispatch(state.tr.removeMark(from, to, schema.marks.strong));\n                    } else {\n                      dispatch(state.tr.addMark(from, to, schema.marks.strong.create()));\n                    }\n                    editorView.focus();\n                  }\n                  break;\n\n                case 'toggleItalic':\n                  console.log('[WebView] Toggling italic');\n                  if (schema.marks.em) {\n                    const hasItalic = state.doc.rangeHasMark(from, to, schema.marks.em);\n                    if (hasItalic) {\n                      dispatch(state.tr.removeMark(from, to, schema.marks.em));\n                    } else {\n                      dispatch(state.tr.addMark(from, to, schema.marks.em.create()));\n                    }\n                    editorView.focus();\n                  }\n                  break;\n\n                case 'createGeoMark':\n                  // Check if there's selected text\n                  if (selection.empty) {\n                    console.warn('[WebView] No text selected for geo-mark');\n                    sendMessageToNative({\n                      type: 'error',\n                      message: 'Please select text to create a location'\n                    });\n                    break;\n                  }\n\n                  // Get selected text\n                  const selectedText = state.doc.textBetween(from, to, ' ');\n                  console.log('[WebView] Selected text:', selectedText);\n\n                  // Check if geoMarkData is provided (for animation mode)\n                  if (data.params && data.params.geoMarkData) {\n                    console.log('[WebView] Animation mode: Creating geo-mark directly with data:', data.params.geoMarkData);\n                    try {\n                      const geoMarkType = schema.nodes.geoMark;\n                      if (!geoMarkType) {\n                        throw new Error('geoMark node type not found in schema');\n                      }\n                      console.log('[WebView] Step 1: geoMarkType found in schema');\n\n                      // Create geoMark node with text content and all attributes\n                      const geoMarkNode = geoMarkType.create(\n                        {\n                          geoId: data.params.geoMarkData.geoId,\n                          placeName: data.params.geoMarkData.placeName,\n                          lat: data.params.geoMarkData.lat,\n                          lng: data.params.geoMarkData.lng,\n                          colorIndex: data.params.geoMarkData.colorIndex || 0,\n                          coordSource: data.params.geoMarkData.coordSource || 'manual',\n                          description: data.params.geoMarkData.description || null,\n                          transportFrom: data.params.geoMarkData.transportFrom || null,\n                          transportProfile: data.params.geoMarkData.transportProfile || null,\n                          waypoints: data.params.geoMarkData.waypoints || null,\n                          visitDocument: data.params.geoMarkData.visitDocument || null,\n                          photoName: data.params.geoMarkData.photoName || null\n                        },\n                        schema.text(selectedText)\n                      );\n                      console.log('[WebView] Step 2: geoMarkNode created');\n\n                      // Replace the selected text with the geo-mark node\n                      const tr = state.tr.replaceSelectionWith(geoMarkNode);\n                      console.log('[WebView] Step 3: Transaction created');\n\n                      dispatch(tr);\n                      console.log('[WebView] Step 4: Transaction dispatched');\n\n                      console.log('[WebView] Geo-mark NODE created successfully!');\n                      sendMessageToNative({\n                        type: 'info',\n                        message: 'Location created: ' + data.params.geoMarkData.placeName\n                      });\n                    } catch (error) {\n                      console.error('[WebView] ERROR creating geo-mark:', error);\n                      console.error('[WebView] Error stack:', error.stack);\n                      sendMessageToNative({\n                        type: 'error',\n                        message: `Failed to create geo-mark: ${error.message}`\n                      });\n                    }\n                    break;\n                  }\n\n                  // Interactive mode: Send request to show geo-mark editor\n                  sendMessageToNative({\n                    type: 'showGeoMarkEditor',\n                    data: {\n                      placeName: selectedText,\n                      from: selection.from,\n                      to: selection.to\n                    },\n                    existingLocations: []\n                  });\n                  break;\n\n                case 'addComment':\n                  // Check if there's selected text\n                  if (selection.empty) {\n                    console.warn('[WebView] No text selected for comment');\n                    sendMessageToNative({\n                      type: 'error',\n                      message: 'Please select text to add a comment'\n                    });\n                    break;\n                  }\n\n                  // Get selected text\n                  const commentSelectedText = state.doc.textBetween(from, to, ' ');\n                  console.log('[WebView] Selected text for comment:', commentSelectedText);\n\n                  // Send request to show comment editor\n                  sendMessageToNative({\n                    type: 'showCommentEditor',\n                    data: {\n                      selectedText: commentSelectedText,\n                      from: selection.from,\n                      to: selection.to\n                    }\n                  });\n                  break;\n\n                case 'createComment':\n                  // Create a comment mark with the provided data\n                  if (data.params && schema.marks.comment) {\n                    const commentMark = schema.marks.comment.create({\n                      commentId: data.params.commentId,\n                      userId: data.params.userId,\n                      userName: data.params.userName,\n                      content: data.params.content,\n                      createdAt: data.params.createdAt,\n                      resolved: data.params.resolved || false,\n                      replies: data.params.replies || null\n                    });\n\n                    const commentTr = state.tr.addMark(\n                      data.params.from || from,\n                      data.params.to || to,\n                      commentMark\n                    );\n                    dispatch(commentTr);\n                    console.log('[WebView] Comment created successfully');\n                    editorView.focus();\n                  }\n                  break;\n\n                case 'updateCommentAIReply':\n                  // Update a comment mark's aiReply attribute\n                  console.log('[WebView] Updating comment AI reply:', data.commentId);\n                  if (data.commentId && data.aiReplyDoc && schema.marks.comment) {\n                    let commentFound = false;\n                    const updateTr = state.tr;\n\n                    // Find all comment marks in the document\n                    state.doc.descendants((node, pos) => {\n                      if (!node.isText) return;\n\n                      // Check if this text node has a comment mark with matching ID\n                      const commentMark = node.marks.find(\n                        mark => mark.type.name === 'comment' && mark.attrs.commentId === data.commentId\n                      );\n\n                      if (commentMark) {\n                        commentFound = true;\n                        const nodeStart = pos;\n                        const nodeEnd = pos + node.nodeSize;\n\n                        console.log('[WebView] Found comment mark at', nodeStart, '-', nodeEnd);\n\n                        // Create updated comment mark with aiReply\n                        const updatedCommentMark = schema.marks.comment.create({\n                          ...commentMark.attrs,\n                          aiReply: data.aiReplyDoc\n                        });\n\n                        // Remove old mark and add updated one\n                        updateTr.removeMark(nodeStart, nodeEnd, commentMark);\n                        updateTr.addMark(nodeStart, nodeEnd, updatedCommentMark);\n\n                        console.log('[WebView] Updated comment with AI reply');\n                      }\n                    });\n\n                    if (commentFound) {\n                      dispatch(updateTr);\n                      console.log('[WebView] Comment AI reply updated successfully');\n                      sendMessageToNative({\n                        type: 'info',\n                        message: 'AI reply received'\n                      });\n                    } else {\n                      console.warn('[WebView] Comment not found:', data.commentId);\n                    }\n                  }\n                  break;\n\n                case 'focusEditor':\n                  console.log('[WebView] Focusing editor');\n                  // Focus the editor\n                  editorView.focus();\n                  // Move cursor to end of document\n                  const endPos = state.doc.content.size;\n                  const focusTr = state.tr.setSelection(\n                    window.PM.state.Selection.near(state.doc.resolve(endPos))\n                  );\n                  dispatch(focusTr);\n                  console.log('[WebView] Editor focused, cursor at end');\n                  break;\n\n                case 'insertText':\n                  console.log('[WebView] Inserting text:', data.params?.text);\n                  // Insert text at current cursor position\n                  const text = data.params?.text || '';\n                  const insertTextTr = state.tr.insertText(text);\n                  dispatch(insertTextTr);\n                  console.log('[WebView] Text inserted at pos:', state.selection.$from.pos);\n                  break;\n\n                case 'insertParagraph':\n                  console.log('[WebView] Inserting paragraph');\n                  // Split the current block and reset to paragraph\n                  let paraTr = state.tr.split(state.selection.to);\n                  // After split, set the new block to paragraph (not heading)\n                  const newPos = paraTr.selection.$from.pos;\n                  const $newPos = paraTr.doc.resolve(newPos);\n                  const newBlockStart = $newPos.before($newPos.depth);\n                  const newBlockEnd = $newPos.after($newPos.depth);\n                  paraTr = paraTr.setBlockType(newBlockStart, newBlockEnd, schema.nodes.paragraph);\n                  dispatch(paraTr);\n                  console.log('[WebView] Paragraph split/inserted and reset to paragraph type');\n                  break;\n\n                case 'selectText':\n                  console.log('[WebView] Animating text selection backwards:', data.params?.count);\n                  // Animate selection backwards from cursor (like Shift+ArrowLeft held down)\n                  try {\n                    const count = data.params?.count || 0;\n                    const currentPos = state.selection.to;\n                    const finalStartPos = Math.max(0, currentPos - count);\n\n                    // Animate selection character by character\n                    let currentStep = 0;\n                    const animateSelection = () => {\n                      if (!editorView) return;\n\n                      currentStep++;\n                      const startPos = Math.max(finalStartPos, currentPos - currentStep);\n\n                      const selectTr = editorView.state.tr.setSelection(\n                        window.PM.state.TextSelection.create(editorView.state.doc, startPos, currentPos)\n                      );\n                      editorView.dispatch(selectTr);\n\n                      // Add visual highlight to selected text using DOM manipulation\n                      // This is more reliable than decorations for temporary highlights\n                      setTimeout(() => {\n                        const domSelection = window.getSelection();\n                        if (domSelection && domSelection.rangeCount > 0) {\n                          const range = domSelection.getRangeAt(0);\n                          // Force browser to show selection highlight\n                          if (range.toString().length > 0) {\n                            console.log('[WebView] Selection visible:', range.toString());\n                          }\n                        }\n                      }, 10);\n\n                      // Continue animation if not done\n                      if (currentStep < count) {\n                        setTimeout(animateSelection, 150); // 150ms per character for more visible animation\n                      } else {\n                        console.log('[WebView] Selection animation complete from', finalStartPos, 'to', currentPos);\n                      }\n                    };\n\n                    animateSelection();\n                  } catch (error) {\n                    console.error('[WebView] Error selecting text:', error);\n                  }\n                  break;\n\n                case 'selectBackward':\n                  console.log('[WebView] Selecting backward:', data.params?.length);\n                  sendMessageToNative({\n                    type: 'debug',\n                    message: `[WebView DEBUG] selectBackward command received, length: ${data.params?.length}`\n                  });\n\n                  try {\n                    // Select text backwards from cursor by the specified length\n                    const length = data.params?.length || 0;\n                    const currentPos = state.selection.to;\n                    const startPos = Math.max(0, currentPos - length);\n\n                    sendMessageToNative({\n                      type: 'debug',\n                      message: `[WebView DEBUG] Before selection: currentPos=${currentPos}, will select from ${startPos} to ${currentPos}`\n                    });\n\n                    const selectTr = state.tr.setSelection(\n                      window.PM.state.TextSelection.create(state.doc, startPos, currentPos)\n                    );\n\n                    sendMessageToNative({\n                      type: 'debug',\n                      message: `[WebView DEBUG] Created selection transaction, about to dispatch`\n                    });\n\n                    dispatch(selectTr);\n\n                    sendMessageToNative({\n                      type: 'debug',\n                      message: `[WebView DEBUG] After selection dispatch: from ${startPos} to ${currentPos}`\n                    });\n                  } catch (error) {\n                    sendMessageToNative({\n                      type: 'error',\n                      message: `[WebView ERROR] selectBackward failed: ${error.message}`\n                    });\n                  }\n                  break;\n\n                case 'selectRange':\n                  console.log('[WebView] Selecting range:', data.params?.from, 'to', data.params?.to);\n                  try {\n                    const rangeFrom = data.params?.from || 0;\n                    const rangeTo = data.params?.to || 0;\n\n                    // Create selection for the specified range\n                    const rangeTr = state.tr.setSelection(\n                      window.PM.state.TextSelection.create(state.doc, rangeFrom, rangeTo)\n                    );\n                    dispatch(rangeTr);\n                    console.log('[WebView] Range selected from', rangeFrom, 'to', rangeTo);\n                  } catch (error) {\n                    console.error('[WebView] selectRange failed:', error);\n                  }\n                  break;\n\n                case 'deleteSelection':\n                  console.log('[WebView] Deleting selection');\n                  try {\n                    // Delete the current selection\n                    const deleteTr = state.tr.deleteSelection();\n                    dispatch(deleteTr);\n                    console.log('[WebView] Selection deleted');\n                  } catch (error) {\n                    console.error('[WebView] deleteSelection failed:', error);\n                  }\n                  break;\n\n                case 'showTypingCursor':\n                  console.log('[WebView] Showing typing cursor');\n                  showTypingCursor();\n                  break;\n\n                case 'hideTypingCursor':\n                  console.log('[WebView] Hiding typing cursor');\n                  hideTypingCursor();\n                  break;\n\n                default:\n                  console.warn('[WebView] Unknown command:', data.command);\n              }\n              break;\n\n            case 'startCollaboration':\n              console.log('[WebView] Starting Y.js collaboration:', data);\n\n              if (!editorView) {\n                console.error('[WebView] Cannot start collaboration - editor not ready');\n                sendMessageToNative({\n                  type: 'collaborationStarted',\n                  success: false,\n                  error: 'Editor not ready'\n                });\n                break;\n              }\n\n              if (!window.PM.Y || !window.PM.yProsemirror) {\n                console.error('[WebView] Cannot start collaboration - Y.js not loaded');\n                sendMessageToNative({\n                  type: 'collaborationStarted',\n                  success: false,\n                  error: 'Y.js not loaded'\n                });\n                break;\n              }\n\n              (async () => {\n                try {\n                  // Connect to Tiptap Cloud or standalone Hocuspocus server\n                  const { documentId, userId, userName, token, serverUrl, hocuspocusUrl } = data;\n\n                  // Determine which URL to use (serverUrl takes priority for Tiptap Cloud)\n                  const wsUrl = serverUrl || hocuspocusUrl || 'ws://127.0.0.1:1234/collaboration';\n\n                  console.log('[WebView] Creating Hocuspocus collaboration for document:', documentId);\n                  console.log('[WebView] WebSocket URL:', wsUrl);\n                  console.log('[WebView] Auth token:', token ? 'present' : 'missing');\n\n                  if (!token) {\n                    throw new Error('Authentication required - no token provided');\n                  }\n\n                  // Get HocuspocusProvider from bundled modules\n                  if (!window.PM.HocuspocusProvider) {\n                    throw new Error('HocuspocusProvider not available in bundle');\n                  }\n                  const HocuspocusProvider = window.PM.HocuspocusProvider;\n                  console.log('[WebView] Using bundled HocuspocusProvider');\n\n                  // Create Y.Doc and fragment\n                  ydoc = new window.PM.Y.Doc();\n                  yXmlFragment = ydoc.getXmlFragment('prosemirror');\n                  awareness = new window.PM.Awareness(ydoc);\n\n                  // Set local awareness state\n                  awareness.setLocalStateField('user', {\n                    id: userId,\n                    name: userName,\n                    color: getRandomColor()\n                  });\n\n                  console.log('[WebView] Y.Doc created with clientID:', ydoc.clientID);\n\n                  // LOCAL-FIRST: Load initial state from AsyncStorage if provided\n                  // BUT: Only apply if we have local state AND we're not about to sync from server\n                  // The Hocuspocus provider will merge any server state automatically via CRDT\n                  if (data.yjsState) {\n                    console.log('[WebView] 📥 Loading Y.js state from AsyncStorage');\n                    try {\n                      // Decode base64 to Uint8Array\n                      const binaryString = atob(data.yjsState);\n                      const bytes = new Uint8Array(binaryString.length);\n                      for (let i = 0; i < binaryString.length; i++) {\n                        bytes[i] = binaryString.charCodeAt(i);\n                      }\n\n                      // Apply the state to our Y.Doc BEFORE connecting to Hocuspocus\n                      // This ensures local edits are preserved when merging with server state\n                      window.PM.Y.applyUpdate(ydoc, bytes);\n                      console.log('[WebView] ✅ Y.js state loaded successfully. YXmlFragment length:', yXmlFragment.length);\n                    } catch (error) {\n                      console.error('[WebView] ❌ Failed to load Y.js state:', error);\n                    }\n                  } else {\n                    console.log('[WebView] No local Y.js state to load - will sync from server');\n                  }\n\n                  // LOCAL-FIRST: Monitor Y.Doc updates and persist to AsyncStorage (debounced)\n                  let saveTimeout = null;\n                  ydoc.on('update', (update, origin) => {\n                    // Debounce saves to AsyncStorage (every 2 seconds)\n                    if (saveTimeout) clearTimeout(saveTimeout);\n                    saveTimeout = setTimeout(() => {\n                      // Check if document has content\n                      const docSize = yXmlFragment.length;\n                      if (docSize === 0) return;\n\n                      const state = window.PM.Y.encodeStateAsUpdate(ydoc);\n                      const base64State = btoa(String.fromCharCode(...new Uint8Array(state)));\n                      console.log('[WebView] Saving Y.js state:', state.byteLength, 'bytes');\n                      sendMessageToNative({\n                        type: 'saveYjsState',\n                        state: base64State\n                      });\n                    }, 2000);\n                  });\n\n                  // Create Hocuspocus provider for Tiptap Cloud or standalone server\n                  console.log('[WebView] Connecting to Hocuspocus server...');\n\n                  // Create Hocuspocus provider\n                  yProvider = new HocuspocusProvider({\n                    url: wsUrl,\n                    name: documentId,\n                    document: ydoc,\n                    token: token,\n                    awareness: awareness,\n                    onConnect: () => {\n                      console.log('[WebView] ✅ Hocuspocus connected successfully');\n                    },\n                    onDisconnect: ({ event }) => {\n                      console.log('[WebView] ❌ Hocuspocus disconnected:', event);\n                    },\n                    onStatus: ({ status }) => {\n                      console.log('[WebView] 📡 Hocuspocus status:', status);\n                    },\n                    onSynced: ({ state }) => {\n                      console.log('[WebView] ✅ Hocuspocus synced:', state);\n                      // NOTE: We don't send stateResponse here anymore\n                      // The Y.Doc update observer will handle persistence to AsyncStorage\n                    },\n                    onAuthenticationFailed: ({ reason }) => {\n                      console.error('[WebView] ❌ Hocuspocus authentication failed:', reason);\n                      console.error('[WebView] Token was:', token ? `${token.substring(0, 50)}...` : 'missing');\n                      console.error('[WebView] Document ID:', documentId);\n                      console.error('[WebView] URL:', wsUrl);\n                    },\n                    onClose: ({ event }) => {\n                      console.error('[WebView] ❌ Hocuspocus connection closed:', event);\n                    }\n                  });\n\n                  console.log('[WebView] Hocuspocus provider created and connecting...');\n\n                  // Recreate editor with Y.js plugins\n                  // NOTE: Do NOT pass a doc parameter - ySyncPlugin will create the doc from YXmlFragment\n                  const newState = EditorState.create({\n                    schema: schema,\n                    plugins: [\n                      window.PM.yProsemirror.ySyncPlugin(yXmlFragment),\n                      window.PM.yProsemirror.yCursorPlugin(awareness),\n                      window.PM.yProsemirror.yUndoPlugin(),\n                      keymap({ 'Mod-z': undo, 'Mod-y': redo }),\n                      keymap(baseKeymap)\n                    ]\n                  });\n\n                  editorView.updateState(newState);\n                  console.log('[WebView] Y.js collaboration started');\n\n                  // Update UI\n                  const statusEl = document.getElementById('collab-status');\n                  if (statusEl) {\n                    statusEl.textContent = 'Connected (Y.js)';\n                    statusEl.className = 'connected';\n                  }\n\n                  // Notify React Native\n                  sendMessageToNative({\n                    type: 'collaborationStarted',\n                    success: true,\n                    clientId: ydoc.clientID\n                  });\n\n                  console.log('[WebView] Y.js collaboration started successfully');\n                } catch (error) {\n                  console.error('[WebView] Failed to start Y.js collaboration:', error);\n                  sendMessageToNative({\n                    type: 'collaborationStarted',\n                    success: false,\n                    error: error.message\n                  });\n                }\n              })();\n              break;\n\n            case 'stopCollaboration':\n              console.log('[WebView] Stopping Y.js collaboration');\n\n              (async () => {\n                try {\n                  // Destroy Hocuspocus provider\n                  if (yProvider) {\n                    yProvider.destroy();\n                    yProvider = null;\n                    console.log('[WebView] Hocuspocus provider destroyed');\n                  }\n\n                  // Clean up Y.js resources\n                  if (ydoc) {\n                    ydoc.destroy();\n                    ydoc = null;\n                    yXmlFragment = null;\n                    awareness = null;\n                    console.log('[WebView] Y.js resources cleaned up');\n                  }\n\n                  // Remove Y.js plugins and restore editor with basic plugins\n                  if (editorView) {\n                    const currentDoc = editorView.state.doc;\n                    const newState = EditorState.create({\n                      schema: schema,\n                      doc: currentDoc,\n                      plugins: [\n                        history(),\n                        keymap({ 'Mod-z': undo, 'Mod-y': redo }),\n                        keymap(baseKeymap)\n                      ]\n                    });\n                    editorView.updateState(newState);\n                    console.log('[WebView] Editor restored with basic plugins');\n                  }\n\n                  // Update UI\n                  const statusEl = document.getElementById('collab-status');\n                  if (statusEl) {\n                    statusEl.textContent = 'Disconnected';\n                    statusEl.className = 'disconnected';\n                  }\n\n                  sendMessageToNative({\n                    type: 'collaborationStopped',\n                    success: true\n                  });\n\n                  console.log('[WebView] Y.js collaboration stopped successfully');\n                } catch (error) {\n                  console.error('[WebView] Error stopping Y.js collaboration:', error);\n                  sendMessageToNative({\n                    type: 'collaborationStopped',\n                    success: false,\n                    error: error.message\n                  });\n                }\n              })();\n              break;\n\n            case 'applySteps':\n              console.log('[WebView] Applying steps from', data.clientID, '- version:', data.version, '- steps:', data.steps.length);\n              if (editorView && data.steps && data.steps.length > 0) {\n                try {\n                  let tr = editorView.state.tr;\n\n                  // Apply each step to the transaction\n                  for (const stepJSON of data.steps) {\n                    const step = Step.fromJSON(schema, stepJSON);\n                    tr.step(step);\n                  }\n\n                  // Apply the transaction to update the editor\n                  editorView.dispatch(tr);\n                  editorState = editorView.state;\n\n                  console.log('[WebView] Successfully applied', data.steps.length, 'steps');\n\n                  // Notify React Native that document changed\n                  sendMessageToNative({\n                    type: 'documentChange',\n                    document: editorView.state.doc.toJSON()\n                  });\n                } catch (e) {\n                  console.error('[WebView] Error applying steps:', e);\n                }\n              }\n              break;\n\n            case 'yjsUpdate':\n              // Handle incoming Y.js update from React Native (base64 encoded)\n              console.log('[WebView] yjsUpdate message received, data:', {\n                hasUpdateBase64: !!data.updateBase64,\n                updateBase64Type: typeof data.updateBase64,\n                updateBase64Length: data.updateBase64 ? data.updateBase64.length : 0,\n                ydocReady: !!ydoc\n              });\n\n              if (data.updateBase64) {\n                try {\n                  // Decode base64 to Uint8Array\n                  const binary = atob(data.updateBase64);\n                  const bytes = new Uint8Array(binary.length);\n                  for (let i = 0; i < binary.length; i++) {\n                    bytes[i] = binary.charCodeAt(i);\n                  }\n                  console.log('[WebView] Decoded base64 update, byte size:', bytes.length);\n\n                  if (ydoc) {\n                    // Y.js is initialized, apply update immediately\n                    console.log('[WebView] Applying Y.js update from native, size:', bytes.length);\n                    window.PM.Y.applyUpdate(ydoc, bytes, 'remote');\n                    console.log('[WebView] Y.js update applied successfully');\n                  } else {\n                    // Buffer the update until Y.js is initialized\n                    console.log('[WebView] Buffering Y.js update (ydoc not ready yet)');\n                    pendingYjsUpdates.push(bytes);\n                  }\n                } catch (error) {\n                  console.error('[WebView] Error decoding/applying Y.js update:', error);\n                }\n              } else {\n                console.warn('[WebView] Received yjsUpdate but no updateBase64 data');\n              }\n              break;\n\n            case 'awarenessUpdate':\n              // Handle incoming awareness update from React Native\n              if (awareness && data.update) {\n                try {\n                  const update = new Uint8Array(data.update);\n                  console.log('[WebView] Applying awareness update from native, size:', update.length);\n                  window.PM.awarenessProtocol.applyAwarenessUpdate(\n                    awareness,\n                    update,\n                    'remote'\n                  );\n                  console.log('[WebView] Awareness update applied successfully');\n                } catch (error) {\n                  console.error('[WebView] Error applying awareness update:', error);\n                }\n              } else {\n                console.warn('[WebView] Received awarenessUpdate but awareness not initialized or no update data');\n              }\n              break;\n\n            default:\n              console.warn('[WebView] Unknown message type:', data.type);\n          }\n        } catch (e) {\n          console.error('[WebView] Error handling message:', e);\n        }\n      });\n    }\n  </script>\n</body>\n</html>\n";
