{
  "version": 3,
  "sources": ["../../../src/client-tools.ts", "../../../src/index.ts"],
  "sourceRoot": "/Users/mads/workspace/tourvision-mobile/workers/chat/.wrangler/tmp/deploy-1zTTqH",
  "sourcesContent": ["/**\n * Client Tool Definitions\n *\n * Defines the schema for tools that are executed on the frontend client.\n * These schemas are used by the LLM to understand what tools are available\n * and how to call them.\n */\n\nexport interface ClientTool {\n  name: string;\n  description: string;\n  parameters: {\n    type: 'object';\n    properties: Record<string, {\n      type: string;\n      description: string;\n      enum?: string[];\n    }>;\n    required: string[];\n  };\n  delegateToClient: true; // Marks this as a client-executed tool\n}\n\n/**\n * Tool schemas for LLM function calling\n */\nexport const CLIENT_TOOLS: ClientTool[] = [\n  {\n    name: 'geocode',\n    description: 'Get accurate geographic coordinates (latitude, longitude) for any location name. Use this whenever the user mentions a specific place. Returns the full place name, coordinates, and source.',\n    parameters: {\n      type: 'object',\n      properties: {\n        location: {\n          type: 'string',\n          description: 'The location name to geocode. Can be a city, landmark, address, or region. Examples: \"Copenhagen, Denmark\", \"Lejre\", \"Eiffel Tower, Paris\", \"123 Main St, New York\"'\n        },\n        biasCoords: {\n          type: 'object',\n          description: '(Optional) Approximate coordinates to bias the search. Useful for disambiguating common place names. Format: {lat: number, lng: number}'\n        }\n      },\n      required: ['location']\n    },\n    delegateToClient: true\n  }\n\n  // Route tool removed - routing is handled by setting transport attributes on geo-marks\n  // The frontend will automatically calculate routes when it sees transport attributes\n\n  // Future tool schemas:\n  //\n  // {\n  //   name: 'weather',\n  //   description: 'Get weather forecast for a location on a specific date',\n  //   parameters: {\n  //     type: 'object',\n  //     properties: {\n  //       location: { type: 'string', description: 'Location name' },\n  //       date: { type: 'string', description: 'ISO date (YYYY-MM-DD)' }\n  //     },\n  //     required: ['location', 'date']\n  //   },\n  //   delegateToClient: true\n  // },\n  //\n  // {\n  //   name: 'distance',\n  //   description: 'Calculate travel distance and duration between two locations',\n  //   parameters: {\n  //     type: 'object',\n  //     properties: {\n  //       from: { type: 'string', description: 'Starting location' },\n  //       to: { type: 'string', description: 'Destination location' },\n  //       mode: {\n  //         type: 'string',\n  //         description: 'Travel mode',\n  //         enum: ['walking', 'driving', 'cycling', 'transit']\n  //       }\n  //     },\n  //     required: ['from', 'to']\n  //   },\n  //   delegateToClient: true\n  // }\n];\n", "import { CLIENT_TOOLS } from \"./client-tools\";\n\nexport interface Env {\n  AI: any; // Cloudflare Workers AI binding\n  CHAT_ROOM: DurableObjectNamespace;\n}\n\ninterface ChatMessage {\n  id: string;\n  document_id: string;\n  user_id: string;\n  role: \"user\" | \"assistant\";\n  content: string;\n  metadata?: any;\n  created_at: string;\n}\n\nexport class ChatRoomV2 {\n  private state: DurableObjectState;\n  private env: Env;\n  private sessions: Set<WebSocket>;\n  private pendingToolCalls: Map<string, {resolve: (result: any) => void; reject: (error: Error) => void; timeout: NodeJS.Timeout}>;\n\n  constructor(state: DurableObjectState, env: Env) {\n    this.state = state;\n    this.env = env;\n    this.sessions = new Set();\n    this.pendingToolCalls = new Map();\n  }\n\n  async fetch(request: Request): Promise<Response> {\n    // Expect WebSocket upgrade\n    const upgradeHeader = request.headers.get(\"Upgrade\");\n    if (upgradeHeader !== \"websocket\") {\n      return new Response(\"Expected WebSocket\", { status: 426 });\n    }\n\n    // Create WebSocket pair\n    const pair = new WebSocketPair();\n    const [client, server] = Object.values(pair);\n\n    // Accept WebSocket connection\n    this.state.acceptWebSocket(server);\n    this.sessions.add(server);\n\n    console.log(`[ChatRoom] WebSocket connection accepted. Total sessions: ${this.sessions.size}`);\n\n    // Send empty chat history (no persistence)\n    server.send(JSON.stringify({\n      type: \"history\",\n      messages: []\n    }));\n\n    return new Response(null, {\n      status: 101,\n      webSocket: client,\n    });\n  }\n\n  async webSocketMessage(ws: WebSocket, message: string | ArrayBuffer) {\n    console.log('[ChatRoom] Received message:', message);\n    try {\n      const data = JSON.parse(message as string);\n      const documentId = this.state.id.toString();\n      console.log('[ChatRoom] Parsed message type:', data.type);\n\n      switch (data.type) {\n        case \"chat_message\":\n          await this.handleChatMessage(data, ws, documentId);\n          break;\n\n        case \"tool_result\":\n          await this.handleToolResult(data);\n          break;\n\n        case \"request_history\":\n          ws.send(JSON.stringify({\n            type: \"history\",\n            messages: []\n          }));\n          break;\n\n        default:\n          console.warn(`[ChatRoom] Unknown message type: ${data.type}`);\n      }\n    } catch (error) {\n      console.error(\"[ChatRoom] Error processing message:\", error);\n      ws.send(JSON.stringify({\n        type: \"error\",\n        error: \"Failed to process message\"\n      }));\n    }\n  }\n\n  async webSocketClose(ws: WebSocket, code: number, reason: string, wasClean: boolean) {\n    this.sessions.delete(ws);\n    console.log(`[ChatRoom] WebSocket closed. Code: ${code}, Reason: ${reason}. Total sessions: ${this.sessions.size}`);\n  }\n\n  async webSocketError(ws: WebSocket, error: any) {\n    console.error(\"[ChatRoom] WebSocket error:\", error);\n    this.sessions.delete(ws);\n  }\n\n  /**\n   * Handle tool result from client\n   */\n  private async handleToolResult(data: any) {\n    const { tool_id, result, error } = data;\n    console.log('[ChatRoom] Received tool result for:', tool_id);\n\n    const pending = this.pendingToolCalls.get(tool_id);\n    if (!pending) {\n      console.warn('[ChatRoom] No pending tool call found for:', tool_id);\n      return;\n    }\n\n    // Clear timeout\n    clearTimeout(pending.timeout);\n    this.pendingToolCalls.delete(tool_id);\n\n    // Resolve or reject based on result\n    if (error) {\n      pending.reject(new Error(error));\n    } else {\n      pending.resolve(result);\n    }\n  }\n\n  /**\n   * Request a tool execution from the client and wait for result\n   */\n  private async requestClientTool(toolName: string, args: any): Promise<any> {\n    const toolId = crypto.randomUUID();\n\n    console.log('[ChatRoom] Requesting client tool:', toolName, 'with args:', args);\n\n    // Create promise that will be resolved when client sends result\n    const toolPromise = new Promise((resolve, reject) => {\n      // Set timeout (10 seconds)\n      const timeout = setTimeout(() => {\n        this.pendingToolCalls.delete(toolId);\n        reject(new Error(`Tool call timeout: ${toolName}`));\n      }, 10000);\n\n      this.pendingToolCalls.set(toolId, { resolve, reject, timeout });\n    });\n\n    // Send tool request to all connected clients\n    this.broadcast(JSON.stringify({\n      type: 'tool_request',\n      tool_id: toolId,\n      tool_name: toolName,\n      args: args\n    }));\n\n    // Wait for result\n    return toolPromise;\n  }\n\n  private async handleChatMessage(data: any, sender: WebSocket, documentId: string) {\n    console.log('[ChatRoom] handleChatMessage called');\n    const { content, user_id, metadata } = data;\n\n    if (!content || !user_id) {\n      console.log('[ChatRoom] Missing required fields');\n      sender.send(JSON.stringify({\n        type: \"error\",\n        error: \"Missing required fields: content, user_id\"\n      }));\n      return;\n    }\n\n    console.log('[ChatRoom] Creating user message');\n    // Create user message (in-memory only)\n    const userMessage: ChatMessage = {\n      id: crypto.randomUUID(),\n      document_id: documentId,\n      user_id,\n      role: \"user\",\n      content,\n      metadata,\n      created_at: new Date().toISOString()\n    };\n\n    console.log('[ChatRoom] Broadcasting user message');\n    // Broadcast user message to all clients\n    this.broadcast(JSON.stringify({\n      type: \"message\",\n      message: userMessage\n    }));\n\n    // Send immediate acknowledgment that AI is processing\n    const ackMessageId = crypto.randomUUID();\n    const ackMessage: ChatMessage = {\n      id: ackMessageId,\n      document_id: documentId,\n      user_id: user_id,\n      role: \"assistant\",\n      content: \"...\",\n      metadata: { processing: true },\n      created_at: new Date().toISOString()\n    };\n\n    console.log('[ChatRoom] Broadcasting acknowledgment message');\n    this.broadcast(JSON.stringify({\n      type: \"message\",\n      message: ackMessage\n    }));\n\n    console.log('[ChatRoom] Generating AI response');\n    // Generate AI response with streaming\n    await this.generateAIResponse(documentId, user_id, content);\n    console.log('[ChatRoom] AI response complete');\n  }\n\n  private async generateAIResponse(documentId: string, userId: string, userMessage: string) {\n    try {\n      const messages = [\n        {\n          role: \"system\",\n          content: `You are a helpful travel planning assistant. When users mention specific locations, use the geocode tool to get accurate coordinates.\n\nFormat your responses as HTML paragraphs. After getting coordinates from the geocode tool, wrap location names in geo-mark spans with unique geo-ids:\n\nFor single locations:\n<p>Here is <span class=\"geo-mark\" data-geo-id=\"loc1\" data-place-name=\"Paris, France\" data-lat=\"48.8588897\" data-lng=\"2.320041\" data-color-index=\"0\">Paris</span>.</p>\n\nFor routes between locations, geocode both locations and add transport attributes to the DESTINATION:\n<p>Route from <span class=\"geo-mark\" data-geo-id=\"loc1\" data-place-name=\"Copenhagen, Denmark\" data-lat=\"55.67\" data-lng=\"12.56\" data-color-index=\"0\">Copenhagen</span> to <span class=\"geo-mark\" data-geo-id=\"loc2\" data-place-name=\"Roskilde, Denmark\" data-lat=\"55.64\" data-lng=\"12.08\" data-color-index=\"1\" data-transport-from=\"Copenhagen\" data-transport-profile=\"driving\">Roskilde</span> by car.</p>\n\nIMPORTANT:\n- Use SHORT display names inside the span (just \"Copenhagen\", not \"Copenhagen, Denmark\")\n- Keep the full place name in data-place-name attribute\n- For data-transport-from, you can use either the geo-id OR the simple display name (the system will match it)\n- Add data-color-index incrementing from 0 for each unique location\n\nTransport profiles: \"driving\" for car, \"walking\" for on foot, \"cycling\" for bike, \"transit\" for public transport.`\n        },\n        { role: \"user\", content: userMessage }\n      ];\n\n      console.log('[ChatRoom] Calling Cloudflare Workers AI...');\n\n      // Convert CLIENT_TOOLS to tools format (Hermes model doesn't need type/function wrapper)\n      const tools = CLIENT_TOOLS.map(({ name, description, parameters }) => ({\n        name,\n        description,\n        parameters\n      }));\n\n      // Traditional function calling approach with loop\n      let currentMessages = [...messages];\n      const maxIterations = 5; // Prevent infinite loops\n      let iterations = 0;\n      let finalResponse = \"\";\n      const messageId = crypto.randomUUID();\n\n      while (iterations < maxIterations) {\n        iterations++;\n        console.log(`[ChatRoom] AI call iteration ${iterations}`);\n\n        // Call AI with current messages and tools\n        const response = await this.env.AI.run(\n          \"@hf/nousresearch/hermes-2-pro-mistral-7b\",\n          {\n            messages: currentMessages,\n            tools: tools\n          }\n        );\n\n        console.log('[ChatRoom] AI response:', response);\n\n        // Check if there are tool calls\n        if (response.tool_calls && response.tool_calls.length > 0) {\n          console.log(`[ChatRoom] Processing ${response.tool_calls.length} tool calls`);\n\n          // Add assistant's message with tool calls\n          currentMessages.push({\n            role: \"assistant\",\n            content: JSON.stringify(response.tool_calls)\n          });\n\n          // Execute all tool calls in parallel\n          const toolPromises = response.tool_calls.map(async (toolCall) => {\n            console.log(`[ChatRoom] Executing tool: ${toolCall.name}`, toolCall.arguments);\n\n            try {\n              // Request tool execution from client\n              const toolResult = await this.requestClientTool(\n                toolCall.name,\n                toolCall.arguments\n              );\n\n              console.log(`[ChatRoom] Tool ${toolCall.name} result:`, toolResult);\n\n              return {\n                role: \"tool\",\n                name: toolCall.name,\n                content: JSON.stringify(toolResult)\n              };\n            } catch (error) {\n              console.error(`[ChatRoom] Tool ${toolCall.name} error:`, error);\n              return {\n                role: \"tool\",\n                name: toolCall.name,\n                content: JSON.stringify({ error: error.message || String(error) })\n              };\n            }\n          });\n\n          // Wait for all tool results\n          const toolResults = await Promise.all(toolPromises);\n\n          // Add all tool results to messages\n          for (const result of toolResults) {\n            currentMessages.push(result);\n          }\n\n          // Continue loop to get final response with tool results\n          continue;\n        }\n\n        // No tool calls, we have the final response\n        if (response.response) {\n          finalResponse = response.response;\n          console.log('[ChatRoom] Final response received');\n          break;\n        } else {\n          console.warn('[ChatRoom] No response or tool_calls in AI response');\n          break;\n        }\n      }\n\n      if (iterations >= maxIterations) {\n        console.error('[ChatRoom] Max iterations reached, stopping');\n        finalResponse = \"I apologize, but I encountered an issue processing your request. Please try again.\";\n      }\n\n      console.log('[ChatRoom] Full AI response:', finalResponse);\n\n      // Send the complete response\n      if (finalResponse) {\n        const chunkMessage = {\n          type: \"ai_chunk\",\n          message_id: messageId,\n          chunk: finalResponse,\n          done: false\n        };\n        console.log('[ChatRoom] Sending chunk to client:', JSON.stringify(chunkMessage));\n        this.broadcast(JSON.stringify(chunkMessage));\n      }\n\n      // Fallback if AI returned empty response\n      if (!finalResponse.trim()) {\n        console.warn('[ChatRoom] AI returned empty response, using fallback');\n        finalResponse = \"I apologize, but I'm having trouble generating a response right now. Please try again.\";\n      }\n\n      // Also process HTML comment tool calls (fallback for models that don't use native function calling)\n      let processedResponse = await this.processToolCalls(finalResponse);\n      console.log('[ChatRoom] Response after processToolCalls:', processedResponse);\n\n      // Post-process: Wrap plain text response in HTML if model didn't follow format\n      if (!processedResponse.includes('<p>') && !processedResponse.includes('<h')) {\n        console.log('[ChatRoom] Response is plain text, wrapping in HTML paragraphs');\n        // Split by double newlines (paragraph breaks)\n        const paragraphs = processedResponse.split(/\\n\\n+/).filter(p => p.trim());\n        processedResponse = paragraphs.map(p => {\n          // Handle headings (lines that end with colon or are all caps)\n          if (p.trim().endsWith(':') && p.trim().length < 50) {\n            return `<h3>${p.trim()}</h3>`;\n          }\n          // Regular paragraphs\n          return `<p>${p.trim().replace(/\\n/g, '<br>')}</p>`;\n        }).join('\\n');\n      }\n\n      // Auto-detect and wrap location names in geo-marks\n      // Common location patterns: proper nouns, landmarks, places ending in common suffixes\n      const locationPatterns = [\n        // Named landmarks/buildings\n        /\\b([A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*(?:\\s+(?:Palace|Castle|Museum|Gardens?|Park|Square|Tower|Cathedral|Church|Bridge|Statue|Harbor?|Street|Avenue|Center|Centre|Hall|Market|Temple)))\\b/g,\n        // City districts/neighborhoods\n        /\\b((?:Old\\s+Town|Downtown|[A-Z][a-z]+(?:town|borg|ville|berg)))\\b/g,\n      ];\n\n      let enhancedResponse = processedResponse;\n      for (const pattern of locationPatterns) {\n        enhancedResponse = enhancedResponse.replace(pattern, (match) => {\n          // Skip if already wrapped in a geo-mark or HTML tag\n          const beforeMatch = enhancedResponse.substring(0, enhancedResponse.indexOf(match));\n          if (beforeMatch.lastIndexOf('<span class=\"geo-mark\"') > beforeMatch.lastIndexOf('</span>')) {\n            return match;\n          }\n          if (beforeMatch.lastIndexOf('<') > beforeMatch.lastIndexOf('>')) {\n            return match;\n          }\n\n          // Wrap in geo-mark span (without coordinates - will be enriched client-side if needed)\n          return `<span class=\"geo-mark\" data-place-name=\"${match}\" data-coord-source=\"llm\">${match}</span>`;\n        });\n      }\n\n      // Assign sequential color indices to all geo-marks (using modulo 5 for color cycling)\n      let colorIndex = 0;\n      enhancedResponse = enhancedResponse.replace(\n        /<span class=\"geo-mark\"([^>]*)>/g,\n        (match, attributes) => {\n          // Only add color-index if not already present\n          if (!attributes.includes('data-color-index')) {\n            const index = colorIndex % 5; // Cycle through 5 colors\n            colorIndex++;\n            return `<span class=\"geo-mark\"${attributes} data-color-index=\"${index}\">`;\n          }\n          return match;\n        }\n      );\n\n      console.log('[ChatRoom] Final enhanced response being sent:', enhancedResponse);\n\n      // Create complete AI message\n      const aiMessage: ChatMessage = {\n        id: messageId,\n        document_id: documentId,\n        user_id: userId,\n        role: \"assistant\",\n        content: enhancedResponse,\n        metadata: { model: \"hermes-2-pro-mistral-7b\" },\n        created_at: new Date().toISOString()\n      };\n\n      // Send completion\n      const completionMessage = {\n        type: \"ai_chunk\",\n        message_id: messageId,\n        chunk: \"\",\n        done: true,\n        message: aiMessage\n      };\n      console.log('[ChatRoom] Sending completion to client:', JSON.stringify(completionMessage));\n      this.broadcast(JSON.stringify(completionMessage));\n    } catch (error) {\n      console.error(\"[ChatRoom] Error generating AI response:\", error);\n      this.broadcast(JSON.stringify({\n        type: \"error\",\n        error: \"Failed to generate AI response\"\n      }));\n    }\n  }\n\n  /**\n   * Repair common JSON formatting errors from LLM\n   * Fixes: {\"key:value\"} -> {\"key\":\"value\"}\n   */\n  private repairJSON(json: string): string {\n    // Fix missing quotes after keys: {\"key:value\"} -> {\"key\":\"value\"}\n    // Pattern: {\" followed by word characters, then : without closing quote\n    const fixedJson = json.replace(/\\{\"(\\w+):([^\"}]+)\"\\}/g, (match, key, value) => {\n      // If value doesn't start with a quote, add quotes\n      const quotedValue = value.trim().startsWith('\"') ? value : `\"${value.trim()}\"`;\n      return `{\"${key}\":${quotedValue}}`;\n    });\n\n    return fixedJson;\n  }\n\n  /**\n   * Process tool calls in the LLM response\n   * Detects <!-- TOOL:name:args --> patterns, executes them via client, and replaces with results\n   */\n  private async processToolCalls(response: string): Promise<string> {\n    const toolCallPattern = /<!-- TOOL:(\\w+):(.*?) -->/g;\n    let processedResponse = response;\n    const toolCalls: Array<{match: string; toolName: string; args: any}> = [];\n\n    // Extract all tool calls\n    let match: RegExpExecArray | null;\n    while ((match = toolCallPattern.exec(response)) !== null) {\n      try {\n        const toolName = match[1];\n        let argsJson = match[2];\n\n        // Try to repair common JSON errors\n        argsJson = this.repairJSON(argsJson);\n\n        // Try to parse JSON\n        const args = JSON.parse(argsJson);\n\n        toolCalls.push({\n          match: match[0],\n          toolName,\n          args\n        });\n      } catch (error) {\n        console.error('[ChatRoom] Failed to parse tool call:', match[0]);\n        console.error('[ChatRoom] Original JSON:', match[2]);\n        console.error('[ChatRoom] After repair:', this.repairJSON(match[2]));\n        console.error('[ChatRoom] Error:', error);\n\n        // Still remove the malformed tool call from output\n        processedResponse = processedResponse.replace(match[0], '');\n      }\n    }\n\n    // Execute each tool call sequentially\n    for (const toolCall of toolCalls) {\n      try {\n        console.log('[ChatRoom] Executing tool:', toolCall.toolName, 'with args:', toolCall.args);\n\n        // Request tool execution from client\n        const result = await this.requestClientTool(toolCall.toolName, toolCall.args);\n\n        console.log('[ChatRoom] Tool result:', result);\n\n        // Replace tool call with result (or empty string to remove the comment)\n        // The LLM should generate geo-marks after receiving tool results\n        processedResponse = processedResponse.replace(toolCall.match, '');\n      } catch (error) {\n        console.error('[ChatRoom] Tool execution failed:', error);\n        // Remove the failed tool call from response\n        processedResponse = processedResponse.replace(toolCall.match, '');\n      }\n    }\n\n    return processedResponse;\n  }\n\n  /**\n   * Extract complete HTML tags and words from buffer\n   * Returns what can be sent immediately and what should remain buffered\n   */\n  private extractCompleteUnits(buffer: string): { toSend: string; remaining: string } {\n    let toSend = \"\";\n    let i = 0;\n\n    while (i < buffer.length) {\n      const char = buffer[i];\n\n      // Check if we're starting an HTML tag\n      if (char === '<') {\n        // Find the closing >\n        const closeTagIndex = buffer.indexOf('>', i);\n\n        if (closeTagIndex === -1) {\n          // Incomplete tag, keep in buffer\n          break;\n        }\n\n        // Complete tag found, extract it\n        const tag = buffer.substring(i, closeTagIndex + 1);\n        toSend += tag;\n        i = closeTagIndex + 1;\n      }\n      // Regular text (not inside a tag)\n      else {\n        // Find the next tag start or whitespace\n        let wordEnd = i;\n        while (\n          wordEnd < buffer.length &&\n          buffer[wordEnd] !== '<' &&\n          buffer[wordEnd] !== ' ' &&\n          buffer[wordEnd] !== '\\n' &&\n          buffer[wordEnd] !== '\\t'\n        ) {\n          wordEnd++;\n        }\n\n        // If we hit a tag or whitespace, we have a complete word\n        if (wordEnd > i && (\n          wordEnd >= buffer.length ||\n          buffer[wordEnd] === '<' ||\n          buffer[wordEnd] === ' ' ||\n          buffer[wordEnd] === '\\n' ||\n          buffer[wordEnd] === '\\t'\n        )) {\n          // Extract word and include trailing whitespace if present\n          const word = buffer.substring(i, wordEnd);\n          toSend += word;\n          i = wordEnd;\n\n          // Include trailing whitespace\n          if (i < buffer.length && (buffer[i] === ' ' || buffer[i] === '\\n' || buffer[i] === '\\t')) {\n            toSend += buffer[i];\n            i++;\n          }\n        } else if (wordEnd === i) {\n          // Just whitespace, include it\n          toSend += buffer[i];\n          i++;\n        } else {\n          // Incomplete word at end of buffer, keep for next iteration\n          break;\n        }\n      }\n    }\n\n    const remaining = buffer.substring(i);\n\n    return { toSend, remaining };\n  }\n\n  private broadcast(message: string) {\n    // Get all WebSockets managed by this Durable Object\n    const webSockets = this.state.getWebSockets();\n    console.log(`[ChatRoom] Broadcasting to ${webSockets.length} WebSockets`);\n\n    for (const ws of webSockets) {\n      try {\n        console.log('[ChatRoom] Sending to WebSocket');\n        ws.send(message);\n      } catch (error) {\n        console.error(\"[ChatRoom] Error broadcasting to WebSocket:\", error);\n      }\n    }\n  }\n}\n\nexport default {\n  async fetch(request: Request, env: Env): Promise<Response> {\n    const url = new URL(request.url);\n\n    // Health check endpoint\n    if (url.pathname === \"/health\") {\n      return new Response(\n        JSON.stringify({\n          status: \"ok\",\n          service: \"tourvision-chat\",\n          timestamp: new Date().toISOString()\n        }),\n        { headers: { \"Content-Type\": \"application/json\" } }\n      );\n    }\n\n    // Extract locations endpoint - uses LLM to detect locations in text\n    if (url.pathname === \"/api/extract-locations\" && request.method === \"POST\") {\n      try {\n        const { text } = await request.json();\n\n        if (!text || typeof text !== 'string') {\n          return new Response(\n            JSON.stringify({ error: 'Invalid request: text field required' }),\n            { status: 400, headers: { \"Content-Type\": \"application/json\", \"Access-Control-Allow-Origin\": \"*\" } }\n          );\n        }\n\n        console.log('[ExtractLocations] Processing text:', text);\n\n        // Call AI to extract locations\n        const response = await env.AI.run(\n          \"@hf/nousresearch/hermes-2-pro-mistral-7b\",\n          {\n            messages: [\n              {\n                role: \"system\",\n                content: `You are a travel itinerary assistant. Convert the user's text into a structured ProseMirror document with geo-marks for locations and transportation information.\n\nReturn ONLY valid JSON in this exact ProseMirror format:\n{\n  \"type\": \"doc\",\n  \"content\": [\n    {\n      \"type\": \"paragraph\",\n      \"content\": [\n        {\"type\": \"text\", \"text\": \"I will \"},\n        {\"type\": \"text\", \"text\": \"cycle\", \"marks\": [{\"type\": \"transportAction\", \"attrs\": {\"mode\": \"cycling\"}}]},\n        {\"type\": \"text\", \"text\": \" from \"},\n        {\n          \"type\": \"geoMark\",\n          \"attrs\": {\n            \"geoId\": \"loc-1\",\n            \"placeName\": \"Lejre\",\n            \"colorIndex\": 0\n          },\n          \"content\": [{\"type\": \"text\", \"text\": \"Lejre\"}]\n        },\n        {\"type\": \"text\", \"text\": \" to \"},\n        {\n          \"type\": \"geoMark\",\n          \"attrs\": {\n            \"geoId\": \"loc-2\",\n            \"placeName\": \"Copenhagen\",\n            \"colorIndex\": 1,\n            \"transportFrom\": \"Lejre\",\n            \"transportProfile\": \"cycling\"\n          },\n          \"content\": [{\"type\": \"text\", \"text\": \"Copenhagen\"}]\n        }\n      ]\n    }\n  ]\n}\n\nRules:\n- Create unique geoId for each location (loc-1, loc-2, etc.)\n- Set colorIndex starting from 0 and incrementing\n- For destinations, add transportFrom (previous location name) and transportProfile\n- Transport profiles: \"walking\", \"driving\", \"cycling\", \"transit\", \"flight\"\n- Keep the original text's natural language\n- Do not include lat/lng - frontend will geocode using placeName\n\nReturn ONLY the JSON, no markdown, no explanation.`\n              },\n              {\n                role: \"user\",\n                content: `Convert to ProseMirror format:\\n\\n\"${text}\"`\n              }\n            ]\n          }\n        );\n\n        console.log('[ExtractLocations] AI response:', response);\n\n        // Parse the AI response\n        let document = null;\n        try {\n          // The response might be wrapped in markdown code blocks\n          let content = response.response || response.content || '';\n\n          // Remove markdown code blocks if present\n          content = content.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n\n          document = JSON.parse(content);\n\n          // Validate it's a ProseMirror document\n          if (!document || document.type !== 'doc') {\n            console.error('[ExtractLocations] Invalid document structure');\n            document = null;\n          }\n        } catch (parseError) {\n          console.error('[ExtractLocations] Failed to parse AI response:', parseError);\n          document = null;\n        }\n\n        console.log('[ExtractLocations] Generated document:', JSON.stringify(document));\n\n        return new Response(\n          JSON.stringify({ document }),\n          {\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Access-Control-Allow-Origin\": \"*\"\n            }\n          }\n        );\n      } catch (error) {\n        console.error('[ExtractLocations] Error:', error);\n        return new Response(\n          JSON.stringify({ error: 'Internal server error', locations: [] }),\n          {\n            status: 500,\n            headers: {\n              \"Content-Type\": \"application/json\",\n              \"Access-Control-Allow-Origin\": \"*\"\n            }\n          }\n        );\n      }\n    }\n\n    // CORS preflight\n    if (request.method === \"OPTIONS\") {\n      return new Response(null, {\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n          \"Access-Control-Allow-Headers\": \"Content-Type\"\n        }\n      });\n    }\n\n    // WebSocket upgrade for chat rooms\n    const chatMatch = url.pathname.match(/^\\/chat\\/(.+)$/);\n    if (chatMatch && request.headers.get(\"Upgrade\") === \"websocket\") {\n      const documentId = chatMatch[1];\n\n      // Get or create Durable Object for this document\n      const id = env.CHAT_ROOM.idFromName(documentId);\n      const stub = env.CHAT_ROOM.get(id);\n\n      // Forward the WebSocket request to the Durable Object\n      return stub.fetch(request);\n    }\n\n    return new Response(\"Not Found\", { status: 404 });\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
