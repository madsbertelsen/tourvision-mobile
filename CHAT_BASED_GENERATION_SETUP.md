# Chat-Based Document Generation Setup

## Overview
We've changed the architecture from directly calling edge functions to using a chat-based system. Documents are now generated by inserting messages into a `document_chats` table, which triggers a local Node.js listener that processes the messages.

## Architecture

```
User creates prompt ‚Üí Frontend creates document ‚Üí Frontend inserts chat message
                                                            ‚Üì
                                                  Supabase Realtime Event
                                                            ‚Üì
                                            Local Node.js Listener (document-chat-listener.js)
                                                            ‚Üì
                                                  Calls edge function to generate
                                                            ‚Üì
                                                  Updates document with content
```

## Setup Steps

### 1. Apply Database Migration

Go to your Supabase Dashboard SQL Editor and run the following SQL:

```sql
-- Create document_chats table for document-specific chat messages
CREATE TABLE IF NOT EXISTS public.document_chats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID NOT NULL REFERENCES public.documents(id) ON DELETE CASCADE,
    user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    role TEXT NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
    content TEXT NOT NULL,
    metadata JSONB DEFAULT '{}',
    created_at TIMESTAMPTZ DEFAULT now(),
    updated_at TIMESTAMPTZ DEFAULT now()
);

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_document_chats_document_id ON public.document_chats(document_id);
CREATE INDEX IF NOT EXISTS idx_document_chats_user_id ON public.document_chats(user_id);
CREATE INDEX IF NOT EXISTS idx_document_chats_created_at ON public.document_chats(created_at DESC);

-- Enable Row Level Security
ALTER TABLE public.document_chats ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist
DROP POLICY IF EXISTS "Users can view their document chats" ON public.document_chats;
DROP POLICY IF EXISTS "Users can insert chats for their documents" ON public.document_chats;

-- Users can view chats for documents they own
CREATE POLICY "Users can view their document chats" ON public.document_chats
    FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM public.documents
            WHERE documents.id = document_chats.document_id
            AND documents.user_id = auth.uid()
        )
    );

-- Users can insert chats for documents they own
CREATE POLICY "Users can insert chats for their documents" ON public.document_chats
    FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.documents
            WHERE documents.id = document_chats.document_id
            AND documents.user_id = auth.uid()
        )
        AND user_id = auth.uid()
    );

-- Check if the function exists before trying to use it
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_proc WHERE proname = 'update_updated_at_column') THEN
        -- Add updated_at trigger
        CREATE TRIGGER update_document_chats_updated_at
            BEFORE UPDATE ON public.document_chats
            FOR EACH ROW
            EXECUTE FUNCTION public.update_updated_at_column();
    END IF;
END $$;
```

### 2. Start the Realtime Listener

The listener needs to be running to process chat messages and generate documents:

```bash
# From the project root
node scripts/document-chat-listener.js
```

Keep this running in a terminal while testing. You should see:
```
üöÄ Document Chat Listener started
üì° Connecting to Supabase: https://unocjfiipormnaujsuhk.supabase.co
‚è≥ Listening for new chat messages...
‚úÖ Successfully subscribed to document_chats table
```

### 3. Test the System

1. Make sure the Expo app is running:
   ```bash
   cd expo-app
   npx expo start --web --port 8082
   ```

2. Login with test credentials:
   - Email: `test@example.com`
   - Password: `dda9817e-c401-4ad4-9ec1`

3. Click "Generate Trip with AI" (sparkles icon)

4. Enter a prompt like "Plan a 2-day trip to Paris"

5. Click "Generate Trip"

6. Watch the listener terminal - you should see:
   - New message received
   - Document generation starting
   - Document updated

7. The app will redirect to the document view once generation is complete

## How It Works

1. **generate-document.tsx** creates a new empty document
2. It inserts a chat message with `role: 'user'` and `metadata: { initial_prompt: true }`
3. The **document-chat-listener.js** receives the realtime event
4. It calls the `generate-document-stream` edge function
5. It updates the document with the generated content
6. It inserts an assistant message confirming generation
7. The frontend subscribes to chat updates and redirects when complete

## Files Changed

- `/expo-app/app/(app)/generate-document.tsx` - Now creates document and inserts chat message
- `/scripts/document-chat-listener.js` - Node.js realtime listener
- `/supabase/migrations/20250129_create_document_chats.sql` - Database migration

## Benefits of This Architecture

1. **Decoupled Processing**: Frontend doesn't wait for generation
2. **Retry Logic**: Listener can retry failed generations
3. **Chat History**: All prompts and responses are stored
4. **Real-time Updates**: Using Supabase realtime for instant updates
5. **Local Development**: Easy to debug and modify the listener

## Troubleshooting

If the listener doesn't show "Successfully subscribed":
- Check that the migration was applied successfully
- Verify the table exists in Supabase Dashboard
- Check the listener console for any error messages

If generation doesn't start:
- Check the listener is running
- Verify the chat message was inserted (check Supabase Dashboard)
- Look for errors in the listener console

If the document doesn't update:
- Check the edge function logs in Supabase Dashboard
- Verify the `generate-document-stream` function is deployed
- Check for API key issues in the edge function